<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <title>Rayjun 的博客</title>
    <meta name="description" content="发现自己 - https://rayjun.wtf">
    <meta name="keywords" content="程序员,算法,Go,Java,Rayjun,区块链">
    <meta charset="utf-8">
    
        
            
<link rel="stylesheet" href="/css/lemon.css">

        
    
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/github.min.css">

    
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script>

    
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.slim.min.js"></script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-E9HMN12DB9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-E9HMN12DB9');
     </script>
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    <div class="menu-outer">
        <div class="container">
            <a class="blog-name" href="/">rayjun 的博客</a>
            <nav class="menu-inner">
                
                    <a class="menu" href="/">首页</a>
                
                    <a class="menu" href="/archives">归档</a>
                
                    <a class="menu" href="/about">关于</a>
                
            <div class="menu nav-search">
                <span>
                    <i class="fa fa-search"></i>
                </span>
                <input type="text" autocomplete="off" name="search" placeholder="搜索" id="local-search-input">
            </div>
            </nav>
        </div>
    </div>

    <div class="content">
        <div class="container">
            <div class="content-left">
                <div class="content-inner">
                    <div id="local-search-result"></div>
                    <div id="div-body">
                    <article class="post">
    <h1>如何打造一个高效的工作环境</h1>
    <p>这篇文章并不是我一个人独立完成的，感谢<a href="https://coolshell.cn/" target="_blank" rel="noopener">皓哥</a>帮忙改稿和补充，也感谢其他同学的校对，才有了这篇文章。</p>
<hr>
<p>程序员是一个很懒的群体，总想着能够让代码为自己干活，他们不断地把工作生活中的一些事情用代码自动化了，从而让整个社会的效率运作地越来越高。所以，程序员在准备去优化这个世界的时候，都会先要优化自己的工作环境，是所谓“工欲善其事，必先利其器”。</p>
<p>我们每个程序员都应该打造一套让自己更为高效的工作环境。那怕就是让你少输入一次命令，少按一次键，少在鼠标和键盘间切换一次，都会让程序员的工作变得更为的高效。所以，程序员一般需要一台性能比较好，不会因为开了太多的网页或程序就卡得不行的电脑，还要配备多个显示器，一个显示器写代码，一个查文档，一个测试运行结果，而不必在各种窗口来来回回的切换……在大量的窗口间切换经常会迷路，而且也容易出错（分不清线上或测试环境）……</p>
<p>除了硬件上的装备，软件上也是能够得升程序员生产力的地方，下面我们就想在软件层面说一下可以提升程序员生产力的一些东西。</p>
<p>这篇文章在查阅了很多资料以及结合自身的实践，从四个方面来说明如何打造一套适合自己的工具，分别是<strong>编辑器篇</strong>、<strong>命令行篇</strong>、<strong>Shell和脚本篇</strong>、<strong>版本管理篇</strong>。</p>
<h3>编辑器篇</h3>
<p>对于程序员来说，日常与编辑器打交道的时间非常长。编辑器是值得我们投入大量时间去学习并且定制来满足我们的需要。</p>
<p>如何选择合适的编辑器呢？编辑器有很多，有的值得投资时间去学习，有的基本就不用花时间去学。应当去学习那些能够提升生产力，有很强的生命力，并且能够适应各类环境的编辑器。</p>
<p><strong>Vim</strong> 和 <strong>Emacs</strong> 就是非常值得投资的编辑器，如果你决定开始学习 Vim/Emacs，刚开始的时候会感觉高很痛苦，甚至会伤害到自己的生产力，但是没关系，通过两三周的专注练习后，就可以通过学习编辑器的死亡之谷，很快就可以赚回票价了。</p>
<p>使用 Vim/Emacs 的另一个重要好处是，当你在处理一些线上问题的时候，有时候需要一个 IDE，你发现在一个Term 终端上是运行不了图形界面的编辑器了，你只有 Vim/Emacs 这样的选择。在 Coolshell 上有一篇《无插件Vim 编程技巧》（https://coolshell.cn/articles/11312.html）你可以移步一看。</p>
<p>为什么不学习 Notepad，因为，<strong>使用高效编辑器的终极目标是抛弃鼠标，让手编辑的速度可以跟的上大脑思考的速度</strong>。就我自己来说，从大二开始接触 Emacs 开始，已经使用 5 年了，通过不断的对 Emacs 进行定制，已经有了一套自己的使用模式了，每次打开 Emacs 就像是打开了自己才知道的秘籍，这是其他 IDE 都没有办法比的，通过不断定制自己的工具，可以激发自己创造的欲望。</p>
<p>但是我不参加编辑器的圣战，这些都是无意义的口水战。在一次接触了 Vim 之后，我反而喜欢上 Vim 的编辑模式了，于是在 Emacs 中使用上了 Vim 的编辑模式，实际的情况是这两者并不冲突（皓哥翻译的那篇 《简明 Vim 练级攻略》（https://coolshell.cn/articles/5426.html）文章非常不错）。</p>
<p>在 Emacs 上，有很多有用的特性和插件。 Emacs 的 <strong>org-mode</strong>，这个工具用来写作，还可用来做任务管理，任务计时器，甚至可以用来做表格的计算。功能上已经完全不是 markdown 能比的，但是遗憾的是目前只能在 Emacs 中使用（貌似有人在 Vim 上实现过）。</p>
<p>还有就是 Emacs 中的用来做文件管理的插件 <strong>helm</strong> 和 <strong>ivy</strong>，这两个插件完成的功能差不多，但是 helm 比较重量级一些，如果一个项目的代码量比较大时，文件的切换和搜索就没那么快了，所以我更喜欢轻量级的 ivy。</p>
<p>还有两个我最喜欢的插件，<strong>evil</strong> 和 <strong>magit</strong>，evil 可以让 Emacs 变身成为一个 Vim，大多数的 Vim 操作都可以覆盖上。magit 是一个可以使 Emacs 变身成为 Git 的插件。当然其他的各种语言的支持插件就是常规操作了，不多说。</p>
<p>下面推荐一些 Emacs 和 Vim 的学习资源:</p>
<p><strong>Emacs</strong></p>
<ul>
<li>
<p><strong>一年成为 Emacs 高手</strong>，当年我也是靠着这一篇文章真正入门 emacs,</p>
<p>https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org</p>
</li>
<li>
<p>陈斌 (一年成为 Emacs 高手的作者)的 Emacs 配置，是一个很不错的配置，我现在使用的配置要就是从这个演化来的 https://github.com/redguardtoo/emacs.d</p>
</li>
<li>
<p>Steve Purcell 大牛的配置，很适合 Web 开发者：https://github.com/purcell/emacs.d</p>
</li>
<li>
<p>Spacemacs 配置，适合新手，有着非常完善的文档：https://github.com/syl20bnr/spacemacs</p>
</li>
<li>
<p>reddit 的 Emacs 频道，最前沿的 Emacs 技巧：https://www.reddit.com/r/emacs/</p>
</li>
<li>
<p>Emacs org-mode 的文档，从这个文档中你可以发现纯文本的魔力：https://orgmode.org/</p>
</li>
<li>
<p>Emacs Wiki，上面有大量的 Emacs 插件的实践，虽然质量参差不齐，但是也有很多优秀的插件 https://www.emacswiki.org/emacs/EmacsWiki</p>
</li>
</ul>
<p><strong>Vim</strong></p>
<ul>
<li>Doist 创业公司 CEO amix 的 Vim 配置，被称之为最强 vimrc：https://github.com/amix</li>
<li>junegunn 是韩国的一个大牛，擅长写 Vim 插件，他的 Vim 插件看起来总是令人赏心悦目：https://github.com/junegunn/vim-plug</li>
<li>SpaceVim，一个开箱即用的 Vim 配置，对新手很友好，和 Spacemacs 一样，有着很完善的文档：https://github.com/SpaceVim/SpaceVim</li>
<li>reddit 的 Vim 频道，有很多最前沿的 Vim 技巧:https://www.reddit.com/r/vim/</li>
</ul>
<h3>命令行篇</h3>
<p>一个好的、可定制的命令行环境可以给工作效率带来很大的提升。如果你还在使用这个，那就差点意思了：</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/shell/Image.png" alt=""></p>
<p>在不同的操作系统下，都有着很不错的命令行工具，比如 Mac 下的 <strong>Iterm2</strong>，Linux 下的原生命令行，如果你是在 Windows 下工作，问题也不大，因为 Windows 下现在有了 <strong>WSL</strong>。WSL 提供了一个由微软开发的Linux兼容的内核接口（不包含Linux内核代码），然后可以在其上运行GNU用户空间，例如 Ubuntu，openSUSE，SUSE Linux Enterprise Server，Debian和Kali Linux。这样的用户空间可能包含 Bash shell 和命令语言，使用本机 GNU/Linux 命令行工具（sed，awk 等），编程语言解释器（Ruby，Python 等），甚至是图形应用程序（使用主机端的X窗口系统）。</p>
<p>使用命令行可以完成所有日常的操作，新建文件夹（mkdir）、新建文件（touch）、移动（mv）、复制（cp）、删除（rm）等等。而且使用 Linux/Unix 命令行最好的方式是可以用 awk、sed、grep、xargs、find、sort 等等这样的命令，然后用管道把其串起来，就可以完成一个你想要的功能，尤其是一些简单的数据统计功能。这是Linux命令行不可比拟的优势。比如：</p>
<ul>
<li>查看连接你服务器 top10 用户端的 IP 地址：</li>
</ul>
<p><code>netstat -nat | awk '{print $5}' | awk -F ':' '{print $1}' | sort | uniq -c | sort -rn | head -n 10</code></p>
<ul>
<li>查看一下你最常用的10个命令：</li>
</ul>
<p><code>cat .bash_history | sort | uniq -c | sort -rn | head -n 10 (or cat .zhistory | sort | uniq -c | sort -rn | head -n 10</code></p>
<p>在命令行中使用 <strong>alias</strong>  可以将使用频率很高命令或者比较复杂的命令合并成一个命令，或者修改原生的命令。</p>
<p>下面这几个命令，可能是你天天都在敲的。所以，你应该设置成 alias 来提高效率</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alias nis&#x3D;&quot;npm install --save &quot;</span><br><span class="line">alias svim&#x3D;&#39;sudo vim&#39;</span><br><span class="line">alias mkcd&#x3D;&#39;foo()&#123; mkdir -p &quot;$1&quot;; cd &quot;$1&quot; &#125;; foo &#39;</span><br><span class="line">alias install&#x3D;&#39;sudo apt get install&#39;</span><br><span class="line">alias update&#x3D;&#39;sudo apt-get update &amp;&amp; sudo apt-get upgrade&#39;</span><br><span class="line">alias ..&#x3D;&quot;cd ..&quot;</span><br><span class="line">alias ...&#x3D;&quot;cd ..; cd ..&quot;</span><br><span class="line">alias www&#x3D;&#39;python -m SimpleHTTPServer 8000&#39;</span><br><span class="line">alias sock5&#x3D;&#39;ssh -D 8080 -q -C -N -f user@your.server&#39;</span><br></pre></td></tr></table></figure></p>
<p>你还可以参考如下的一些文章，看看别人是怎么用好 <code>alias</code> 的</p>
<ul>
<li>https://www.cyberciti.biz/tips/bash-aliases-mac-centos-linux-unix.html</li>
<li>https://www.digitalocean.com/community/questions/what-are-your-favorite-bash-aliases</li>
<li>https://www.linuxtrainingacademy.com/23-handy-bash-shell-aliases-for-unix-linux-and-mac-os-x/</li>
<li>https://brettterpstra.com/2013/03/31/a-few-more-of-my-favorite-shell-aliases/</li>
</ul>
<p>命令行中除了原生的命令之外，还有很多可以提升使用体验的工具。下面罗列一些很不错的命令，把原生的命令增强地很厉害:</p>
<ul>
<li>
<p><strong>fasd</strong> 增强了 <code>cd</code> 命令 (https://github.com/clvv/fasd)。</p>
</li>
<li>
<p><strong>bat</strong> 增强了 <code>cat</code> 命令 (https://github.com/sharkdp/bat)。如果你想要有语法高亮的 <code>cat</code>，可以试试 <strong>ccat</strong>(https://github.com/jingweno/ccat)</p>
</li>
<li>
<p><strong>exa</strong> 增强了 <code>ls</code> 命令(https://github.com/ogham/exa），如果你需要在很多目录上浏览各种文件 ，<strong>ranger</strong> 命令可以比 <code>cd</code> 和 <code>cat</code> 更有效率（https://github.com/ranger/ranger)，甚至可以在你的终端预览图片。</p>
</li>
<li>
<p><strong>fd</strong> 是一个比 <code>find</code> 更简单更快的命令(https://github.com/sharkdp/fd)，他还会自动地忽略掉一些你配置在 <code>.gitignore</code> 中的文件，以及 <code>.git</code> 下的文件。</p>
</li>
<li>
<p><strong>fzf</strong> 是另外一个很好用的文件搜索神器 (https://github.com/junegunn/fzf)，其主要是搜索当前目录以下的文件，还可以使用 <code>fzf --preview 'cat {}'</code> 边搜索文件边浏览内容。</p>
</li>
<li>
<p><code>grep</code> 是一个上古神器，然而，<strong>ack</strong> (https://beyondgrep.com/)、<strong>ag</strong> (https://github.com/ggreer/the_silver_searcher) 和 <strong>rg</strong> (https://github.com/BurntSushi/ripgrep) 是更好的grep，和上面的fd一样，在递归目录匹配的时候，会忽略到你配置在 .gitignore 中的规则。</p>
</li>
<li>
<p><code>rm</code> 是一个危险的命令，尤其是各种 <code>rm -rf …</code>，所以，<strong>trash</strong>（https://github.com/andreafrancia/trash-cli/) 是一个更好的删除命令。</p>
</li>
<li>
<p><code>man</code> 命令是好读文档的命令，但是man的文档有时候太长了，所以，你可以试式 <strong>tldr</strong>（https://github.com/tldr-pages/tldr) 命令，把文档上的一些示例整出来给你看。</p>
</li>
<li>
<p>如果你想要一个图示化的<code>ping</code>，你可以试试 <strong>prettyping</strong> (https://github.com/denilsonsa/prettyping) 。</p>
</li>
<li>
<p>如果你想搜索以前打过的命令，不要再用 Ctrl +R 了，你可以使用加强版的 <strong>hstr</strong> (https://github.com/dvorka/hstr) 。</p>
</li>
<li>
<p><strong>htop</strong> (https://hisham.hm/htop/） 是 top 的一个加强版。然而，还有很多的各式各样的top，比如：用于看IO负载的 <strong>iotop</strong> (http://guichaz.free.fr/iotop/)，网络负载的 <strong>iftop</strong> (http://www.ex-parrot.com/~pdw/iftop/), 以及把这些top都集成在一起的 <strong>atop</strong> (https://github.com/Atoptool/atop)。</p>
</li>
<li>
<p><strong>ncdu</strong> (https://dev.yorhel.nl/ncdu) 比 du 好用多了用。另一个选择是 nnn（https://github.com/jarun/nnn) 。</p>
</li>
<li>
<p>如果你想把你的命令行操作建录制成一个 SVG 动图，那么你可以尝试使用 <strong>asciinema</strong> (https://asciinema.org/) 和 <strong>svg-trem</strong> (https://github.com/marionebl/svg-term-cli) 。</p>
</li>
<li>
<p><strong>httpie</strong>(https://github.com/jakubroztocil/httpie) 是一个可以用来替代 curl 和 wget 的 http 客户端，httpie 支持 json 和语法高亮，可以使用简单的语法进行 http 访问: <code>http -v github.com</code>。</p>
</li>
<li>
<p><strong>tmux</strong> (https://github.com/tmux/tmux) 在需要经常登录远程服务器工作的时候会很有用，可以保持远程登录的会话，还可以在一个窗口中查看多个 shell 的状态。</p>
</li>
<li>
<p><strong>Taskbook</strong>(https://github.com/klaussinani/taskbook) 是可以完全在命令行中使用的任务管理器 ，支持 ToDo 管理，还可以为每个任务加上优先级。</p>
</li>
<li>
<p><strong>sshrc</strong> (sshrc：https://github.com/Russell91/sshrc ) 是个神器，在你登录远程服务器的时候也能使用本机的 shell 的 rc 文件中的配置。</p>
</li>
<li>
<p><strong>goaccess</strong> (https://github.com/allinurl/goaccess) 这个是一个轻量级的分析统计日志文件的工具，主要是分析各种各样的 access log。</p>
</li>
</ul>
<p>关于这些增加命令，参考自下面的这些文章</p>
<ol>
<li>https://dev.to/_darrenburns/10-tools-to-power-up-your-command-line-4id4</li>
<li>https://dev.to/_darrenburns/tools-to-power-up-your-command-line-part-2-2737</li>
<li>https://dev.to/_darrenburns/power-up-your-command-line-part-3-4o53</li>
<li>https://darrenburns.net/posts/tools/</li>
<li>https://hacker-tools.github.io/</li>
</ol>
<h3>Shell 和脚本篇</h3>
<p>shell 是可以与计算机进行高效交互的文本接口。shell 提供了一套交互式的编程语言（脚本），shell的种类很多，比如 <strong>sh</strong>、<strong>bash</strong>、<strong>zsh</strong> 等。</p>
<p>shell 的生命力很强，在各种高级编程语言大行其道的今天，很多的任务依然离不开 shell。比如可以使用 shell 来执行一些编译任务，或者做一些批处理任务，初始化数据、打包程序等等。</p>
<p>写一个脚本很简单，<strong>touch zsh-script.sh</strong>：</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/zsh</span></span><br><span class="line">echo Hello shell</span><br></pre></td></tr></table></figure></p>
<p>一个脚本就写完了，<strong>#!/bin/zsh</strong> 表示使用的是哪种 shell。写完之后需要给脚本加上执行的权限:</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给脚本执行的权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x zsh-script.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行脚本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./zsh-script.sh</span></span><br></pre></td></tr></table></figure></p>
<p>脚本的语法很简单，而且可以在脚本中使用命令行的所有命令。还有很多其他有意思的玩法，比如在后台运行：</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./zsh-script.sh &amp;</span></span><br></pre></td></tr></table></figure></p>
<p>还有可以定时执行，在 <strong>crontab</strong> 加入：</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /home/ray/zsh-script.zsh</span><br></pre></td></tr></table></figure></p>
<p>crontab 是 Linux 中的一个定时器，可以定制执行任务，上面的表示每分钟执行一次脚本。</p>
<p>我最喜欢的就是 <strong>zsh</strong> + <strong><a href="https://ohmyz.sh/" target="_blank" rel="noopener">oh-my-zsh</a></strong> + <strong><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">zsh-autosuggestions</a></strong> 的组合，你也可以试试看。其中 zsh 和 oh-my-zsh 算是常规操作了，但是 zsh-autosuggestions 特别有用，可以超级快速的帮你补全你输入过的命令，让命令行的操作更加高效。 只需要简单的安装配置，你的命令行马上变得高档大气上档次，狂拽炫酷吊炸天。</p>
<p>另外，<strong><a href="https://fishshell.com/" target="_blank" rel="noopener">fish</a></strong> 也是另外一个牛逼的shell，比如：命令行自动完成（根据历史记录），命令行命令高亮，当你要输入命令行参数的时候，自动提示有哪些参数…… fish在很多地方也是用起来很爽的。和上面的 oh-my-zsh 有点不分伯仲了。</p>
<p>你也许会说，用 Python 脚本或 PHP 来写脚本会比 Shell 更好更没有 bug，但我要申辩一下:</p>
<ul>
<li>其一，如果你有一天要维护线上机器的时候，或是到了银行用户的系统（与外网完全隔离，而且服务器上没有安装 Python/PHP 或是他们的的高级库，那么，你只有 Shell 可以用了）。</li>
<li>其二，而且，如果要跟命令行交互很多的话，Shell 是不二之选，试想一下，如果你要去 100 台远程的机器上查access.log 日志中有没有某个错误，完成这个工作你是用 PHP/Python 写脚本快还是用 Shell 写脚本快呢？</li>
</ul>
<p>要写好一个脚本并不容易，下面有一些小模板供你参考：</p>
<p>处理命令行参数的一个样例</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">while [ &quot;$1&quot; !&#x3D; &quot;&quot; ]; do</span><br><span class="line">    case $1 in</span><br><span class="line">        -s  )   shift	</span><br><span class="line">		SERVER&#x3D;$1 ;;  </span><br><span class="line">        -d  )   shift</span><br><span class="line">		DATE&#x3D;$1 ;;</span><br><span class="line">	--paramter|p ) shift</span><br><span class="line">		PARAMETER&#x3D;$1;;</span><br><span class="line">        -h|help  )   usage # function call</span><br><span class="line">                exit ;;</span><br><span class="line">        * )     usage # All other parameters</span><br><span class="line">                exit 1</span><br><span class="line">    esac</span><br><span class="line">    shift</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>命令行菜单的一个样例</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Bash Menu Script Example</span><br><span class="line"></span><br><span class="line">PS3&#x3D;&#39;Please enter your choice: &#39;</span><br><span class="line">options&#x3D;(&quot;Option 1&quot; &quot;Option 2&quot; &quot;Option 3&quot; &quot;Quit&quot;)</span><br><span class="line">select opt in &quot;$&#123;options[@]&#125;&quot;</span><br><span class="line">do</span><br><span class="line">    case $opt in</span><br><span class="line">        &quot;Option 1&quot;)</span><br><span class="line">            echo &quot;you chose choice 1&quot;</span><br><span class="line">            ;;</span><br><span class="line">        &quot;Option 2&quot;)</span><br><span class="line">            echo &quot;you chose choice 2&quot;</span><br><span class="line">            ;;</span><br><span class="line">        &quot;Option 3&quot;)</span><br><span class="line">            echo &quot;you chose choice $REPLY which is $opt&quot;</span><br><span class="line">            ;;</span><br><span class="line">        &quot;Quit&quot;)</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">        *) echo &quot;invalid option $REPLY&quot;;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>颜色定义，你可以使用 <code>echo -e &quot;${Blu}blue ${Red}red ${RCol}etc....&quot;</code> 进行有颜色文本的输出</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RCol&#x3D;&#39;\e[0m&#39;    # Text Reset</span><br><span class="line"></span><br><span class="line"># Regular           Bold                Underline           High Intensity      BoldHigh Intens     Background          High Intensity Backgrounds</span><br><span class="line">Bla&#x3D;&#39;\e[0;30m&#39;;     BBla&#x3D;&#39;\e[1;30m&#39;;    UBla&#x3D;&#39;\e[4;30m&#39;;    IBla&#x3D;&#39;\e[0;90m&#39;;    BIBla&#x3D;&#39;\e[1;90m&#39;;   On_Bla&#x3D;&#39;\e[40m&#39;;    On_IBla&#x3D;&#39;\e[0;100m&#39;;</span><br><span class="line">Red&#x3D;&#39;\e[0;31m&#39;;     BRed&#x3D;&#39;\e[1;31m&#39;;    URed&#x3D;&#39;\e[4;31m&#39;;    IRed&#x3D;&#39;\e[0;91m&#39;;    BIRed&#x3D;&#39;\e[1;91m&#39;;   On_Red&#x3D;&#39;\e[41m&#39;;    On_IRed&#x3D;&#39;\e[0;101m&#39;;</span><br><span class="line">Gre&#x3D;&#39;\e[0;32m&#39;;     BGre&#x3D;&#39;\e[1;32m&#39;;    UGre&#x3D;&#39;\e[4;32m&#39;;    IGre&#x3D;&#39;\e[0;92m&#39;;    BIGre&#x3D;&#39;\e[1;92m&#39;;   On_Gre&#x3D;&#39;\e[42m&#39;;    On_IGre&#x3D;&#39;\e[0;102m&#39;;</span><br><span class="line">Yel&#x3D;&#39;\e[0;33m&#39;;     BYel&#x3D;&#39;\e[1;33m&#39;;    UYel&#x3D;&#39;\e[4;33m&#39;;    IYel&#x3D;&#39;\e[0;93m&#39;;    BIYel&#x3D;&#39;\e[1;93m&#39;;   On_Yel&#x3D;&#39;\e[43m&#39;;    On_IYel&#x3D;&#39;\e[0;103m&#39;;</span><br><span class="line">Blu&#x3D;&#39;\e[0;34m&#39;;     BBlu&#x3D;&#39;\e[1;34m&#39;;    UBlu&#x3D;&#39;\e[4;34m&#39;;    IBlu&#x3D;&#39;\e[0;94m&#39;;    BIBlu&#x3D;&#39;\e[1;94m&#39;;   On_Blu&#x3D;&#39;\e[44m&#39;;    On_IBlu&#x3D;&#39;\e[0;104m&#39;;</span><br><span class="line">Pur&#x3D;&#39;\e[0;35m&#39;;     BPur&#x3D;&#39;\e[1;35m&#39;;    UPur&#x3D;&#39;\e[4;35m&#39;;    IPur&#x3D;&#39;\e[0;95m&#39;;    BIPur&#x3D;&#39;\e[1;95m&#39;;   On_Pur&#x3D;&#39;\e[45m&#39;;    On_IPur&#x3D;&#39;\e[0;105m&#39;;</span><br><span class="line">Cya&#x3D;&#39;\e[0;36m&#39;;     BCya&#x3D;&#39;\e[1;36m&#39;;    UCya&#x3D;&#39;\e[4;36m&#39;;    ICya&#x3D;&#39;\e[0;96m&#39;;    BICya&#x3D;&#39;\e[1;96m&#39;;   On_Cya&#x3D;&#39;\e[46m&#39;;    On_ICya&#x3D;&#39;\e[0;106m&#39;;</span><br><span class="line">Whi&#x3D;&#39;\e[0;37m&#39;;     BWhi&#x3D;&#39;\e[1;37m&#39;;    UWhi&#x3D;&#39;\e[4;37m&#39;;    IWhi&#x3D;&#39;\e[0;97m&#39;;    BIWhi&#x3D;&#39;\e[1;97m&#39;;   On_Whi&#x3D;&#39;\e[47m&#39;;    On_IWhi&#x3D;&#39;\e[0;107m&#39;;</span><br></pre></td></tr></table></figure></p>
<p>取当前运行脚本绝对路径的示例：（注：Linux下可以用 <code>dirname $(readlink -f $0)</code> ）</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FILE&#x3D;&quot;$0&quot;</span><br><span class="line">while [[ -h $&#123;FILE&#125; ]]; do</span><br><span class="line">    FILE&#x3D;&quot;&#96;readlink &quot;$&#123;FILE&#125;&quot;&#96;&quot;</span><br><span class="line">done</span><br><span class="line">pushd &quot;&#96;dirname &quot;$&#123;FILE&#125;&quot;&#96;&quot; &gt; &#x2F;dev&#x2F;null</span><br><span class="line">DIR&#x3D;&#96;pwd -P&#96;</span><br><span class="line">popd &gt; &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure></p>
<p>如何在远程服务器运行一个本地脚本</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#无参数</span><br><span class="line">ssh user@server &#39;bash -s&#39; &lt; local.script.sh</span><br><span class="line"></span><br><span class="line">#有参数</span><br><span class="line">ssh user@server ARG1&#x3D;&quot;arg1&quot; ARG2&#x3D;&quot;arg2&quot; &#39;bash -s&#39; &lt; local_script.sh</span><br></pre></td></tr></table></figure></p>
<p>如何检查一个命令是否存在，用 <code>which</code> 吗？最好不要用，因为很多操作系统的 <code>which</code> 命令没有设置退出状态码，这样你不知道是否是有那个命令。所以，你应该使用下面的方式。</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># POSIX 兼容:</span><br><span class="line">command -v &lt;the_command&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># bash 环境:</span><br><span class="line">hash &lt;the_command&gt; </span><br><span class="line">type &lt;the_command&gt; </span><br><span class="line"></span><br><span class="line"># 示例：</span><br><span class="line">gnudate() &#123;</span><br><span class="line">    if hash gdate 2&gt;&#x2F;dev&#x2F;null; then</span><br><span class="line">        gdate &quot;$@&quot;</span><br><span class="line">    else</span><br><span class="line">        date &quot;$@&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，如果要写出健壮性更好的脚本，下面是一些相关的技巧：</p>
<ul>
<li>使用 <code>-e</code> 参数，如：<code>set -e</code> 或是 <code>#!/bin/sh -e</code>，这样设置会让你的脚本出错就会停止运行，这样一来可以防止你的脚本在出错的情况下还在拼拿地干活停不下来。</li>
<li>使用 <code>-u</code> 参数，如： <code>set -eu</code>，这意味着，如果你代码中有变量没有定义，就会退出。</li>
<li>对一些变理，你可以使用默认值。如：<code>${FOO:-'default'}</code></li>
<li>处理你代码的退出码。这样方便你的脚本跟别的命令行或脚本集成。</li>
<li>尽量不要使用 <code>;</code> 来执行多个命令，而是使用 <code>&amp;&amp;</code>，这样会在出错的时候停止运行后续的命令。</li>
<li>对于一些字符串变量，使用引号括起，避免其中有空格或是别的什么诡异字符。</li>
<li>如果你的脚有参数，你需要检查脚本运行是否带了你想要的参数，或是，你的脚本可以在没有参数的情况下安全的运行。</li>
<li>为你的脚本设置 <code>-h</code> 和 <code>--help</code> 来显示帮助信息。千万不要把这两个参数用做为的功能。</li>
<li>使用 <code>$()</code> 而不是 `` 来获得命令行的输出，主要原因是易读。</li>
<li>小心不同的平台，尤其是 MacOS 和 Linux 的跨平台。</li>
<li>对于 <code>rm -rf</code> 这样的高危操作，需要检查后面的变量名是否为空，比如：<code>rm -rf $MYDIDR/*</code> 如果 <code>$MYDIR</code>为空，结果是灾难性的。</li>
<li>考虑使用 &quot;find/while&quot; 而不是 “for/find”。如：<code>for F in $(find . -type f) ; do echo $F; done</code> 写成 <code>find . -type f | while read F ; do echo $F ; done</code> 不但可以容忍空格，而且还更快。</li>
<li>防御式编程，在正式执行命令前，把相关的东西都检查好，比如，文件目录有没有存在。</li>
</ul>
<p>最后推荐一些 Shell 和脚本的参考资料。</p>
<p>各种有意思的命令拼装，一行命令走天涯:</p>
<ul>
<li>http://www.bashoneliners.com/</li>
<li>http://www.shell-fu.org/</li>
<li>http://www.commandlinefu.com/</li>
</ul>
<p>下面是一些脚本集中营，你可以在里面淘到各种牛X的脚本：</p>
<ul>
<li>http://www.shelldorado.com/scripts/</li>
<li>https://snippets.siftie.com/public/tag/bash/</li>
<li>https://bash.cyberciti.biz/</li>
<li>https://github.com/alexanderepstein/Bash-Snippets</li>
<li>https://github.com/miguelgfierro/scripts</li>
<li>https://github.com/epety/100-shell-script-examples</li>
<li>https://github.com/ruanyf/simple-bash-scripts</li>
</ul>
<p>甚至写脚本都可以使用框架:</p>
<ul>
<li>写bash脚本的框架  https://github.com/Bash-it/bash-it</li>
</ul>
<p>Google的Shell脚本的代码规范：</p>
<ul>
<li>https://google.github.io/styleguide/shell.xml</li>
</ul>
<p>最后，别忘了几个和shell有关的索引资源：</p>
<ul>
<li>https://github.com/alebcay/awesome-shell</li>
<li>https://github.com/awesome-lists/awesome-bash</li>
<li>https://terminalsare.sexy/</li>
</ul>
<h3>版本管理篇</h3>
<p>版本管理的工具对我来说已经不仅仅不是管理代码的工具了。任何需要不断优化，不断修改的内容都需要进行版本管理。</p>
<p>版本管理的工具很多。现在还有好些人还不喜欢 Git 还在用 svn，那是因为他们并不知道 Git 的强大之处，这种脱机的版本管理可以让你在没有网的情况下提效代码变更，再加上 Git 切换 branch 快得不行，merge branch 时会把 branch 的改动情况一同 merge 了，这样可以让你看到整个历史。再有 stash，cherry-pick 等等这样的黑魔法加持，你的工作效率真的很爽的。如今最好用的应该就是 <strong>Git</strong> 了，在加上最近 <strong>GitHub</strong> 私有仓库的开放，让这一优势继续扩大。</p>
<p>Git 这么好用的原因来源于其底层数据结构的设计，非常的有意思，如果你接触过区块链，你会发现 Git 底层的数据结构与区块链的数据结构有异曲同工之处。</p>
<p>Git 除了可以完成通常的版本管理之外，它还拥有一些很神奇的技能：</p>
<ul>
<li>帮你找 bug 的命令: <strong>git bisect</strong>，通过二分搜索的方式来帮助你定位到引入 bug 的 commit。</li>
<li>可以帮助你洞察一切的 <strong>git blame</strong> 可以给你文件的每行信息都进行注释，然后就可以看到关于该行修改的每一次 commit 的哈希标签、作者和提交日期。</li>
<li>可以帮你恢复一切的 <strong>git reflog</strong>，通常我们 <strong>git reset</strong> 命令都是慎用的，要不然就坏事了，但是 git relog 在你将变化提交之前，可以帮助你回到任何修改之前，包括 git reset。但是 reflog 只是保存在本地，而且不是永久保存，有一个可以配置的过期时间。</li>
</ul>
<p>除此之外，还有一些 Git 的小技巧：</p>
<ul>
<li>如果你当前修改的文档在你本地的master上，然后你想把这个修改迁移到一个branch上，这样方便你做PR，如果这些修改还没有被add，那么你可以使用 <code>git checkout -b new_branch_name</code> 来完成。</li>
<li>如果你commit后，还没有push，你想修改一下这前的commit，你可以使用 <code>git commit --amend</code></li>
<li>使用 <code>git pull --rebase</code> 可以避免出现一个 merge buble。</li>
<li>如果你要删除远程分支，可以使用 <code>git push origin --delete &lt;remote-branchname&gt;</code></li>
<li>使用 <code>git add -p</code> 可以让你挑选修改，这样你可以把你的一次大改动变成多个提交。</li>
<li><code>git checkout -p</code> 和 <code>git add -p</code> 类似，如果让你挑选你想checkout的修改。</li>
<li>你知道你可以使用时间在你的git命令行上吗？比如：<code>git diff HEAD@{'2 months ago'}</code> 或 <code>git diff HEAD@{yesterday}</code> 或 <code>git diff HEAD@{'2010-01-01 12:00:00'}</code></li>
</ul>
<p>有时候，设置一下 Git 的别名也是可以让你更高效工作的一件事，比如：</p>
<p>使用如下的 <code>git lg</code> 别名</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --&quot;</span><br></pre></td></tr></table></figure></p>
<p>就可以把原来的 <code>git log</code> 的输出</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/git/git.log_.01.png" alt=""></p>
<p>变成下面这个样子</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/git/git.log_.02.png" alt=""></p>
<p>除此之外，Git 还有好些比较有用的别名，下面这几个收集库，可以让你更高效更赏心悦目地使用 Git</p>
<ul>
<li>https://github.com/momeni/gittify</li>
<li>https://github.com/GitAlias/gitalias</li>
<li>https://gist.github.com/mwhite/6887990</li>
</ul>
<p>Git 有多种用法，可以使用原生的 Git 命令行，原生的 Git 命令加上 shell 脚本的包装就可以做到很高效了。 Git 也有图形化的界面，比如 Git 安装包自带的 gitk 或者 TortoiseGit，因为比起命令行来太慢了。还有就是 magit，这是 Emacs 的一个插件，这个插件将所有 Git 的操作都融入到 Emacs 中了，只需要使用使用快捷键就能够完成 Git 的所有操作，但是同时又带有一点图形化的感觉，这么说有点苍白无力，看图:</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/emacs/emacs-git.jpg" alt=""></p>
<p>我现在日常会使用 Git 来进行代码管理、博客文章的管理和自己的知识库的管理。这些内容使用版本管理起来的好处是可以看见自己的成长过程，每一次修改的内容，每一个想法的进化。</p>
<p>下面推荐一下 Git 的学习资料:</p>
<ul>
<li>Progit2，最好的深入学习 Git 的教材，而且是开源的https://github.com/progit/progit2</li>
<li>Magit，Git 在 Emacs 上的打开方式：https://magit.vc/</li>
<li>Vim-fugitive，Git 在 Vim 上的打开方式：https://github.com/tpope/vim-fugitive</li>
<li>Git 相关的 shell 提示： https://github.com/magicmonty/bash-git-prompt</li>
</ul>
<p>Happy hacking！</p>
<p>(完)</p>

</article>


                    </div>
                </div>
            </div>
            <div class="content-right">
                <div class="context-box">
                    <div class="wechat">
    <div class="header">
        <img src="/images/wechat.jpeg">
    </div>
</div>
                </div>
            </div>
        </div>
    </div>
    <div class="bottom-outer">
        <div class="bottom-inner">
            <span>© 2022 Rayjun</span>
            <span>&nbsp;&nbsp; PowerBy <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></span>
        </div>
    </div>
    
        
        
<script src="/js/lemon.js"></script>

        
    
</body>
</html>