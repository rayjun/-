<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git_workflow</title>
    <url>/2015/01/28/2015-01-28-git_workflow/</url>
    <content><![CDATA[<p>####ssh
在日常的开发中，我们已经不能够离开的了git了。而在团队开发的时候，可能会用到一个git服务器。这个时候，ssh 就有用了，ssh key帮助我们在自己的电脑于git服务器之间建立一个安全的连接。这样就不用在每次提交的时候都要输入密码。只要将生成ssh key放到服务起上就行。</p>
<h5>在本机上生成ssh key</h5>
<h6>linux和mac os上</h6>
<p>在这两种系统上直接使用以下的命令就成：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;$your_email&quot;</span><br></pre></td></tr></table></figure>
在执行完上面的命令之后，在你的<code>~/.ssh/</code>目录下就会生成<code>id_rsa.pub</code>文件，这里面的内容就是生成的ssh key了，将里面的内容直接拷贝到服务器上就可以。</p>
<h6>在windows</h6>
<p>windows永远都是特立独行的。在windows上用上面的办法是行不通的。得找其他的方法，首先确保在windows上安装了git。然后按照如下的步骤：</p>
<ul>
<li>从git的程序目录打开 <code>Git Bash</code></li>
<li>敲入跟上面一样的命令<code>ssh-keygen -t rsa -C &quot;$your_email&quot;</code></li>
<li>在<code>C:\Users\$your_name\.ssh</code>文件夹下会生成ssh key。</li>
<li>最后将这个ssh key放到服务器上就可行了。</li>
</ul>
<h5>在一台电脑上管理多个ssh key</h5>
<p><a href="http://yijiebuyi.com/blog/f18d38eb7cfee860c117d629fdb16faf.html" target="_blank" rel="noopener">同一台电脑上管理多个ssh key</a></p>
<h4>Git工作流</h4>
<h5>克隆项目</h5>
<p>从服务器端将项目克隆到本地：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@emample.com:project-name.git</span><br></pre></td></tr></table></figure></p>
<h5>创建一个新的分支</h5>
<p>想要为了实现一个新的功能而开启的另一个分支：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b $feature_name</span><br></pre></td></tr></table></figure></p>
<h5>完成代码后，提交它</h5>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -am &quot;My feature is ready&quot;</span><br></pre></td></tr></table></figure></p>
<h5>将提交的新代码推送到服务器上</h5>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin $feature_name</span><br></pre></td></tr></table></figure></p>
<h5>工作收尾</h5>
<p>在提交代码之后，就可以在页面上看到自己最新提交的代码。然后你就可以去创建一个合并的请求，你的team leader在看到这些请求之后就会去察看这些代码，如果没有问题，就可以顺利的合并了。在git的模式下，工作就是这么简单。</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>最好的json转换器-fastjson</title>
    <url>/2015/01/24/2015-01-24-%E6%9C%80%E5%A5%BD%E7%9A%84json%E8%BD%AC%E6%8D%A2%E5%99%A8-fastjson/</url>
    <content><![CDATA[<h4>FastJson简介</h4>
<p>FastJson是由阿里巴巴工程师开发的一款处理json对象的工具包，号称是最快的json处理器， 比JackJson（也是号称最快的）还快，当然这个速度我是没有去测试过，使用这个是因为觉得这个 工具好用。功能强大，完全支持Java Bean、集合、Map、日期、Enum，支持范型，支持自省； 无依赖，能够直接运行在Java SE 5.0以上版本；支持Android；开源 (Apache 2.0)</p>
<h4>FastJson优势</h4>
<p>其实之前一直是用其他的工具来处理Json与Java之间的转化，因为平时处理的Json都不是特别复杂 的数据，所以一般的工具也是可以应付的来。可是上回处理Json的时候出了一个问题，就是其他的一些 工具没有办法完成复合对象的转化，下面我举个例子来说明下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> Class ClassRoom&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> roomId;</span><br><span class="line">  <span class="keyword">private</span> String roomName;</span><br><span class="line">  <span class="keyword">private</span> String garde;</span><br><span class="line">  <span class="keyword">private</span> String minister;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Student&gt; students = ArrayList&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于这个对象内部还有另一个List，在使用其他的Json转化工具的时候，没有办法将内部的那个List 也转化成Java对象，就是转的不完全，而使用fastjson则可以解决这个问题。</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>无声的沉默</title>
    <url>/2015/01/28/2015-01-28-%E6%97%A0%E5%A3%B0%E7%9A%84%E6%B2%89%E9%BB%98/</url>
    <content><![CDATA[<h4>不屈的抗争</h4>
<p>好吧，下定决心到现在已经很长时间了，但是收效甚微啊，真的不知是何原因。其实长时间这个状态也是很幸苦的。一直在做着事，却不知自己完成了哪些。但是也还是要一直这样子做些去的。早就决定不去做无意义的呻吟了。要动手。</p>
<h4>任务表</h4>
<p>一恍惚之间，一天又已经到了末尾了。可是要做的事情还是很多呀，想学的东西也还是很多呀。总之，一天有48小时就好了。哎，没办法，只好想着提高效率了。最近接触的东西有点多，让我来好好理理。</p>
<h5>技术重点</h5>
<p>在这个技术横飞的时代，想不受到诱惑都不行，但是无奈呀，精力有限，能做的事情也就那么点了，为了确实能让自己做一些事。只好默默地去抗拒那些诱惑了。回到正题上，重点要搞定的就是android和web了。android好说，就那点东西，用着用着就熟了，可是妹的，web的技术更新的有点快，跟着它跑是要被累死的节奏了。所以在追寻新技术的路上也只能是泪奔了。咳咳，怎么又跑了。web技术的面有点大，那么也只能是先打好基础了。php是一定要好好学基础的。laravel这个框架目前也是必学的，还得靠这个吃饭呢。本来也就完事了，可是发现，html和css不熟自己根本没办法独立的做出一个像样的网站呀，所以还是得学啊。还没完呢，项目不能是自己一个人做吧。得去跟别人合作，那么，git必学的吧，还好这个上手还是比较快的。git学好了，那么github也不能够放弃吧。当然这个也是必须的，作为一个程序员来说。好吧，主要的技术就是这些了。好像还不少呢。
- android
- php
- laravel
- html/html5
- css/bootstrap
- git/github
其实也还好了，我这是不是在自欺欺人~~</p>
<h5>其他技术</h5>
<p>作为一个怀抱着创业梦想的程序员来说，那么学习一下创业的课程也是很有必要的吧，那startup课程还是很有必要学的咯。创业的过程的中难免会与投资，理财之类的事情打交道，那么投资理财这方面的事情也得懂一点吧，当然，还有股票。感觉快要累死~。作为一个怀抱着顶级黑客梦想的程序员，怎么能不学lisp，特别是作为一个emacs的死忠。说的豪言壮语，但感觉都是在给自己挖坑啊。好吧，先就这么多吧，要不就真的该累死。
- startup
- 投资/股票/理财
- lisp/emacs</p>
<h5>目前要做的事</h5>
<p>好吧，如果在未来的一年时间里，能把那些事情完成的很好，那么也就没有啥压力了。但是自己还是有个真的很不好的习惯，为啥精力就是很难集中呢，这样一来，那得浪费多少呀。这个也是很需要解决的一个问题，目前最重要的就是跟着项目走，当然，还有一个毕设也是很蛋疼的。这样都是需要好好完成的。好吧，话不多讲，得重新进入状态了。那是必须的。</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>只是没思考</title>
    <url>/2015/03/07/2015-04-07-%E5%8F%AA%E6%98%AF%E6%B2%A1%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h4>只是没思考</h4>
<hr>
<p>也是有一段时间都没有来写文章了，包括在经历了某些好事之后，也没来得及写点什么。不过最近
经历的事情有点多，必须得好好消化了，要不然，在很多事情上，就会显得很茫然，不知道该如何
去下手处理。其实，这段时间看来，对于我来说，有件事情还是特别重要的，那就是，我发现我几乎
从来不会进入一个深度思考的境界，特别是最近发现这样做的后果越来越不好。觉得也是应该做点什
么了。我翻阅过去，发现自己只是没思考。</p>
<h4>没思考生活</h4>
<hr>
<p>从大学前几年的平凡到现在的忙碌，我的生活似乎发生了很大的变化，我开始积极的去面对我以后
会遇到的问题。每天都在忙碌，可是我却不知道我将去向何方，我越来越不知道生活应该是怎么样的。
或许，我只是没有思考清楚红酒与礼服在我的生活中应当怎样出现。低头赶路的日子是很辛苦的，没
有远方的景色，我如何能继续。远方的美景，是我即将要去的地方，至少是我想去的地方。她不应该
从我的视线里消失，而应该出现的我的脑海里。而那里需要我一步步的走过去才行，而我却没有思考
过如何来走好这一步步的路，发现在很多时候，我只是在原地转圈，却不知道自己已经没有了方向，
时间不应该就这样的被消耗掉，不是么？我必须得好好思考如何来用自己的时间才不会被浪费掉。
生活最不可辜负的就是姑娘与远方，不是么？</p>
<h4>没思考技术</h4>
<hr>
<p>其实还是蛮惭愧的，作为一个技术人员。很多时候我都发现自己没有真正意义上的拿的出手的技术。
我几乎从来没有思考过一种技术可以给我的生活带来什么样子的变化。我没有将这些技术带入到我的
生活，只是将他们束在梦想的高阁上，我没有使用这些工具来为我的生活作出一丝的改变，也不应该
是这样的。对于我来说，这些技术只是工具，我的想法，才是最重要的，技术可以将我的想法来实现。
而不能只是作为技术的傀儡，我的目标不是技术，而是我的想法，我的远方。更多的时候，我也希望
自己能够认清楚。技术的学习过程应该是高效的，而不能在上面花费太多的经历，学习的时候，应该
深入的去学习原理，而不是只学习表面，这样的话，会在学习一个东西时花费太多的时间。这样其实
比一开始就将原理学透花的时间要多的多。技术可以慢慢学，但是得好好学。</p>
<h4>没思考过人生</h4>
<hr>
<p>只有离开学校这个安乐窝之后才发现，生活远远都比我们想象种的要艰难的多。当然不是想把这个
世界想象的那么负面，但至少我们还是得正视一下事实。我们有时候思考事情总是会更多的站在自己
的角度上来思考这个事情。而没有从整个局面上来发现问题的所在，这样我们就会陷入到无尽的抱怨
当中，其实这样消耗的是自己。最好的方法莫过于好好思考，好好体会，好好提高。靠外在的东西终
归是会让自己陷入到一个弱势的群体中去。所一总的来说，静下心来努力的提高自己总是一个不错的
选择。人生的问题没有那么容易能够得到解答，而我们能做的，唯有不断的思考，学习，才能在这个
时代站稳脚，才能到达远方。</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>windows8配置homestead及laravel开发环境</title>
    <url>/2015/02/01/2015-02-01-windows8%E9%85%8D%E7%BD%AEhomestead%E5%8F%8Alaravel%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h4>准备工具</h4>
<p>一般来说，在windows上配置开发环境是一个很艰苦的事情。而vagrant的出现则是我们开发者的一个福利。大大的减轻了我们的配置的复杂新，但是虽然有所减轻，但还是要动手配一些的。话不多说，下面开始进入正题，首先来说下需要一些什么：</p>
<ol>
<li>windows已经装好了git，如果没装，<a href="http://git-scm.com/download/" target="_blank" rel="noopener">点这里</a></li>
<li>需要安装好php(只需要php，其他的都不需要，并且在php.ini里面开启openssl扩展)。</li>
<li>然后需要<a href="https://getcomposer.org/Composer-Setup.exe" target="_blank" rel="noopener">composer</a> 和<a href="https://www.vagrantup.com/" target="_blank" rel="noopener">vagrant</a> 和 <a href="https://www.virtualbox.org/" target="_blank" rel="noopener">virtualbox</a> 以及一个<a href="http://pan.baidu.com/s/1qWjuVdq" target="_blank" rel="noopener">homestead</a>。
以上就是配置环境所需的全部软件，下面我们来配环境。</li>
</ol>
<h4>配置流程</h4>
<p>简而言之，Homestead是laravel官方预封装好的一个基于virtualbox的linux虚拟机，在这个虚拟机里面安装好了一系列的软件Nginx、PHP 5.6、MySQL、Postgres、Redis、Memcached，足够laravel的开发。这个虚拟机可以很方便的启动，销毁，和重建。基本不会把你现有的操作系统搞得乱七八糟。下面简单说下安装流程：</p>
<h4>Composer安装</h4>
<p>Composer是php的一个依赖管理的工具，可以很方便的管理laravel开发过程中所需的一系列的扩展。是一个很重要的工具。直接打开上面下载的安装包安装就行，如果出现了错误，估计是没有在php里面开启ssl，重新开启一下就可以安装成功。</p>
<h4>Vagrant以及VirtualBox安装</h4>
<p>这两个也都是基于图形界面安装的，直接安装就行。需要说明的是要使用Virtualbox就需要开启硬件虚件支持(VT-X),在BIOS里面开启。</p>
<h4>配置虚拟机</h4>
<p>所需要的软件基本都安装完成了，接下来就是需要配置虚拟机了。</p>
<ol>
<li>
<p>将homestead加入到virtualbox中，在终端中运行以下代码(path是自己放置homestead的路径)：</p>
<pre><code>  vagrant box add laravel/homestead path\homestead.box
</code></pre>
</li>
<li>
<p>安装homestead命令行工具：</p>
<p>composer global require &quot;laravel/homestead=~2.0&quot;</p>
<p>一般在这里会出现一个ssl错误，这个是由于咱们的特殊的国情造成的，你们懂得，解决办法是使用国内的镜像，按照<a href="https://phphub.org/topics/85" target="_blank" rel="noopener">这里</a> 的方式在composer.json里面增加国内的镜像，再次执行以上的代码，就能够顺利的完成安装了。</p>
</li>
<li>
<p>初始化homestead</p>
<p>homestead init
执行后生成C:\Users&lt;username&gt;.homestead,homestead的配置文件就在里面了。</p>
</li>
<li>
<p>修改Homestead.yaml</p>
<p>ip: &quot;192.168.10.10&quot;
memory: 2048
cpus: 2</p>
<p>authorize: ~/.ssh/id_rsa.pub</p>
<p>keys:
- ~/.ssh/id_rsa</p>
<p>folders:
- map: ~/LaravelWorkspace
to: /home/vagrant/Code</p>
<p>sites:
- map: homestead.app
to: /home/vagrant/Code/laravel/public
hhvm: true</p>
<p>databases:
- homestead</p>
<p>variables:
- key: APP_ENV
value: local
LaravelWorkspace是一个代码共享区，在这里所做的修改立马就能反映到虚拟机里面去。其他的是一些包括站点和数据库的配置，具体的一些细节大家可以去laravel的官网看看详细的细节介绍。
然后上面的那个ssh密钥是要通过gitbash生成的，如下:</p>
<p>ssh-keygen -t rsa -C &quot;your@email.com&quot;
那个站点需要在windows的C:\Windows\System32\drivers\etc\hosts文件里面添加如下配置：</p>
<p>192.168.10.10  homestead.app</p>
</li>
<li>
<p>启动虚拟机</p>
<p>homestead up
执行以上代码一段时间之后，就应该可以看到虚拟机被启动起来了，然后通过 <code>http://homestead.app:8000</code> 或者<code>192.168.10.10</code>去访问你的laravel项目的首页了。</p>
</li>
</ol>
<h4>Homestead ssh问题</h4>
<p>本来环境在上一步就已经配置完成了，可是在windows上，命令行能力实在是有限，没有办法支撑起开发需求，因为windows命令行不支持ssh访问。这个确实比较蛋疼。大家当然也可以使用其他的ssh工具来访问虚拟机(用户名和密码都是vagrant).这里给大家推荐一款更强大的工具，就是chrome的secure shell，在网页上的终端，见过没。用这个就能很方便的去访问ssh，咱们的开发需求到这里也基本被满足了。</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>快速开发的一些想法</title>
    <url>/2015/04/17/2015-04-17-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>在我们目前的开发模式中，很多传统的开发思维已经不怎么适合如今的开发模式。我们需要的是一种更加灵活，更高效的开发模式。</p>
<h4>技术栈选择</h4>
<hr>
<p>技术栈的选择是一个很重要的选择，这个选择决定后续的项目的走向。开发的敏捷性，可迭代性在很大程度上也在依赖着技术栈的选择。虽然对不同的项目会有着不同的技术选型，但是开发的主体技术栈还是需要维持在一个稳定的状态。这样是有利于团队的工作流的稳定，开发也会更加有效率。然后可以定期的对技术栈进行一个更新。</p>
<h4>接口</h4>
<hr>
<p>接口是开发过程当中的一个核心，也就是业务逻辑的核心。我们在如今的开发中不需要去做大量的详细设计。那种方式是不适合我们如今的这种模式的。但是接口却是我们必须要做好的一件事。我们的接口设计就在很大的程度上取代了原来的详细设计。接口的设计成了我们开发过程中的核心。所以在动手代码之前，我们应该先尽量将接口详细化。</p>
<h4>数据交换格式</h4>
<hr>
<p>数据格式交换则又是另外一个层面的东西。所有的接口最终都会返回数据，而这种数据格式则是需要事先进行约定的，因为实际上交换的数据格式与逻辑是相关联的。只有在数据的层面理清之后我们才算是把整个系统的业务逻辑理解清楚。而只有在这样的基础之上，我们对于后续的迭代才不会乱。</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>我们必须在路上</title>
    <url>/2015/07/05/2015-07-05-%E6%88%91%E4%BB%AC%E5%BF%85%E9%A1%BB%E5%9C%A8%E8%B7%AF%E4%B8%8A/</url>
    <content><![CDATA[<p>两年之后，我如约出发，再次踏上了去西藏的路。这一次来的感受就与两年前不太一样了。只不过这一次，原计划中的尼泊尔时去不了了。我一直觉得，两年前的那次骑行事我性格的转折点。虽然我现在的性格也还是有很多的问题，但是在那次的旅行中，最为关键的困难被我克服了。对于我来说，或许是家族的遗传，让我对这个世界保持着愤怒。</p>
<h4>骑车</h4>
<p>骑自行车对我来说，真的是一个很宝贵的经历。在期间，我学会了坚持的含义，虽然现在做的也不好，但是我也还是在不断的往那方面去做。谁都知道坚持做就会有成果的，就好像知道坚持锻炼和合理的饮食就会有好的身材一样。但是做到的人确实寥寥无几。是因为大多数人毕竟是平凡的。在路上，你所有的脾气都无处可发，再怎么发脾气，山路还是那么长，还是那么陡，不会有任何的改变。除非放弃，否则这还是你必须要面对的。所以，一脚一脚踏上山顶才是最好的选择，少发脾气更容易保持体力。这也是一种做事的态度。在碰到一件招人烦的事情时，没有必要去对事情不满，将这个事情解决是你目前最为重要的事，其他的，都可以先放下。</p>
<h4>火车</h4>
<p>这次的旅行将骑车路上20多天的时间缩短为2天。这回可是带着一大帮的队友一起的，而不是独自一人上路。路上的旅途并不枯燥难耐。这么轻松的出游也确实是一件很惬意的事情，到了之后，感觉就像是到家了，没有任何的突兀。也不想拍照，只想安静的呆一会。相比于坚持，保持热情或许是一个更难的事情，一般只有对一件事情是发自心底的热爱才能保持长久的热情。但是热情也是可以培养的，我们在做事，当我们可以从做事本身不断的获得成就的时候，我们就可以对这件事保持长足的耐心与热情。而这样的成就，也是需要自己不断的去培养的。在新鲜事物曾出不穷的时候，如何对一件事情保持热情，也就变的越来越困难了。但是调整好心态，就还是可以的，不是么？</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>效率提升利器iterm-zsh-tmux</title>
    <url>/2015/07/05/2015-07-05-%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87%E5%88%A9%E5%99%A8iterm-zsh-tmux/</url>
    <content><![CDATA[<p>Mac 系统是一个很好的开发环境，在这个平台上有着大量的优秀的开发工具。利用好这些工具就可以很大程度上的提高工作效率。其中命令行就是一个使用频率很高的工具。一个好用的命令行可以帮助我们在各个环境下进行切换。其实 Mac 自带的 terminal 已经是一个很好用的工具，可是在 iterm＋zsh＋tmux的冲击下，就显得有些乏力了。</p>
<h4>Iterm</h4>
<p>iterm 解决了一个很重要的问题，就是对于快捷键的支持要远比 terminal 好。一般来说，快捷键使用的好就可以妥妥的提升工作效率。在 iterm中，可以支持分屏和快速切换，在这一点上就比 terminal 要好的多。而且 iterm 还有其他的很多特性。比如历史命令的自动补全，支持256色等。</p>
<h4>zsh</h4>
<p>zsh 是用来替代 teminal 中的 bash，因为默认的 bash 的版本实在有点老了。而且 zsh 完全兼容 bash，没有任何的历史负担，在 zsh 中，可以帮助你纠正拼写错误。而且有着更为强大的补全。</p>
<h4>tmux</h4>
<p>tmux 是一个很好的终端复用软件，可以同时运行多个终端，自由的在多个终端之间进行切换。</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>Git 工作流</title>
    <url>/2015/08/18/2015-08-18-Git%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<p>作为一个 <code>web</code> 开发者，<code>Git</code> 已经成为一个很重要的工具。我们现在已经习惯每天打开电脑，然后编码，然后将代码推送到 <code>Github</code> 服务器上。这几乎成为日常工作的标配，<code>Git</code> 也成为了一个极其重要的软件。再搭配上 <code>emacs</code> 的 <code>magit</code> 插件，就成为了开发的神器，当然这只是我自己的喜好。不过还是强烈推荐。回到正题。<code>Git</code> 很强大，是一款很好的团队协作软件，分支与合并是它最为强大的两个特性，正因为太过于强大也就带来了不少的问题。因为可以随意的创建分支与合并，所以导致项目的主线变得难以协调和维护。一个好的 <code>Git</code> 工作流将大大提高工作效率，让所有人的协作变的井井有条。下面的 <code>Git</code> 流是参考了 <a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank" rel="noopener">阮一峰的文章</a> 下面是一个推荐的工作流：</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015080501.png" alt="git"></p>
<h4>新建分支</h4>
<pre><code># 获取主干最新代码
$ git checkout master
$ git pull

# 新建一个开发分支myfeature
$ git checkout -b myfeature
</code></pre>
<h4>提交分支</h4>
<pre><code>$ git add .
$ git status
$ git commit
</code></pre>
<h4>撰写提交信息</h4>
<p>下面是一个范例：</p>
<pre><code>Present-tense summary under 50 characters

* More information about commit (under 72 characters).
* More information about commit (under 72 characters).

http://project.management-system.com/ticket/123
</code></pre>
<h4>与主干合并</h4>
<pre><code>$ git fetch origin
$ git rebase origin/master
</code></pre>
<h4>合并commit</h4>
<pre><code>$ git rebase origin/master
</code></pre>
<h4>推送到远程仓库</h4>
<pre><code>$ git push --force origin myfeature
</code></pre>
<h4>提交 Pull request</h4>
<p>提交到远程分支之后，就可以提交 <code>Pull request</code>,将代码合并到master。</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>laravel单元测试</title>
    <url>/2015/03/07/2015-03-07-laravel%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h4>laravel单元测试</h4>
<hr>
<p><strong>laravel</strong>的单元测试是基于<strong>phpunit</strong>的。基本上将<strong>phpunit</strong>全部都集成到了<strong>laravel</strong>中。所以在使用<strong>laravel</strong>的单元测试的时候，还是比较简单的。单独使用 <strong>phpunit</strong> 也还是需要做大量的配置，特别是对          <strong>Model</strong>或者<strong>Repository</strong>层进行测试的时候。但是在laravel中，提供了一个 <strong>testing</strong> 的环境，在这个环境中进行单元测试，就可以省略掉大量的配置。让单元测试的速度大大的增加。</p>
<h4>laravel环境</h4>
<hr>
<p>在 <strong>laravel</strong> 中，对于不同环境的设计是很不错的。大致上 <strong>laravel</strong>可以分为生产、开发、测试等环境。而我们在测试的时候就可以完全在这个测试环境中进行的。这个测试环境与生产和开发环境是完全独立开的，这样一来，在测试的时候就可以完全不去影响到其他的环境。我们的单元测试就可以在这个测试环境中完成。
在测试开始之前，将<strong>database.php</strong> 拷贝一份到<strong>app\config\testing</strong> 文件夹。在这个文件里配置单元测试的数据库环境。有一点需要注意的是，<strong>laravel</strong> 默认的数据库是 <strong>Mysql</strong> 如果要更换测试的数据库，则需要在 <strong>app\config\testing\database.php</strong> 中配置 <strong>'default' =&gt; 'your databse type'</strong>。比如在测试环境中可以使用<strong>sqllite</strong> 等数据库。做完这个配置之后，那么单元测试的数据库到此就算是配置完成了。</p>
<h4>单元测试</h4>
<hr>
<p><strong>laravel</strong> 对单元测试 有着很好的支持。基本上对<strong>phpunit</strong> 进行了一个很好的包装。但是在使用phpunit的时候，我们需要配置大量的环境。而在laravel中就不需要。只需要写一个个的测试用例。在laravel项目的test文件夹里面有一个例子来说名如何进行测试。写完测试用例之后直接在命令行运行<strong>vendor/bin/phpunit</strong>然后，所有的测试用例都可以执行。这样，一个简单但是功能完备的单元测试就配好了。</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>Coreseek 中文搜索引擎</title>
    <url>/2015/09/22/2015-09-22-Coreseek%E4%B8%AD%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h3>Coreseek 中文搜索引擎</h3>
<p>如今在一个网站或者一个 <strong>APP</strong> 中，站内搜索的功能很大程度上已经是必不可少的功能了。在这篇文章中我会详细的介绍如何为网站或者 <strong>APP</strong> 开发一个站内搜索的功能。</p>
<h4>Coreseek 简述</h4>
<p><strong>Coreseek</strong> 是一个基于 <strong>Sphinx</strong> 开发的支持中文搜索的搜索引擎。具有强大的分词模式，而且支持多种模式的匹配。而且可以支持多种数据源。将这个嵌入到引用中也是非常便捷的，下面来说以下详细的配置方式。本文的配置环境为 <strong>Ubuntu 14.04</strong>，安装的软件以 <strong>Sphinx-2.1.3</strong> 和 <strong>coreseek-4.1</strong> 为例。安装包可自行去官网下载。</p>
<h4>安装 Sphinx 与 Coreseek</h4>
<h5>安装 Sphinx</h5>
<pre><code>tar zxvf sphinx-2.1.3.tar.gz
cd sphinx-2.1.3
./configure --prefix=/usr/local/sphinx --with-mysql=/usr/local/mysql

sudo make &amp; make install
</code></pre>
<p>其中 <strong>--prefix</strong> 是指定安装路径，<strong>--with-mysql</strong> 是指mysql的安装路径。在这个地方需要特别注意如果 <strong>mysql</strong> 是编译安装在 <strong>/usr/local/mysql</strong> ，按照以上的方法可以顺利安装，如果是采用 <strong>apt-get</strong> 方法进行安装的，则上面的安装方法会失败，那么就得采用以下的安装方法:</p>
<pre><code>--with-mysql-includes=/usr/include/mysql
--with-mysql-libs=/usr/lib/mysql
</code></pre>
<p>这样就可以将 <strong>Sphinx</strong> 顺利的编译安装。安装完成后，就会在 <strong>／usr/local/sphinx/bin</strong> 目录下生成以下的目录:</p>
<pre><code>indexer #创建索引命令
searchd #启动进程命令
search #命令行搜索命令
</code></pre>
<p>然后在 <strong>/usr/local/sphinx/ect</strong> 目录下修改配置文件</p>
<pre><code>sudo cp sphinx.conf.dist sphinx.conf
</code></pre>
<h5>Coreseek 安装</h5>
<pre><code>tar zxvf coreseek-4.1.tar.gz
</code></pre>
<p>在解压完成之后，将会出现两个文件夹：csft-4.1、mmseg-3.2.14。其中 <strong>mmseg</strong> 是一个非常棒的中文分词算法，中文搜索也是建立在这个分词算法之上的。先来安装 <strong>mmseg</strong> ：</p>
<pre><code>cd mmseg-3.2.14
./configure --prefix=/usr/local/mmseg
</code></pre>
<p>一般来说上述会出现一个编译错误: &quot;config.status: error: cannot find input file: src/Makefile.in&quot;。这个错误是因为没有安装 <strong>automake</strong>，在安装完成之后，依次执行以下的命令：</p>
<pre><code>sudo apt-get install automake
aclocal
libtoolize --force
automake --add-missing
autoconf
autoheader
make clean
./configure --prefix=/usr/local/mmseg
make
sudo make install
</code></pre>
<p>安装完成后再安装csft(coreseek)：</p>
<pre><code>cd csft-4.1/
sh buildconf.sh
./configure --prefix=/usr/local/coreseek --with-mysql=/usr/local/mysql/ --with-mmseg=/usr/local/mmseg/ --with-mmseg-includes=/usr/local/mmseg/include/mmseg/ --with-mmseg-libs=/usr/local/mmseg/lib/
sudo make &amp;&amp; make install
</code></pre>
<p>安装完成之后，修改 <strong>/usr/local/coreseek/etc</strong> 中的配置文件：</p>
<pre><code>sudo cp sphinx.conf.dist csft.conf
</code></pre>
<p>然后在上面安装的过程当中，也会有一些坑，具体解决方法见<a href="http://blog.csdn.net/jcjc918/article/details/39032689" target="_blank" rel="noopener">这篇文章</a>。基本上，配置到这里就完成了，如果需要在程序中使用这些，就需要做一些额外的配置。具体见之前的参考文章，这篇文章主要是用来解决编译安装过程中的一些坑。在安装完成之后，如果要使用这个搜索引擎则需要做以下的事情:</p>
<ul>
<li>有数据源</li>
<li>建立 <strong>sphinx</strong>配置文件</li>
<li>生成索引</li>
<li>启动 <strong>searchd</strong> 服务进程，默认端口是9312</li>
<li>使用<strong>php</strong>(以php为例)去连接 sphinx 服务。</li>
</ul>
<h4>参考资料</h4>
<ul>
<li><a href="http://www.coreseek.cn/" target="_blank" rel="noopener">官方文档</a></li>
<li><a href="http://nonfu.me/p/6347.html" target="_blank" rel="noopener">安装参考</a></li>
<li><a href="http://blog.csdn.net/jcjc918/article/details/39032689" target="_blank" rel="noopener">去坑参考</a></li>
</ul>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>Laravel 中的 oauth2</title>
    <url>/2015/08/06/2015-08-06-Laravel%E4%B8%AD%E7%9A%84oauth2/</url>
    <content><![CDATA[<h4>Web Api</h4>
<p>Web 如今渐渐发展成为一种服务，会有一些程序使用 Web 服务，并且程序 与 Web 服务之间使用的是 HTTP 进行通信的。程序向 Web 服务发出 HTTP 请求，并接收其响应。这时，通信所使用的规则就是 Web Api。而 Api 也活成为未来的一个发展方向。</p>
<h4>dingo/api</h4>
<p>这是一个基于 composer 开发的用于管理 api 的一个工具，具体的配置如下：</p>
<pre><code>https://github.com/dingo/api/wiki
</code></pre>
<h4>lucadegasperi/oauth2-server-laravel</h4>
<p>这时一个基于 composer 开发的用于 oauth2 二次开发的一个工具包，具体的配置如下：</p>
<pre><code>https://github.com/lucadegasperi/oauth2-server-laravel/wiki
</code></pre>
<h4>具体应用</h4>
<p>本文不再赘述这两个组件的安装及配置，在下文之前，我们默认安装完成，迁移文件也已经执行。</p>
<h5>原理说明</h5>
<p>在这两个组件中，<code>dingo/api</code> 主要的作用是为 <code>Web Api</code> 服务提供统一的管理。而在这篇文章中，我们主要用到这个组件 <code>oauth2</code> 的部分。配合 <code>lucadegasperi/oauth2-server-laravel</code> 来完成完整的移动应用与后端的验证通信过程。本文的例子采用的是 <code>password</code> 的验证方法。</p>
<h5>具体实现</h5>
<p>在安装完成之后，在项目中会多出 <code>oauth2.php</code>, <code>api.php</code>等配置文件。我们的配置也将从这些文件展开。<code>lucadegasperi/oauth2-server-laravel</code> 这个组件主要是完成 <code>oauth2</code> 的具体验证和令牌的分发。在这次的实例中，我们采用的是 <code>password</code> 的验证方法，所以要在 <code>oauth2.php</code> 中做如下的配置：</p>
<pre><code>'grant_types' =&gt; [
    'password' =&gt; [
        'class'            =&gt; 'League\OAuth2\Server\Grant\PasswordGrant',
        'access_token_ttl' =&gt; 604800,

        // the code to run in order to verify the user's identity
        'callback'         =&gt; '\App\Repositories\Verifier@verify'
    ],
    'refresh_token' =&gt; [
        'class'                 =&gt; 'League\OAuth2\Server\Grant\RefreshTokenGrant',
        'access_token_ttl'      =&gt; 3600,

        // the refresh token time to live
        'refresh_token_ttl'     =&gt; 604800,

        // whether or not to issue a new refresh token when a new access token is issued
        'rotate_refresh_tokens' =&gt; false,
    ],
],
</code></pre>
<p>在以上配置中我们配置了基本的验证规则以及令牌刷新的方法，简单明了。注意到上面有一个 <code>callback</code> 方法，这个方法是用来贵基本的用户名密码进行验证的一个方法，具体实现如下：</p>
<pre><code>class Verifier {
    public function verify($username, $password)
    {
        $credentials = [
            'phone'    =&gt; $username,
            'password' =&gt; $password,
        ];

       if (Auth::once($credentials))
       {
           return Auth::user()-&gt;id;
       }

      return false;
   }
}
</code></pre>
<p>在以上的验证完成之后，就可以对客户端发送令牌：</p>
<pre><code>Route::post('oauth/access_token', function() {
    return Response::json(Authorizer::issueAccessToken());
});
</code></pre>
<p>具体参数如下：</p>
<pre><code>grant_type: password
client_id: test_id
client_secret: test_secret
username: rayjun
password: 12345
</code></pre>
<p>下面是一个返回的例子：</p>
<pre><code>{
    &quot;access_token&quot;: &quot;2YotnFZFEjr1zCsicMWpAA&quot;,
    &quot;expires_in&quot;: 3600,
    &quot;token_type&quot;: &quot;bearer&quot;,
    &quot;refresh_token&quot;: &quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,
    &quot;user_id&quot;: 1
}
</code></pre>
<p>然后需要在 <code>config/api.php</code> 中配置 <code>oauth2</code> 的验证方式：</p>
<pre><code> 'oauth' =&gt; function ($app) {
        $provider = new Dingo\Api\Auth\Provider\OAuth2($app['oauth2-server.authorizer']-&gt;getChecker());

        $provider-&gt;setUserResolver(function ($id) {
            // Logic to return a user by their ID.
        });

        $provider-&gt;setClientResolver(function ($id) {
            // Logic to return a client by their ID.
        });

        return $provider;
}
</code></pre>
<p>完成以上的配置基本就完成 <code>oauth2</code> 在 <code>laravel</code> 中的配置了。当然要在 <code>routes.php</code> 中指定要保护的路由，这一功能由 <code>dingo/api</code>帮助实现。如下：</p>
<pre><code>$api-&gt;group(['protected' =&gt; true],function($api){
    //需要保护的路由
});
</code></pre>
<p>在 <code>laravel</code> 使用 <code>oauth2</code> 中的配置基本完成了。</p>
<h5>注意</h5>
<p>以上的配置都是在以 <code>nginx</code> 为服务器的情况下配置的，如果你使用的是 <code>Apache</code> 服务器，那么还需要重写规则，在 <code>.htaccess</code> 文件中加入以下的代码：</p>
<pre><code>#Authorization Headers
RewriteCond %{HTTP:Authorization} .
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
</code></pre>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>时间与效率</title>
    <url>/2015/08/18/2015-08-18-%E6%97%B6%E9%97%B4%E4%B8%8E%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<p>因为在最近的工作当中效率一直不高，想到可能是自己的时间管理有点问题。所以觉得该找点时间来理一理了。当然时间管理是一个太大的话题，我也并非管理专业出身，没有办法将这个问题提升到理论的高度。仅限于我自己的经验范围内来说一说这个话题。高工作效率与很多因素都有关，我自己能不能干出高效率完全取决于这个任务是否紧急。这样的状态当然还是有问题的，所以我把一些高效率工作的要点总结下来。大家一起共勉吧。</p>
<h4>专注</h4>
<p>专注是高效率的一个非常重要的原则。专注一分钟不难，难处就在于如何长时间在各种环境中保持专注。当然这也是一句废话，这本来就是不太可能完成的任务。但是至少在一段时间内保持专注还是可以做到的。在我看来，专注需要一个<code>todo list</code>，人都是有惰性的，而<code>todo list</code>是一个很好的自我监督的工具。每天早晨在一个记事本上记录下自己一天的任务。然后每个任务都在自己的专注期内完成，中途不需要休息。当然任务太大的情况下可以将任务分解为一个个可以在自己专注期内完成的小任务。当每完成一个任务的时候，自己的成就感将会爆棚，这也算是我们采取这一策略的自我奖励吧。当然 <code>todo list</code> 有很多的专业工具，移动端和pc端都有，还有我最爱的 <code>emacs orgmode</code>，这个简直就是神器。我已经完全离不开这个了。</p>
<h4>找出自己的高效率点</h4>
<p>每个人都有自己的高效率点，就像有人喜欢在半夜里写代码一样。找出你自己的高效率点然后好好利用它，将可以使自己的效率翻倍。对于我来说，我现在越来越不喜欢晚睡，太晚睡觉将会影响第二天一整天的状态。整个人都会不舒服。相反，我喜欢早起。一天之计在于晨，大早晨的时间用来睡觉实在是有点浪费。早上的时间可以用来做很多的事情。基本上可以处理掉白天需要花很长时间才能完成的事情。比如写代码，学英语。然后在白天的时候，在这些不太能专注的时间内，可以用来完成一些行政上的工作。当然也可以用这些时间来看看书，写写文章什么的。找出自己的高效率点，然后合理的利用它。</p>
<h4>一段时间只做一件事</h4>
<p>这个点与专注有关。在学习新东西的时候。应当是一鼓作气将其学完，而不要将学习的战线拉的太长。人的记忆是有时间限制的，战线拉的太长，我们实际所花的时间也就越多，所以正确的做法是在尽可能短的时间内去搞定它，剩下的就是一个练习和熟练的过程，而不要断断续续的去学，因为这样实际上所花的时间将会更长。</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>Laravel 定时任务</title>
    <url>/2015/10/18/2015-10-18-Laravel%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>在 php 中使用定时器是一件不太简单的事情，之前大概只能通过 cron 来实现定时任务。但是在 Laravel5 中，定时任务将会变得很简单。</p>
<h3>Laravel Schedule</h3>
<p>这个是 Laravel5 中新增加的特性之一。在 Laravel5 中，进入到 app/Console/Kernel.php 中，可以看到以下代码：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected function schedule(Schedule $schedule)</span><br><span class="line">  &#123;</span><br><span class="line">      $schedule-&gt;command(&#39;inspire&#39;)</span><br><span class="line">               -&gt;hourly();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
这个 schedule 方法就是定时任务执行的关键，我们可以将所有的定时任务都放到其中，其中， Laravel 提供了诸多的方法来控制任务执行的时间间隔，例如：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$schedule-&gt;command(&#39;foo&#39;)-&gt;everyFiveMinutes();</span><br><span class="line"></span><br><span class="line">$schedule-&gt;command(&#39;foo&#39;)-&gt;everyTenMinutes();</span><br><span class="line"></span><br><span class="line">$schedule-&gt;command(&#39;foo&#39;)-&gt;everyThirtyMinutes();</span><br><span class="line"></span><br><span class="line">$schedule-&gt;command(&#39;foo&#39;)-&gt;mondays();</span><br><span class="line"></span><br><span class="line">$schedule-&gt;command(&#39;foo&#39;)-&gt;tuesdays();</span><br><span class="line"></span><br><span class="line">$schedule-&gt;command(&#39;foo&#39;)-&gt;wednesdays();</span><br><span class="line"></span><br><span class="line">$schedule-&gt;command(&#39;foo&#39;)-&gt;thursdays();</span><br><span class="line"></span><br><span class="line">$schedule-&gt;command(&#39;foo&#39;)-&gt;fridays();</span><br><span class="line"></span><br><span class="line">$schedule-&gt;command(&#39;foo&#39;)-&gt;saturdays();</span><br><span class="line"></span><br><span class="line">$schedule-&gt;command(&#39;foo&#39;)-&gt;sundays();</span><br></pre></td></tr></table></figure>
我们既可以通过创建 Command 来作为任务来执行，也可以使用闭包函数来作为任务：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$schedule-&gt;call(function()</span><br><span class="line">&#123;</span><br><span class="line">  	 	&#x2F;&#x2F;TODO ...</span><br><span class="line">  	 	</span><br><span class="line">&#125;)-&gt;hourly();</span><br></pre></td></tr></table></figure>
就这样，要执行的任务就可以简单的创建。</p>
<h3>启动 Schedule</h3>
<p>在定义完以上的任务之后，可以通过 <code>php artisan schedule:run</code> 来执行这些任务，但是，这个任务执行一起，需要不断的执行这个这个命令定时器才能不断的运行，所以就需要 <code>linux</code> 的系统功能的帮助，在命令行下执行下面的命令：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
执行完以上的命令之后，会出现一个处于编辑状态的文件，在文件中填入一下内容：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * php &#x2F;path&#x2F;to&#x2F;artisan schedule:run</span><br></pre></td></tr></table></figure>
然后保存，关闭。上面命令的含义是每隔一分中就执行一下 <code>schedule:run</code>命令。这样一来，前面定义的任务就可以不断的按照定义的时间间隔不断的执行，定时任务的功能也就实现了。</p>
<p>注：这个仅仅是在 <code>linux</code> 平台上，<code>windows</code> 还没研究过实现方法。</p>
]]></content>
      <categories>
        <category>jekyll laravel</category>
      </categories>
  </entry>
  <entry>
    <title>当我在谈论毕业的时候，我在谈些什么</title>
    <url>/2015/07/22/2015-7-22-%E5%BD%93%E6%88%91%E5%9C%A8%E8%B0%88%E8%AE%BA%E6%AF%95%E4%B8%9A%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E5%9C%A8%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h4>我们毕业了</h4>
<hr>
<p>在经历了漫长的升学考试之后，我们顺利进入了大学。而我认为大学本科则是我们最后的学生时代。在大学里，大家开始忙碌着去做各种自己感兴趣的事情。虽然不一定有意义。但是对于我们自己来说，却是很有意义的。因为这是这么多年以来，自己真正意义上的独立，离开了父母的监督。我们可以去做任何自己想做的事情。在大学里，我们每个人还有着满腔的梦想，每个人都认为自己是最独特的那个人，终有一天会让自己的光芒照耀世人。可是自己的行为却不太跟的上自己的梦想。大学里，我们会充满激情的去完成以前没有办法做的事情，我们称之为青春。这就是我们平凡而又美好的大学。可是在7月13日。这一切都已经结束了。我们毕业了。毕业意味着青春的散场，意味着责任的开始，当然也意味着新生活的开始。</p>
<h4>工作开始了</h4>
<hr>
<p>我们毕业了。但是生活还得继续，所以我们开始工作了（读研也是一定程度上的工作）。工作之后，我们也不得不去面临大量的任务。这些任务不是大学的课后作业，没有办法去借鉴同学的作业。只能靠着自己大学的积累来完成这些。在大学里，面对我们不喜欢的人，我们大可以置之不理，做好自己便够了。工作后，我们得学会察言观色，我们面对自己讨厌的人必须面带微笑。这些都是在经历了之后才学会的，生活让我们感觉到了痛，我们便学会了如何去顺从生活。曾经的豪言状语已经成为了青春的回忆。当我们泪流满面的生活之后。才明白了生活的意义。</p>
<h4>毕业时，我们要从大学带走什么</h4>
<hr>
<p>在四年前,我们来到大学时。除了高中刷题刷出来的一堆常识。我们并没有其他的任何的能力。在大学里面，关于通才和专才的辩论已经持续了很久。实际上在我看来，这两种说法都过于极端。人的精力是有限的，要做到通才是一件很难的事，大部分所谓的通才只是对大多数的东西略知皮毛，只是了解一些主流的说法，但是却并没有自己的见解。这种类型的人并不能算作是通才。还有专才也是过于极端的，实际上，没有哪一门学科是完全独立于其他学科存在的。如果只是对于一个方向的得钻研而没有估计到知识面得扩展，这样的专才也不能算作是通才。我认为大学里真正意义上的人才是在某个方面有很深的研究，同时在知识面上也有相当的广度。这才是作为一个大学毕业生应当拥有的能力。当然，在大学里，只是学习现有的知识肯定是不够的。我们在这里就不讨论做人的准则了。我相信只要是一个正常的人，读过几本书，应该就不会有太大的问题。我认为毕业的时候，你从大学带走的一样最重要的东西就是自学能力，在大学里，我们也会去学习很多的专业的知识，可是知识的更新换代的速度是很快的。在工作之后，在大学所学的知识可能很多就没有用了，在这种情况下，我们必须有能力去对自己的知识体系进行更新。而做到这些事情，又非得自学能力强。这样看来，只有具备了这些能力。我们才算是一个完整的人。这样我们才能承受住社会的冲击，在社会中做好自己。所以在毕业的时候，走出校门的那一刻，我们必须成为一个独立的、完整的人。</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>Laravel系列之队列的坑</title>
    <url>/2016/03/27/2016-03-27-Laravel%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%9F%E5%88%97%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h3>Laravel 队列</h3>
<p>Laravel 队列使用起来很方便，任何的 Event 和 Job 只要实现了 ShouldQueue 这个接口就代表着这些 Event 或者 Job 在
触发的时候会被加入到队列中。本文中的队列是基于 redis 实现的，其他的配置方法可以查看<a href="https://laravel.com/docs/5.2/queues" target="_blank" rel="noopener">官网</a>。</p>
<h3>队列监听</h3>
<p>在测试的时候，队列的监听可以在命令行启动，但是在正式上线的时候，就需要将监听设置成后台的 deamon，让监听在后台持续的运行，确保队列正常的
运作。linux 的 nohup 命令基本可以完成这一个需求，但是这个命令有个问题，在队列监听因为异常挂掉了之后，没有办法重启监听。这个对于实际的
上线来说是有问题的。那么这个时候，使用 <a href="http://supervisord.org/" target="_blank" rel="noopener">supervisord</a> 就很有用。利用这个工具可以完成队列监听的开机启动
以及自动重启。</p>
<h3>队列中的坑</h3>
<p>通过以下的命令可以完成队列监听：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan queue:listen</span><br></pre></td></tr></table></figure></p>
<p>将这个命令写入到 supervosird 的配置文件中基本就算完成配置了，但是这里有一个坑，这个命令有一个 --tries 的参数，这个参数的意思是在队列
任务执行失败之后，需要重新执行多少次，它的默认值特别具有迷惑性，它的默认值是 0，这个0不是尝试0次，而是不断的尝试，之前就是因为没有配置这个
参数才导致微信的模板消息被消耗光。在不断尝试的时候，也不会发送队列执行失败的邮件。找了半天才发现这个bug。</p>
]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title>Android系列之opencv-for-android的开发环境配置</title>
    <url>/2016/03/29/2016-03-29-Android%E7%B3%BB%E5%88%97%E4%B9%8Bopencv-for-android%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3>opencv for android</h3>
<p>opencv 近些年的发展很好，在安卓平台上已经有了比较成熟的版本。关于 Opencv For Android 的相关细节可以查看<a href="http://opencv.org/downloads.html" target="_blank" rel="noopener">官网</a>。本文主要是关于在 Android Studio 平台上开发环境的配置，本文的软件版本为 Android Studio 1.5 以及 Opencv For Android 2.4.11。</p>
<h3>配置过程</h3>
<ol>
<li>下载 Opencv For Android 的 sdk，<a href="http://opencv.org/downloads.html" target="_blank" rel="noopener">下载地址</a>, 下载完成之后解压。</li>
<li>将 opencv 导入进 Android Studio, 从 File -&gt; New -&gt; Import Module， 然后选择 sdk/java 那个文件夹。</li>
<li>更新导入的 Module 中的 build.gradle 文件，将其中 android sdk 的版本改成当前项目的 android sdk 的版本。</li>
<li>增加 Module 依赖，File -&gt; Project Structure, 然后选择 app Module，切换到Dependencies，点击 + 号，选择 Module，就能看见刚才添加的 OPencv Module，把它添加进来。</li>
<li>将解压包下的 sdk/native/libs 里面的内容拷贝到 app/src/mian 目录下，并将其改名为 jniLibs。</li>
</ol>
<p>在实际使用的时候，在 MainActivity 下添加以下的代码：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!OpenCVLoader.initDebug()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上的代码是去加载 opencv 的库文件。</p>
<p>在 android  studio 中配置这个环境很简便，甚至都不需要配置 NDK 的环境。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>爬虫入门</title>
    <url>/2015/10/02/2015-10-02-%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>最近在由于项目的需要，需要从一个网站上爬取一些数据，量不是特别大，于是就自己动手写了一个小爬虫。爬虫虽小，五脏具全，好歹是将整个过程体验了一下。下面是整个爬虫的开发过程。</p>
<h3>开发准备</h3>
<p>对于写一个简单的爬虫来说，需要准备一些基础知识。实际来说，就是简单的获取网页的方法以及如何解析整个网页。在这篇文章中我们使用 <strong>php</strong> 来完成整个爬虫的开发。需要用到 php_curl 模块和 php 的多线程(虽然这不是 php 所擅长的)以及正则的基本知识。</p>
<h3>获取网页</h3>
<p>这个是很基础的部分，主要是利用 <strong>php_curl</strong> 去获取整个页面的内容</p>
<pre><code>// $url 是最初始的 url，爬虫从这里开始
$content = cls_curl::get($url);
</code></pre>
<p>当然，整个方法被我封装过了，具体的 php_curl 的使用方法，见<a href="http://php.net/curl" target="_blank" rel="noopener">这里</a>。</p>
<h3>获取目标 url</h3>
<p>为了让爬虫自动去爬取我所需要的内容。我得从网页中获取到目标网页的 url，那么就需要从初始网页中不断的去爬取 目标内容：</p>
<pre><code>preg_match_all('#href=\&quot;/shop/[0-9]*?\&quot;#', $content, $out);
</code></pre>
<p>在整个代码中，大家看到了一些很奇怪的符号，这些就是正则表达式，爬虫并不是非得使用正则表达式，但是正则表达式匹配的饿效率却不是其他的方法可以比的。大家不要被这些符号吓到，精通正则表达式当然不是一件简单的事情，但是初步的了解，简单的使用还是不难的。如果想详细的了解，这里有一篇不错的<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">教程</a>。但是在这里，大家只需要了解以下的基本知识：</p>
<pre><code>+ [0-9] 是匹配到任意一个数字
+ * 表示重复零次或更多次
+ ? 表示重复另次或者一次
+ *? 表示的是非贪婪模式，表示整个匹配的长度不会无限匹配下去。
</code></pre>
<p>所以大家就能了解的到我想匹配到的是一个以 'shop' 开始，后面接着数字的链接了。这样我就获取到了我的目标链接了。</p>
<h3>获取目标内容</h3>
<p>在获取到目标的网页 url 之后，我需要像之前那样获取到目标网页的内容，剩下的就是要获取目标网页的内容了：</p>
<pre><code>preg_match_all('#&lt;h1 class=\&quot;shop-name\&quot;&gt;\s(.*?)\s&lt;/h1&gt;#s', $content, $shopname);
</code></pre>
<p>整个正则表达式也没什么新鲜的东西，也是将网页中的 <strong>shop-name</strong> 给爬取下来了，但是顺带将 <strong>h1</strong> 和 <strong>a</strong>标签里面的内容也给爬下来了，但其实整个并不是我们想要的。我们需要的只是 <strong>shop-name</strong>。所以需要将一些额外的内容给过滤掉：</p>
<pre><code>$name = preg_replace(&quot;/&lt;(a.*?)&gt;(.*?)&lt;(\/a.*?)&gt;/si&quot;,&quot;&quot;,$shopname[0][0]);
$name = preg_replace(&quot;/&lt;(\/?h1.*?)&gt;/si&quot;,&quot;&quot;,$name);
</code></pre>
<p>&quot;/&lt;(a.<em>?)&gt;(.</em>?)&lt;(/a.*?)&gt;/si/&quot; 是将整个 a 标签，包括标签里面的内容替换成&quot;&quot;,</p>
<p>&quot;/&lt;(/?h1.*?)&gt;/si&quot; 则只是将 h1 标签去掉，把里面的内容留下。经过这两行代码后，我们所需要的内容其实就获取到了。没错，爬虫就是这么简单。</p>
<h3>更高的爬取效率</h3>
<p>上面的方法其实就已经是一个简单的爬虫了，但是网页的数量太多，如果一直安上面的方法来爬取的话，速度实在是太慢了。所以我们需要充分的将硬件利用起来，没错，就是利用多线程的方法同时使用多个爬虫去爬数据。这样就可以大大的提升爬虫的效率了。</p>
<pre><code>$w = new worker();
$w-&gt;count = 1;
$w-&gt;is_once = true;

//利用后台线程来爬取数据，不能在 web 环境中运行
$count = 200000;        // 每个进程循环多少次
$w-&gt;on_worker_start = function($worker) use ($count) {
    //
};

$w-&gt;run();
</code></pre>
<p>可以通过线程来控制每个爬虫的爬取次数，这个 worker 工具并不是我写的，参考<a href="https://github.com/owner888/phpspider/blob/master/phpspider/worker.php" target="_blank" rel="noopener">这里</a>。好了，到这里，一个简单的爬虫基本就完成了，将数据存入数据库的部分我并没有写出来，那个根本就不需要专门说了。对于爬虫，也还是需要慢慢的探索。</p>
]]></content>
      <categories>
        <category>jekyll update</category>
      </categories>
  </entry>
  <entry>
    <title>Android系列之系统级别的AlertDialog</title>
    <url>/2016/04/04/2016-04-04-Android%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%88%AB%E7%9A%84AlertDialog/</url>
    <content><![CDATA[<h3>AlertDialog 的坑</h3>
<p>对话框是安卓开发里面使用的一个很广的组件，我们可以利用这个组件来完成很多的功能，而这篇文章主要讲到的是在开发中使用 AlertDialog 时候遇到的
一个小问题，开发时的代码类似下面这些:</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  AlertDialog.Builder dialogBuilder &#x3D; new AlertDialog.Builder(new ContextThemeWrapper(context, R.style.AlertDialogCustom));</span><br><span class="line"></span><br><span class="line">  dialogBuilder.setTitle(&quot;xx&quot;);</span><br><span class="line">  dialogBuilder.setMessage(&quot;xxx&quot;);</span><br><span class="line"></span><br><span class="line">  dialogBuilder.setCancelable(false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  dialogBuilder.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                ActivityCollection.finishAll();</span><br><span class="line">                Intent intent &#x3D; new Intent(context, LoginActivity.class);</span><br><span class="line"></span><br><span class="line">                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line"></span><br><span class="line">                context.startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">  AlertDialog alertDialog &#x3D; dialogBuilder.create();</span><br><span class="line"> alertDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);</span><br><span class="line">alertDialog.show();</span><br></pre></td></tr></table></figure></p>
<p>在 AndroidManifest.xml 文件中还需要配置一个权限：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure></p>
<p>以上的代码是弹出一个系统级别的警告框，上面的那些代码是没有问题的，但是在小米手机上调试时，程序没有报错，但是那个警告框就是
没有弹出来，好吧，找了半天发现，需要在手机上开启这个系统对话框的权限：</p>
<p><img src="http://7xi5nj.com1.z0.glb.clouddn.com/16-4-4/48782197.jpg" alt=""></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>Laravel系列-redis使用</title>
    <url>/2015/12/08/2015-12-8-laravel%E7%B3%BB%E5%88%97-redis%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3>Redis</h3>
<p><a href="http://www.redis.net.cn/" target="_blank" rel="noopener">Redis</a> 是一个开源的 key-value 数据库。在某些场合上可以对关系型数据库进行很好的补充。<a href="http://www.redis.net.cn/" target="_blank" rel="noopener">Redis</a> 的命令使用起来非常方便，例如对于字符串的存取</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;存入字符串</span><br><span class="line">127.0.0.1:6379&gt; set name key</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取出存入的字符串</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;key&quot;</span><br></pre></td></tr></table></figure></p>
<p>更多的 <a href="http://www.redis.net.cn/" target="_blank" rel="noopener">Redis</a> 相关的内容可以访问官网。</p>
<h3>Laravel 中使用 Redis</h3>
<p><a href="http://www.redis.net.cn/" target="_blank" rel="noopener">Redis</a> 可以支持诸多语言。例如 Java，Php，Ruby，Python 等。在 Laravel 中可以很方便的集成 <a href="http://www.redis.net.cn/" target="_blank" rel="noopener">Redis</a>，只需要通过 Composer 安装一个扩展包就行：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;require&quot;: &#123;</span><br><span class="line">        &quot;predis&#x2F;predis&quot;: &quot;~1.0&quot;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，然后就可以在 <a href="http://www.golaravel.com/laravel/docs/5.1/" target="_blank" rel="noopener">Laravel</a> 中使用 <a href="http://www.redis.net.cn/" target="_blank" rel="noopener">Redis</a> 了。可以将 <a href="http://www.redis.net.cn/" target="_blank" rel="noopener">Redis</a> 当作队列来使用，也可以将 <a href="http://www.redis.net.cn/" target="_blank" rel="noopener">Redis</a> 作为缓存来使用。</p>
<p>这些简单的用法在 <a href="http://www.golaravel.com/laravel/docs/5.1/" target="_blank" rel="noopener">Laravel</a> 的官方文档中都可以找到很详细的文档。就不多说，今天要说的是使用过程当中的一个坑。</p>
<h4>Redis 坑</h4>
<p><a href="http://www.redis.net.cn/" target="_blank" rel="noopener">Redis</a> 中的发布/订阅是一个很棒的工具，有着很广的用处。但是找个特性在使用的过程中却是有些坑存在，看下面的代码：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Redis::subscribe([&#39;test-channel&#39;], function($message) &#123;</span><br><span class="line">            echo $message;</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> Route::get(&#39;publish&#39;, function () &#123;</span><br><span class="line">    &#x2F;&#x2F; Route logic...</span><br><span class="line"></span><br><span class="line">    Redis::publish(&#39;test-channel&#39;, json_encode([&#39;foo&#39; &#x3D;&gt; &#39;bar&#39;]));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码就是 订阅模式在 <a href="http://www.golaravel.com/laravel/docs/5.1/" target="_blank" rel="noopener">Laravel</a> 中的使用，通过一个匿名的回调函数来接收发布的消息。这里要注意的是，<a href="http://www.redis.net.cn/" target="_blank" rel="noopener">Redis</a> 的订阅的命令会在后台生成一个守护进程。而 <a href="http://www.redis.net.cn/" target="_blank" rel="noopener">Redis</a> 连接服务器使用的是 Socket，所以如果按照 php 的默认配置，在60秒后就会自动断开连接，订阅就没有办法继续了。所以需要在这里加一个防止超时方法，例如下面:</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ini_set(&#39;default_socket_timeout&#39;, -1); &#x2F;&#x2F; 防止连接超时</span><br><span class="line"> Redis::subscribe([&#39;test-channel&#39;], function($message) &#123;</span><br><span class="line">            echo $message;</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> Route::get(&#39;publish&#39;, function () &#123;</span><br><span class="line">    &#x2F;&#x2F; Route logic...</span><br><span class="line"></span><br><span class="line">    Redis::publish(&#39;test-channel&#39;, json_encode([&#39;foo&#39; &#x3D;&gt; &#39;bar&#39;]));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
除了上面的坑之外还有一个坑，依然看上面的代码，我做如下的修改：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ini_set(&#39;default_socket_timeout&#39;, -1); &#x2F;&#x2F; 防止连接超时</span><br><span class="line"> Redis::subscribe([&#39;test-channel&#39;], function($message) &#123;</span><br><span class="line">            Redis::set(&#39;name&#39;, $message);</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> Route::get(&#39;publish&#39;, function () &#123;</span><br><span class="line">    &#x2F;&#x2F; Route logic...</span><br><span class="line"></span><br><span class="line">    Redis::publish(&#39;test-channel&#39;, json_encode([&#39;foo&#39; &#x3D;&gt; &#39;bar&#39;]));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果按照上面的写法，则会报如下的错误:</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception &#39;Predis\Response\ServerException&#39; with message &#39;ERR only (P)SUBSCRIBE &#x2F; (P)UNSUBSCRIBE &#x2F; QUIT allowed in this context&#39;</span><br></pre></td></tr></table></figure>
找个错误的原因是在回调函数的范围内使用了 <code>Redis::set</code> 方法，通过看 <code>Github</code> 上的 issue，发现 <code>Redis::</code> 生成的是同一个客户端，而在同一个客户端内，只能使用上面错误里面列出的几个命令。上面的代码里面，我使用了 <code>Redis::set</code> 命令，于是就报了上面的错误。解决找个问题的方法就是生成一个不同的 <code>Redis</code> 客户端，如下代码:</p>
<pre><code> ini_set('default_socket_timeout', -1); // 防止连接超时
 Redis::subscribe(['test-channel'], function($message) {
 			  $redisClient = new Predis\Client();
            $redisClient-&gt;set('name', $message);
 });
 
 Route::get('publish', function () {
    // Route logic...

    Redis::publish('test-channel', json_encode(['foo' =&gt; 'bar']));
});
</code></pre>
<p>通过上面的代码就可以解决那些问题了。</p>
<p>总之，<a href="http://www.golaravel.com/laravel/docs/5.1/" target="_blank" rel="noopener">Laravel</a> 还是一个不错的框架的。</p>
]]></content>
      <categories>
        <category>jekyll laravel</category>
      </categories>
  </entry>
  <entry>
    <title>Android系列之调用系统相机</title>
    <url>/2016/04/09/2016-04-09-Android%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E6%9C%BA/</url>
    <content><![CDATA[<p>在这次的开发中使用到了调用相机的功能，记录如下：</p>
<p>调用系统相机，获取照片方法如下：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">File outputImage &#x3D; new File(filename); &#x2F;&#x2F;需要具体的文件名称和路径</span><br><span class="line"></span><br><span class="line">Intent intent &#x3D; new Intent();</span><br><span class="line">intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">imageUri &#x3D; Uri.fromFile(outputImage);</span><br><span class="line">intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);</span><br></pre></td></tr></table></figure></p>
<p>以上的代码虽然可以获取照片，但是却也什么都做不了，因为，我们可能需要对这些照片进行额外的操作，比如放到特定的文件夹，或者缩放，
或者裁剪。</p>
<h4>将照片放到特定的位置</h4>
<p>如果只是调用 <code>Environment.getExternalStorageState()</code> ,这会将照片直接保存在 SD 卡的根目录，下面的代码可以将照片保存到 SD
卡的任意地方，如果目录不存在，就会创建一个新的目录：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private File createOutputFile(String path, String fileName) &#123;</span><br><span class="line"></span><br><span class="line">    String storageStatus &#x3D; Environment.getExternalStorageState();</span><br><span class="line"></span><br><span class="line">    if(Environment.MEDIA_REMOVED.equals(storageStatus)) &#123;</span><br><span class="line">        Log.i(TAG, &quot;SD 卡不存在&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File pictureDir &#x3D; new File(Environment.getExternalStorageDirectory(), path);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if(! pictureDir.exists()) &#123;</span><br><span class="line"></span><br><span class="line">        if(! pictureDir.mkdirs()) &#123;</span><br><span class="line">            Log.i(TAG, &quot;目录创建失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File file &#x3D; new File(pictureDir, fileName);</span><br><span class="line"></span><br><span class="line">    return file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>对照片进行裁剪</h4>
<p>以下的代码可以启动一个裁剪器，对刚刚拍好的照片利用系统相机的功能进行裁剪：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intent intent &#x3D; new Intent(&quot;com.android.camera.action.CROP&quot;);</span><br><span class="line">intent.setDataAndType(imageUri, &quot;image&#x2F;*&quot;);</span><br><span class="line">intent.putExtra(&quot;aspectX&quot;, 1);</span><br><span class="line">intent.putExtra(&quot;aspectY&quot;, 1);</span><br><span class="line">intent.putExtra(&quot;outputX&quot;, 200);</span><br><span class="line">intent.putExtra(&quot;outputY&quot;, 200);</span><br><span class="line">intent.putExtra(&quot;scale&quot;, true);</span><br><span class="line">intent.putExtra(&quot;return-data&quot;, false);</span><br><span class="line">intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);</span><br><span class="line">intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString());</span><br><span class="line">intent.putExtra(&quot;noFaceDetection&quot;, true);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>Laravel系列之中间件组及详解</title>
    <url>/2016/04/21/2016-04-21-Laravel%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%BB%84%E5%8F%8A%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Laravel5.2 中出现了一个很有用的特性。这一特性是值得期待的，中间件组的出现可以提高中间件的复用，而且可以让中间件更好组织。
这是 Laravel 在设计思想上的一个重大的提升，也就是 Laravel 在为无状态的开发，也就是前后端分离在做准备。</p>
<h3>中间件组</h3>
<p>在 app\Http\Kernel.php 文件中，出现一个新的配置选项 $middlewareGroups,该数组的键是中间件组的名称，值则是多个中间件
的集合。默认提供了 web 和 api 中间件组的配置:</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected $middlewareGroups &#x3D; [</span><br><span class="line">    &#39;web&#39; &#x3D;&gt; [</span><br><span class="line">        \App\Http\Middleware\EncryptCookies::class,</span><br><span class="line">        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,</span><br><span class="line">        \Illuminate\Session\Middleware\StartSession::class,</span><br><span class="line">        \Illuminate\View\Middleware\ShareErrorsFromSession::class,</span><br><span class="line">        \App\Http\Middleware\VerifyCsrfToken::class,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    &#39;api&#39; &#x3D;&gt; [</span><br><span class="line">        &#39;throttle:60,1&#39;,</span><br><span class="line">    ],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
我们当然也可以在其中增加自己的中间件配置：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected $middlewareGroups &#x3D; [</span><br><span class="line">    &#39;web&#39; &#x3D;&gt; [</span><br><span class="line">        \App\Http\Middleware\EncryptCookies::class,</span><br><span class="line">        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,</span><br><span class="line">        \Illuminate\Session\Middleware\StartSession::class,</span><br><span class="line">        \Illuminate\View\Middleware\ShareErrorsFromSession::class,</span><br><span class="line">        \App\Http\Middleware\VerifyCsrfToken::class,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    &#39;api&#39; &#x3D;&gt; [</span><br><span class="line">        &#39;throttle:60,1&#39;,</span><br><span class="line">    ],</span><br><span class="line">    &#39;admin&#39; &#x3D;&gt; [...]</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>中间件组的使用：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Route::group([&#39;middleware&#39; &#x3D;&gt; [&#39;web&#39;]], function () &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3>需要注意的地方</h3>
<p>在之前的版本中，app\Http\Kernel.php 文件中默认的中间件配置如下：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected $middleware &#x3D; [</span><br><span class="line">       \Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class,</span><br><span class="line">       \App\Http\Middleware\EncryptCookies::class,</span><br><span class="line">       \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,</span><br><span class="line">       \Illuminate\Session\Middleware\StartSession::class,</span><br><span class="line">       \Illuminate\View\Middleware\ShareErrorsFromSession::class,</span><br><span class="line">       \App\Http\Middleware\VerifyCsrfToken::class,</span><br><span class="line">   ];</span><br></pre></td></tr></table></figure></p>
<p>但是在 5.2 的版本中，配置是这样的:</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected $middleware &#x3D; [</span><br><span class="line">    \Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class,</span><br><span class="line">   ];</span><br><span class="line">protected $middlewareGroups &#x3D; [</span><br><span class="line">    &#39;web&#39; &#x3D;&gt; [</span><br><span class="line">        \App\Http\Middleware\EncryptCookies::class,</span><br><span class="line">        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,</span><br><span class="line">        \Illuminate\Session\Middleware\StartSession::class,</span><br><span class="line">        \Illuminate\View\Middleware\ShareErrorsFromSession::class,</span><br><span class="line">        \App\Http\Middleware\VerifyCsrfToken::class,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    &#39;api&#39; &#x3D;&gt; [</span><br><span class="line">        &#39;throttle:60,1&#39;,</span><br><span class="line">    ],</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>对比可以发现，cookies,sessions, CSRF的功能，都从默认中间件中被移除了，加入到了 web 中间件组中了。也就是说，没有
使用 web 中间件组的路由将没有 cookies，sessions，CSRF 的功能了，这也是为什么在 Laravel5.2 中使用默认的登录验证方式，在
没有使用 web 中间件的情况下，登录状态是没有办法保持的。这是 Larvel 在设计思想上的一个重大的提升。</p>
]]></content>
      <categories>
        <category>laravel</category>
      </categories>
  </entry>
  <entry>
    <title>Java系列之观察者模式的实现(一)</title>
    <url>/2016/05/01/2016-05-01-Java%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0(%E4%B8%80)/</url>
    <content><![CDATA[<p>在 Java 中，观察者模式是一个很重要的设计模式，在这篇文章中，我们来简单了解一下如何利用 Java 语言的特性来实现
一个简单的观察者模式。</p>
<h4>Java 中的 Obserable 与 Observer</h4>
<p>在 Java SE 中，有一个 Observer 接口和一个 Observer 类。在 api 文档中，描述如下：</p>
<ul>
<li><code>Observer</code> 一个类实现乐这个接口之后，被观察的对象如果有改变，那么这个类就可以接收到通知。实现这个接口必须要实现 <code>update</code> 方法。</li>
<li><code>Obserable</code> 这个类代表一个可观察的对象，或者 model 层的一个实例，可以被认为是想被观察的对象的一个子类。一个可观察的对象可以有多个观察者。</li>
</ul>
<h4>实现简单的观察者模式</h4>
<p>首先需要定义一个可观察的对象,这个对象中有一个 data 变量，这个变量在被改变的时候会通知到观察者：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ObservableObject extends Observable&#123;</span><br><span class="line"></span><br><span class="line">	int data &#x3D; 0;</span><br><span class="line">	</span><br><span class="line">	public void changeData(int change) &#123;</span><br><span class="line">		data &#x3D; change;</span><br><span class="line">		this.setChanged(); &#x2F;&#x2F;标记对象被改变</span><br><span class="line">		this.notifyObservers();  &#x2F;&#x2F;通知所有的观察者</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义观察者，观察者在接收到被观察者的改变之后，会将改变的值打印出来:</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ObserverObject implements Observer &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void update(Observable o, Object arg) &#123;</span><br><span class="line">		ObservableObject oo &#x3D; (ObservableObject) o;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;被观察者的数据被修改为：&quot;+ oo.data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ObservableObject observableObject &#x3D; new ObservableObject();</span><br><span class="line">		ObserverObject observerObject &#x3D; new ObserverObject();</span><br><span class="line">	</span><br><span class="line">		observableObject.addObserver(observerObject);</span><br><span class="line">		observableObject.changeData(1);</span><br><span class="line">		observableObject.changeData(-100);</span><br><span class="line">		</span><br><span class="line">		observableObject.deleteObserver(observerObject); &#x2F;&#x2F;移除观察者</span><br><span class="line">		observableObject.changeData(200);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果为：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">被观察者的数据被修改为：1</span><br><span class="line">被观察者的数据被修改为：-100</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是只打印了两个结果，是因为在第三次改变之前将观察者移除了，这样造成的结果是被观察者的改变将不能通知到被移除的观察者。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Paper3学术神器</title>
    <url>/2016/05/09/2016-05-09-paper3%E5%AD%A6%E6%9C%AF%E7%A5%9E%E5%99%A8/</url>
    <content><![CDATA[<h3>论文管理</h3>
<p>在学术的过程中，论文的管理是一个非常头疼的事情，当需要整理的论文多到一定数量的时候，很难按照一种有秩序的方式来管理。但是科技作为第一生产力，总是有办法来解决这个问题的。
<code>Paper3</code> 无疑是提升生产力的一个优秀的代表。阅读论文很难说是一个很好的体验，阅读的难度就不说了，还需要从中提炼出我们所需要的信息。如果不做好这些笔记，那么过了一会(并不需要一天)，这篇论文里面讲的东西也就忘的差不多了。在学术的过程中，有些问题总是一直存在的:</p>
<ul>
<li>论文的分类</li>
<li>获取高质量的论文</li>
<li>获取一篇特定的论文</li>
<li>写论文想要用之前的笔记或者批注，发现很难找到</li>
<li>论文丢了。。或者电脑丢了。。。。</li>
</ul>
<p>而 <code>Paper3</code> 刚好就可以用来解决这些问题。</p>
<h3>Paper3</h3>
<h4>简介</h4>
<p>官网上的简介是 <code>你个人的科研图书馆</code>，这句话正是对这个软件最好的描述。</p>
<p><img src="http://7xi5nj.com1.z0.glb.clouddn.com/16-5-10/98626663.jpg" alt=""></p>
<p>进入软件后的主页如下:</p>
<p><img src="http://7xi5nj.com1.z0.glb.clouddn.com/16-5-10/89982379.jpg" alt=""></p>
<h4>强大的搜索能力</h4>
<p>在 <code>Paper3</code> 里面，内置了多达 25 中搜索引擎，常见的例如 <code>ACM</code>, <code>Google Patents</code>, <code>Google Scholar</code>, <code>Web of Science</code> 等数据库引擎，所以如果想要找的论文在这里找不到，在其他的地方也不大可能找到了。</p>
<p><img src="http://7xi5nj.com1.z0.glb.clouddn.com/16-5-10/8936121.jpg" alt=""></p>
<p>在搜索的过程中，所输入的关键词会同时在你收藏的数据库中搜索。而且同时支持从多方面的搜索，比如 <code>title</code>, <code>author</code>, <code>year</code>, <code>publisher</code>, <code>abstract</code> 方面搜索，比如我要搜索一篇 <code>SDN</code> 在 2015 年发表的论文，我可以如下搜索:</p>
<p><img src="http://7xi5nj.com1.z0.glb.clouddn.com/16-5-10/40334710.jpg" alt=""></p>
<p>回车键后开始搜索，搜索结果如下:</p>
<p><img src="http://7xi5nj.com1.z0.glb.clouddn.com/16-5-10/83010274.jpg" alt=""></p>
<p>然后选择我们想要的搜索结果，可以直接将论文导入到我们自己的数据库中:</p>
<p><img src="http://7xi5nj.com1.z0.glb.clouddn.com/16-5-10/22221460.jpg" alt=""></p>
<h4>整洁的资料分类</h4>
<p><code>Paper3</code> 提供了强大的论文分类功能，可以很方便的建立 <code>Collection</code>,我们可以通过 <code>File -&gt; New Collection</code> 来新建一个 <code>Collection</code>。<code>Collection</code> 总体上可以分成两类:</p>
<ul>
<li>一类是普通的 <code>Collection</code>, 这样我们就需要通过右键点击论文 <code>add to collection</code></li>
</ul>
<p><img src="http://7xi5nj.com1.z0.glb.clouddn.com/16-5-10/47500337.jpg" alt=""></p>
<ul>
<li>还有一个是 <code>Smart Collection</code>,论文会根据你自定义的参数自动的加入进来。</li>
</ul>
<p><img src="http://7xi5nj.com1.z0.glb.clouddn.com/16-5-10/47500337.jpg" alt=""></p>
<p>除了这样的分类，还可以为文章添加关键词，随后在搜索的时候，我们可以直接搜索这些关键词，就可以快速的定位到我们看过的一些文章，就可以自然的找到做过的笔记和批注。</p>
<p><img src="http://7xi5nj.com1.z0.glb.clouddn.com/16-5-10/2111477.jpg" alt=""></p>
<h4>便利的阅读体验</h4>
<p>以下是阅读的主界面:</p>
<p><img src="http://7xi5nj.com1.z0.glb.clouddn.com/16-5-10/16684798.jpg" alt=""></p>
<p>右栏中可以显示论文的相关信息，和笔记以及一些社交信息。</p>
<p>在阅读论文的过程中，可以通过右键来完成以下的功能:</p>
<ul>
<li>可以轻松的在论文里面标注，加自己的笔记</li>
<li>将一段文本标记为高亮，有多种颜色可选</li>
<li>将一段文本标记为下划线</li>
<li>将一段文本标记为删除线</li>
<li><code>Mac</code> 利用自带的词典可以随时查单词，在 <code>Windows</code> 上可以利用有道词典的屏幕划词功能来取代这个。</li>
</ul>
<h4>其他</h4>
<p>笔记本有丢失和损坏的风险，纸质的资料更是不保险，那么这个时候云同步的功能就是很有必要的。 <code>Dropbox</code> 可以带来很强大的同步体验，但是迫于无奈，在国内由于一些原因(你懂的),所以 <code>Dropbox</code> 可能没办法使用，所以百度云同步某种程度上也是可以作为替代品的。但是我还是一直在使用 <code>Dropbox</code>，为什么？因为颜值高呀，哈哈。</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>Java系列-Lambda表达式</title>
    <url>/2016/02/12/2016-2-12-Java%E7%B3%BB%E5%88%97-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h4>Lambda 表达式简介</h4>
<p>可以说， Lambda 表达式是函数式编程的一个标志，现如今在 <code>Java</code> 中也加入了这一特性，虽然目前只能算是一个语法糖。
其实在各个语言里面出现的各个 <code>Lamdba</code> 表达式与形式化的λ 演算还是有挺大的差别的。在编程语言中的 Lambda 表达式
本质上是一个匿名函数。特别是对于那些只会使用一次的匿名函数，使用 Lamdba 表达式来表示可以大大提升代码的可读性，以
及缩短代码量。</p>
<p>Lambda 表达式在函数式编程中有着重要的应用。在函数式编程中，函数本身是可以作为一个参数进行传递的。虽然在 Java 中
目前并没有实现这一机制，但是至少在形式上已经迈出了这一步。</p>
<h4>Lambda 在Java中的实现</h4>
<p>说到 Lamdba 表达式在 Java 中的实现，首先就要介绍一下<code>函数接口</code>的概念，在 Java 中，函数接口是这样定义的：一个接
口，如果只有一个显式声明的抽象方法，那么它就是一个函数接口。一般来说会使用 <code>@FunctionalInterface</code> 注解标示，当然
这个注解也可以省略。如下：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123; void run(); &#125;</span><br><span class="line"></span><br><span class="line">public interface Callable&lt;V&gt; &#123; V call() throws Exception; &#125;</span><br><span class="line"></span><br><span class="line">public interface ActionListener &#123; void actionPerformed(ActionEvent e); &#125;</span><br><span class="line"></span><br><span class="line">public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2); boolean equals(Object obj); &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上的接口都是函数接口，但是需要注意的是最后一个接口，虽然有两个抽象方法，但却也是一个函数接口，因为 <code>equals</code> 方法是
Object 的方法。</p>
<p>Lambda 带来的最显著的改变就是对匿名函数的实现，先后实现方法的差别如下：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(12,43,10,56,45,90);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;普通的实现方法</span><br><span class="line">    Collections.sort(numbers, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            return o1 - o2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;第一种 Lambda 表达式的实现</span><br><span class="line">    Collections.sort(numbers, (Integer a, Integer b) -&gt; &#123;</span><br><span class="line">        return a - b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;第二种 Lambda 表达式的实现</span><br><span class="line">    Collections.sort(numbers, (Integer a, Integer b) -&gt; a - b);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;第三种 Lamdba 表达式的实现(不用说明参数类型，上下文可以推测出来参数的类型)</span><br><span class="line">    Collections.sort(numbers, (a,b)-&gt; a - b);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;现在的集合类都增加了一个foreach方法,这个方法可以很方便的使用 lambda 表达式,就可以不用for循环来便利集合</span><br><span class="line">    numbers.forEach(number -&gt; System.out.println(number));</span><br><span class="line"></span><br><span class="line">    numbers.foeEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的例子我们可以发现，其实每一个 Lamdba 事实上就是一个匿名函数的实现，就目前 Java 的 Lamdba 的实现来说，最终
每个 Lamdba 都会被编译成一个实现类。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>2015个人小结</title>
    <url>/2016/01/01/2016-1-1-2015%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3>2015 小结</h3>
<h4>过去的一年</h4>
<p>一年的时间依然是以很快的速度过去了，在过去的这一年的时间里面有很多的事情应该被记住。首先，在去年的7月份，我毕业了，彻底的成为了一个应该独立生活的人了。
回想起来，在毕业之前，很多次的想着毕业的我应该是什么样子的。但是，一切都不会变，一切都还是它本来的样子。但是同时一切也在以一个恒定的速度在变化，不知不觉，却一直在我们身边。第二是我花了一年的时间去尝试了一件事，不，准确的说应该是很多件事。过去的一年由于精力的分散以及各种不合适的做事方法以及不够深入的思考问题的方式，确实没有作出一些另自己满意的东西，甚至是完整的东西。好吧，至少我已经提前知道以及体验了这些，以一种不太好的方式，至少在新的一年里，我会学着尽力去调整自己的做法，让自己的尽可能的作出更多正确的事情。而其他的一切都在磕磕碰碰当中不断的进展着，不算好，也不坏。但是却缺少一种恒定的进步，主要是因为不专注的原因。
好的方面是在过去的一年里，各方面的都进步了不少，无论是心态上，还是实际的能力上，都有了很大的进步，但是自己的一套方法论和思维方法却还是没有形成体系。缺乏这些会让我在某些时候对问题的看待不是很清晰。而且学习的时候并没有成体系的去学习。而且没有将可以阅读的时间都利用上，没有花多数时间去思考，没有好好的去写文章。总之，过去的一年是不好不坏的一年。虽然曲折，但仍然在前进。</p>
<h4>当前的一年</h4>
<p>对于我来说，未来的一年是很重要的一年，是我可以好好打基础的最后一年了。在这一年的时间里，我需要更加踏踏实实的做事，学习，以及生活。在未来的一年里，我需要做好第三年作选择时所具备的一切基础。大致就是完成以下的事情:</p>
<ul>
<li>学好英语</li>
<li>完成两篇论文，将毕业的事情提前搞定</li>
<li>更实在的做事情</li>
</ul>
<p>当然，除了上面那些，还有很多事情要去做：</p>
<ul>
<li>坚持健身</li>
<li>摄影入门，有拿得出手的作品</li>
<li>至少去5个地方旅游</li>
</ul>
<p>其他的就是还有很多的事情可以了解，入门。比如个人财务管理等。已经收拾好，可以继续了。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>为什么还要使用编辑器</title>
    <url>/2016/11/09/2016-11-9-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<p>在各种 <code>IDE</code> 特别繁多的今天，我为什么还要使用编辑器。写这篇文章完全无意去争辩哪个编辑器是最好的，适合自己的，才是最好的。</p>
<h4>初识 emacs</h4>
<blockquote>
<p>在第一次接触到 <code>emacs</code> 的时候，其实并没有被这个其貌不扬的货给打动。甚至一度觉得快捷 键实在是太复杂，差点就弃用了。但是在我 'M-x help' 之后，我发现了一个不同的世界。</p>
</blockquote>
<p>这个编辑器就是计算机史上的艺术，在经过差不多与计算机历史相同的时间之后，依然拥有着强大的生命力。<code>emacs</code> 本身由 <code>lisp</code> 编写，整个软件的设计的思想在今天依然不落伍。当然，软件的好坏不能使用存在时间的长短来衡量，更重要的是，它好用。</p>
<h4>重度使用</h4>
<p>首先，编辑器轻量级，相比于 <code>IDE</code>，编辑器所需要的系统的资源实在是少的很，可以快速的打开，然后开始码字，没有丝毫的负担。电脑也就不会不断的轰鸣，终于可以安安静静的敲键盘了。</p>
<ul>
<li>
<p>编码
其次呢，现在大部分编辑器都有着丰富的插件，在合理的安装了插件之后，整个编辑器的功能就已经与 <code>IDE</code> 的功能不相上下了，比如自动补全，项目文件搜索，项目结构树，搜索，替换等，在这些插件的帮助下，我们就可以完成编码过程中所需的绝大部分的操作。</p>
</li>
<li>
<p>少既是多
再者，在使用 <code>IDE</code> 的过程中，每换一种编程语言，都得换成另外一个 <code>IDE</code>,这样得花时间去学习不同的 <code>IDE</code>,还得在电脑上装上一堆的 <code>IDE</code>，怎么说都不是一件很愉快的事情。但是在编辑器上就不一样了，绝大部分的代码都可以直接编写，而不用去为不同的语言做切换。只需要装几个不同的插件就可以了。同时呢，在编码的同时，也可以使用编辑器直接将文档也编写了。甚至展示用的 <code>PPT</code> 也可以直接使用编辑器来完成（reveal.js）。</p>
</li>
<li>
<p>万能的 org-mode
对于我来说呢，使用 <code>emacs</code> 的一个很重要的原因就是 <code>org-mode</code>，现在，基本我所有的文档都是使用 <code>org-mode</code> 来编写了，编辑完的文档可以轻松的导出为 <code>Markdown</code> 和 <code>pdf</code>， <code>tex</code> 以及网页等其他格式的文档。基本上可以做到一次编写，处处使用了。而且 <code>org-mode</code> 还可以用来做 <code>todo</code>，日程安排，表格统计等。基本上可以完成日常工作中的所有的功能了。</p>
</li>
</ul>
<p>当然，说了这么多，并不是来说明编辑器是全能的，在某些情况下，使用 <code>IDE</code> 才能帮助我们更高效的完成工作。比如说一些移动端的开发，在不同的工作环境下，我们应当使用更合适的工具来完成工作。</p>
]]></content>
      <categories>
        <category>jekyll emacs</category>
      </categories>
  </entry>
  <entry>
    <title>Java系列-StreamApi</title>
    <url>/2016/02/15/2016-2-15-Java%E7%B3%BB%E5%88%97-StreamApi/</url>
    <content><![CDATA[<h4>Java Stream 简介</h4>
<p>Java8 中的 <code>Stream</code> 是对集合(Collection) 对象功能的增强，它专注于对集合对象进行各种便利、高效的聚合操作，
或者是大批量的数据操作。Stream Api 的引入是为了弥补 Java 函数式编程的不足。但是这些 Api 并没有在集合类实现，
而是定义了全新的Stream APi。有几个重要的原因：</p>
<ul>
<li>
<p>集合类的所有元素都存储在内存中，非常大的集合类将占据大量的内存，但是 Stream 只有在执行结束操作(terminal)的
时候才会真正的进行计算(稍后会提到)。</p>
</li>
<li>
<p>另外还有集合类的迭代逻辑通常是通过 <code>for</code> 来负责的，但是 Stream 的迭代是隐含在对 Stream 的各种操作中，例如
map(), reduce()。</p>
</li>
</ul>
<p>创建一个流有很多的方法，例如:</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Collection.stream();</span><br><span class="line">Collection.parallelStream();</span><br><span class="line">Arrays.stream(T array) or Stream.of();</span><br></pre></td></tr></table></figure></p>
<p>一个流可以进行多种操作，总的来说，流的操作分为三类：</p>
<ul>
<li>
<p>中间操作： 一个流可以有零个或者多个中间操作，是为了打开流，作出某种程度的数据映射和过滤，然后返回一个新的流(每次转
换原有的 Stream 对象不变，会返回转变后的一个新的对象)，也就是说，进行这类操作并没有真正开始流的遍历，典型的中间操作
有：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、
sequential、 unordered。</p>
</li>
<li>
<p>结束操作: 一个流只能有一个结束操作，进行这个操作之后，这个流也就结束了，无法进行其他的中间操作或者结束操作，也就是
说结束操作使得流进行了真正的遍历，典型的结束操作有：forEach、 forEachOrdered、 toArray、 reduce、 collect、
min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator。</p>
</li>
<li>
<p>短路操作：因为 Stream 有另外的一个特性，就是 可以存在无限的流。而短路操作正是用来处理这些情况。对于中间操作，如果
接受的是一个无限大的 Stream, 短路操作可以帮助返回一个有限的新的 Stream。对于结束操作，如果接受的十一个无限大的
Stream，短路操作可以帮助在有限的时间内计算出结果，典型的短路操作有：anyMatch、 allMatch、 noneMatch、
findFirst、 findAny、 limit。</p>
</li>
</ul>
<h4>Java Stream 应用</h4>
<p>一个简单的 Stream 例子：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1,45,9,34,78,19,65,76);</span><br><span class="line"></span><br><span class="line">    numbers.stream()</span><br><span class="line">            .filter((i) -&gt; i%2 &#x3D;&#x3D;0)</span><br><span class="line">            .map((i) -&gt; i * i)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成一个无限流，并且取出有限的个数：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NumberStream implements Supplier&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  long value &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Long get() &#123;</span><br><span class="line">      this.value &#x3D; this.value + 1;</span><br><span class="line"></span><br><span class="line">      return this.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">      Stream&lt;Long&gt; numbers &#x3D; Stream.generate(new NumberStream());</span><br><span class="line"></span><br><span class="line">      numbers.map((x) -&gt; x * x ).skip(100).limit(10).forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>redis 注册服务</title>
    <url>/2016/03/11/2016-3-11-redis%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h3>redis 注册为为服务</h3>
<p>在 redis 安装完成之后，需要将 redis 注册为服务，这样做有多个好处:</p>
<ul>
<li>可以利用 service 命令方便的控制服务的启动和停止。</li>
<li>可以利用 chkconfig 命令来控制程序的运行级别。</li>
<li>可以让服务在开机时启动。</li>
</ul>
<h4>redis 安装</h4>
<p>redis 的安装有多种方式，既可以通过源码安装，也可以通过操作系统的报管理器安装。这个就不详细说明了。</p>
<h4>redis 注册服务</h4>
<ul>
<li>安装完成了之后，将源码中 /utils/redis_init_script (不知道文件在哪的可以通过 find / -name redis_init_script 来查找)
文件复制到 /etc/init.d/redisd 文件。</li>
<li>然后在 /etc 目录下创建 /etc/redis 目录(这个目录可以随便建)，并将修改的 redis.conf 复制到 redis目录下。</li>
<li>然后修改 /etc/init.d/redisd 文件，在文件开始的地方添加服务的运行级别。</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"># chkconfig:   2345 90 10</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li>最后启动服务， chkconfig redisd on, 这样redis 就被注册成了服务。</li>
</ul>
<p>基本上所有的程序都可以这样被注册成服务，至于服务(service)和 chkconfig 的意义，在下一篇文章中会讨论。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>API系列之JSON-API最新标准</title>
    <url>/2016/05/10/2016-05-10-API%E7%B3%BB%E5%88%97%E4%B9%8BJSON-API%E6%9C%80%E6%96%B0%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<h3>简介</h3>
<p>JSON API 是一个客户端应该如何如何请求或者修改资源，以及服务器端如何对这些请求作出回应。</p>
<p>JSON API 是为了最小化客户端以及服务器端的请求数量以及大量的数据交换。在不牺牲可读性和灵活性的前提下来提升效率。</p>
<p>JSON API 需要使用 <code>application/vnd.api+json</code> 协议来传输数据。</p>
<h3>约定</h3>
<p>文中的这些关键字 &quot;MUST&quot;,&quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHOULD&quot;,&quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,&quot;NAY&quot; 以及
&quot;OPTINAL&quot; 都可以在 RFC 2119 标准中可以找到解释。</p>
<h3>内容限定</h3>
<h4>客户端职责</h4>
<p>客户端必须(MUST)在 JSON API 请求的时候都要在请求的头部加上 <code>Content-Type:application/vnd.api+json</code>,不带其他的任何参数。</p>
<p>客户端在 JSON API 请求的头部的 <code>Accept</code> 中必须(MUST)至少指明一次协议的类型而不带任何的参数。</p>
<p>客户端必须(MUST)忽略收到的响应为 <code>application/vnd.api+json</code> 类型中 <code>Content-Type</code>所携带的任何参数。</p>
<h4>服务器端职责</h4>
<p>服务器必须(MUST)发送不携带任何参数的 <code>application/vnd.api+json</code> 类型的响应。</p>
<p>服务器必须(MUST)响应 <code>415 Unsupported Media Type</code> 状态码，如果请求 <code>Content-Type:application/vnd.api+json</code> 中携带任何参数的话。</p>
<p>服务器必须(MUST)响应 <code>406 Not Acceptable</code> 状态码，如果一个请求的头部的 <code>Accept</code> 的加上了参数的话。</p>
<pre><code>注意：这个内容协定要求在当前和未来的使用这个协议以及相关扩展的版本中都会存在。
</code></pre>
<h3>文档结构</h3>
<p>这个小节讨论 JSON API 文档的结构。这个协议已经被定义为 <code>application/vnd.api+json</code>。JSON API 文档已经被定义在 JavaScript Object Notation(JSON)[RFC7159]。</p>
<p>尽管请求和响应使用的是相同的协议类型，某些方面只适合其中的一个，这其中的区别在稍后会谈到。</p>
<p>除非特殊情况，否则通过这个规格定义的对象不能(MUST NOT)包含其他的任何成员。客户端和服务器的实现必须(MUST)忽略不在这个规范范围内的其他成员。</p>
<pre><code>注意：这些条件允许规格通过添加改变的方法来进化。
</code></pre>
<h4>顶层</h4>
<p>一个 JSON 对象必须(MUST)是任何的 JSON API 请求和响应所携带数据的根结构，这个对象定义文档的顶层。</p>
<p>一个文档必须(MUST)至少包含一个以下的顶层成员:</p>
<ul>
<li><code>data</code>: 文档的主要数据</li>
<li><code>errors</code>: 一个错误对象的数组</li>
<li><code>meta</code>: 一个包含非标准信息的 meta 对象</li>
</ul>
<p><code>data</code> 和 <code>errors</code> 不能同时出现在同一个请求或者响应中。</p>
<p>一个文档可能(MAY)会包含以下任何的顶层成员:</p>
<ul>
<li><code>jsonapi</code>: 一个描述服务端实现的对象</li>
<li><code>links</code>: 与主要数据相关的链接对象</li>
<li><code>included</code>: 一个与主要数据有关联或者其他的资源对象的数组。</li>
</ul>
<p>如果文档的顶层没有 <code>data</code> 键，这个 <code>included</code> 成员也不能(MUST NOT) 出现在这里。</p>
<p>这个顶层链接对象可能(MAY)包含以下的成员:</p>
<ul>
<li><code>self</code>: 当前响应生成的链接</li>
<li><code>related</code>: 一个相关的资源链接，当这个主要的数据代表一个资源的关系</li>
<li><code>pagination</code>: 主数据的分页链接</li>
</ul>
<p>文档中的主数据是指请求的资源的集合。</p>
<p>主数据必须(MUST)是以下两者中的一个:</p>
<ul>
<li>一个单独的资源对象，一个单独的资源标识对象或者是 null, 为了去请求目标资源</li>
<li>资源对象数组，资源标识对象的数组或者一个 null 的数组，为了请求目标资源集合</li>
</ul>
<p>举个例子，下面的数据就是一个单独的资源对象:</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;articles&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;attributes&quot;: &#123;</span><br><span class="line">      &#x2F;&#x2F; ... this article&#39;s attributes</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;relationships&quot;: &#123;</span><br><span class="line">      &#x2F;&#x2F; ... this article&#39;s relationships</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就是一个资源的标识对象，指代一些资源:</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;articles&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个资源的集合必须用一个数组来表现，即使只有一项内容或者为空。</p>
<h4>资源对象</h4>
<p><code>资源对象</code> 在 JSON API 的文档中代表资源。</p>
<p>一个资源必须(MUST)包含至少以下两个顶层成员:</p>
<ul>
<li><code>id</code></li>
<li><code>type</code></li>
</ul>
<p>例外: 当这个资源代表一个即将要被传送到服务器端创建的时候，这个 `id 可以被省略。</p>
<p>另外，一个资源对象可能(MAY)包含以下的顶层成员:</p>
<ul>
<li><code>attributes</code>: 代表资源数据的属性对象</li>
<li><code>relationships</code>: 描述这个对象与　JSON API 其他对象关系的关系对象</li>
<li><code>links</code>: 包含其他资源的链接对象</li>
<li><code>meta</code>: 包含对象非属性数据的 <code>meta 对象</code></li>
</ul>
<p>一个 <code>article</code> 对象可能是如下的表示:</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;articles&quot;,</span><br><span class="line">  &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;attributes&quot;: &#123;</span><br><span class="line">    &quot;title&quot;: &quot;Rails is Omakase&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;relationships&quot;: &#123;</span><br><span class="line">    &quot;author&quot;: &#123;</span><br><span class="line">      &quot;links&quot;: &#123;</span><br><span class="line">        &quot;self&quot;: &quot;&#x2F;articles&#x2F;1&#x2F;relationships&#x2F;author&quot;,</span><br><span class="line">        &quot;related&quot;: &quot;&#x2F;articles&#x2F;1&#x2F;author&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;data&quot;: &#123; &quot;type&quot;: &quot;people&quot;, &quot;id&quot;: &quot;9&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5>唯一标识</h5>
]]></content>
      <categories>
        <category>api</category>
      </categories>
  </entry>
  <entry>
    <title>2018年总结</title>
    <url>/2019/02/04/2018%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>还是习惯把每年的除夕作为一年结束的时刻。2018 年时正式开始工作的一年，在这一年的时间里面，学到了很多，虽然之前对于工作也有自己的预想。实际工作之后，碰到的问题还是比预想中的多。</p>
<p>在 2018 年，我才刚刚学会学习。</p>
<p>在 2018 年， 我才刚刚理解工作是什么。</p>
<p>在 2018 年， 我才刚刚开始了解我自己。</p>
<p>在刚刚过去的 2018 年，很多的年初立下的目标依然没有完成（苦笑），但是好在有几个目标完成的还可以，健身和英语，完成这两个目标就让我 2018 年基本不亏了。</p>
<p>在 2018 年我读书的策略有了一点的小改变。这一年虚构类的书籍读的少了。读书的数量也没有以前那么多了，但是读书的质量却更好了。开始理解读书并不是追求数量就行。对于虚构的类的书籍，基本上看一遍就可以了，但是对于非虚构类的书籍，需要更加深入的学习和整理才能算是看完。所以 2018 年读的书的数量并不多，但是却感觉更加充实，留下的东西却更多。</p>
<p>在 2018 年我有了更多的输出，甚至比之前几年留下的东西都要多。持续的输出对于自身的成长和积累来说有着很大的好处。人都是有惰性的，不能依靠人性。那就通过输出倒逼自己来完善自己的知识体系。输出的方式包括分享，写作等。我的主要的输出方式是通过写作来完成的。输出能让我能够不断的去梳理自身的知识架构，能够检查出哪部分有遗漏，通过这样的方式来不断完善自己。</p>
<p>在 2018 年我开始不仅仅只是关注技术的问题。在今年开始学习了一些产品的知识。因为我发现技术并不是最终解决问题的方法。技术只是手段，通过学习产品，就能够从不同的角度去发现问题，并找出最优的解决方案，最终通过技术的手段去实现这些解决方案。所以最终七决定性作用的仍然是对于问题的发现和解决方案的提出。学习产品能帮我更好的提升这方面的能力。</p>
<p>在 2018 年我的厨艺增长了不少。开始独立出来生活，不喜欢吃外卖，长期下馆子的话我的胃和我的钱包都没有办法接受。所以自己下厨也就成了一个最好的选择。</p>
<p>在 2018 年我的歌唱的越来越好了。从以前去 KTV 当哑巴，到现在能够去 KTV 从容的拿起话筒唱自己想唱的歌，进步了不少。</p>
<p>在 2019 年，我也还是有一些事情要去做。有一些是 2018 年遗留下来的，或者是一直要去做的事情，比如健身，比如学英语。还有一些是  2019 年的新目标，比如学习日语。</p>
<p>在 2018 年我学到了快速成长的秘诀，那就是不断的去接收外界的反馈。在 2019 年，我要学会把自己当做一个公司来经营。</p>
<p>(完)</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>人人都需要一点正面回馈</title>
    <url>/2016/04/06/2016-04-06-%E4%BA%BA%E4%BA%BA%E9%83%BD%E9%9C%80%E8%A6%81%E4%B8%80%E7%82%B9%E6%AD%A3%E9%9D%A2%E5%9B%9E%E9%A6%88/</url>
    <content><![CDATA[<p>都知道坚持一件事可以超越 80% 的人，但是可能仅仅 20% 的人做到了。想清楚一点就发现我们的环境被概率论所支配，比如那个八二理论。从总体上来说，我们都是其中一个不可预知的随机变量，当然，这个是从总体上来说，对于每一个确定的个体，却不是随机的。</p>
<p>想学摄影，发现怎么也学不会构图，故而放弃。想学吉他，只学会了生日快乐。想学游泳，只学会了狗爬式。想学编程，直到现在也才只会 Hello world。学不下去最直观的感受就是，这个真他么难，但是实际上可能并不是这样，只是有时候步子跨的太大，扯着dan了。其实解决这个问题的方法也很简单，就是将自己的步子放小一点，让自己可以感受到自己的进步，这样来说，大脑接收到的都是正面的回馈，不会产生想放弃的感觉。就是说只要在学习的过程当中，不断的给大脑喂胡萝卜，让大脑一直保持学习的兴趣，这样的话，学习新的技能是不是轻松点。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>AWS 中国区Lambda 部署指南</title>
    <url>/2018/05/07/AWS-%E4%B8%AD%E5%9B%BD%E5%8C%BALambda-%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>serverless 框架中部署Lambda + API Gateway:</p>
<ol>
<li>
<p>Lambda 服务目前只在北京区域(cn-north-1)上线，宁夏区域(cn-northwest-1)目前不支持。</p>
</li>
<li>
<p>API 部署时，需要为 <code>API Gateway</code> 配置<code>Principal</code>，配置方法如下:</p>
<p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="attr">  Resources:</span></span><br><span class="line"><span class="attr">    AppLambdaPermissionApiGateway:</span></span><br><span class="line"><span class="attr">      Properties:</span></span><br><span class="line"><span class="attr">        Principal:</span> <span class="string">apigateway.amazonaws.com</span></span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>部署后的API 不能直接访问，需要配置一个在光环新网上备案的域名，或者使用 <code>aws_iam</code>方式访问接口，配置方法如下:</p>
<p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">functions:</span></span><br><span class="line"><span class="attr">  app:</span></span><br><span class="line"><span class="attr">    handler:</span> <span class="string">index.handler</span></span><br><span class="line"><span class="attr">    events:</span></span><br><span class="line"><span class="attr">      - http:</span> </span><br><span class="line"><span class="attr">          method:</span> <span class="string">ANY</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">          authorizer:</span> <span class="string">aws_iam</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>Postman</code>方式访问方法如下，Authorization 的方式选择 AWS Signature，然后使用IAM账户的AccessKey 和 SecretKey，AWS Region 填写 cn-north-1，Service Name 填写 execute-api:</p>
<p><img src="../../../../../../../var/folders/9j/t84xr7l14xs5fwmch7128cxw0000gn/T/abnerworks.Typora/image-20180507180000661.png" alt="image-20180507180000661"></p>
<p>​</p>
</li>
<li>
<p>不要在 <code>provider</code>和<code>functions</code>中配置<code>environment</code>，这一配置在<code>cn-north-1</code>区域不支持</p>
</li>
<li>
<p>以下是一个简单的 serverless 配置:</p>
<p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">service:</span> <span class="string">serverless-aap2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">custom:</span></span><br><span class="line"><span class="attr">  tableName:</span> <span class="string">'users-table-$&#123;self:provider.stage&#125;'</span></span><br><span class="line"><span class="attr">  dynamodb:</span></span><br><span class="line"><span class="attr">    start:</span></span><br><span class="line"><span class="attr">      migrate:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">provider:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">aws</span></span><br><span class="line"><span class="attr">  runtime:</span> <span class="string">nodejs8.10</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">  endpointType:</span> <span class="string">REGIONAL</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">cn-north-1</span></span><br><span class="line"><span class="attr">  iamRoleStatements:</span></span><br><span class="line"><span class="attr">    - Effect:</span> <span class="string">Allow</span></span><br><span class="line"><span class="attr">      Action:</span></span><br><span class="line"><span class="attr">        - dynamodb:</span><span class="string">Query</span></span><br><span class="line"><span class="attr">        - dynamodb:</span><span class="string">Scan</span></span><br><span class="line"><span class="attr">        - dynamodb:</span><span class="string">GetItem</span></span><br><span class="line"><span class="attr">        - dynamodb:</span><span class="string">PutItem</span></span><br><span class="line"><span class="attr">        - dynamodb:</span><span class="string">UpdateItem</span></span><br><span class="line"><span class="attr">        - dynamodb:</span><span class="string">DeleteItem</span></span><br><span class="line"><span class="attr">      Resource:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&#123;</span> <span class="string">"Fn::GetAtt"</span><span class="string">:</span> <span class="string">["UsersDynamoDBTable",</span> <span class="string">"Arn"</span> <span class="string">]</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="comment">#environment:</span></span><br><span class="line">    <span class="comment">#USERS_TABLE: $&#123;self:custom.tableName&#125;</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">serverless-dynamodb-local</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">serverless-offline</span></span><br><span class="line"></span><br><span class="line"><span class="attr">functions:</span></span><br><span class="line"><span class="attr">  app:</span></span><br><span class="line"><span class="attr">    handler:</span> <span class="string">index.handler</span></span><br><span class="line"><span class="attr">    events:</span></span><br><span class="line"><span class="attr">      - http:</span> </span><br><span class="line"><span class="attr">          method:</span> <span class="string">ANY</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">          authorizer:</span> <span class="string">aws_iam</span></span><br><span class="line"><span class="attr">      - http:</span> </span><br><span class="line"><span class="attr">          method:</span> <span class="string">ANY</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">'&#123;proxy+&#125;'</span></span><br><span class="line"><span class="attr">          authorizer:</span> <span class="string">aws_iam</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="attr">  Resources:</span></span><br><span class="line"><span class="attr">    AppLambdaPermissionApiGateway:</span></span><br><span class="line"><span class="attr">      Properties:</span></span><br><span class="line"><span class="attr">        Principal:</span> <span class="string">apigateway.amazonaws.com</span></span><br><span class="line"><span class="attr">    UsersDynamoDBTable:</span></span><br><span class="line"><span class="attr">      Type:</span> <span class="string">'AWS::DynamoDB::Table'</span></span><br><span class="line"><span class="attr">      Properties:</span></span><br><span class="line"><span class="attr">        AttributeDefinitions:</span></span><br><span class="line"><span class="bullet">          -</span></span><br><span class="line"><span class="attr">            AttributeName:</span> <span class="string">userId</span></span><br><span class="line"><span class="attr">            AttributeType:</span> <span class="string">S</span></span><br><span class="line"><span class="attr">        KeySchema:</span></span><br><span class="line"><span class="bullet">          -</span></span><br><span class="line"><span class="attr">            AttributeName:</span> <span class="string">userId</span></span><br><span class="line"><span class="attr">            KeyType:</span> <span class="string">HASH</span></span><br><span class="line"><span class="attr">        ProvisionedThroughput:</span></span><br><span class="line"><span class="attr">          ReadCapacityUnits:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">          WriteCapacityUnits:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">        TableName:</span> <span class="string">$&#123;self:custom.tableName&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>serverless</tag>
      </tags>
  </entry>
  <entry>
    <title>2019回忆录</title>
    <url>/2020/01/24/2019%E5%9B%9E%E5%BF%86%E5%BD%95/</url>
    <content><![CDATA[<p>没想到这大过年的居然碰上了这档子事，大家注意防护，平平安安度过这段时期。</p>
<hr>
<p>还是习惯把除夕当做一年最后一天。今年对我来说是很重要的一年，完成了很多重要的事情，还算是比较顺利。但让我感到遗憾的是，今年无论是在公交还是地铁上，已经没有小朋友叫我哥哥，都改口叫叔叔了。</p>
<p>今年最重要的事就是把工作换了，虽然都在说今年工作不好找，但我还是幸运的找到了一个满意的工作，换完工作后，技术上自我感觉有很大的提升，原来很多只能自己玩玩的技术都可以在生产环境中用到了，好在原来底子就不差，过渡的还算顺利。对于工作，成长性应该是首先要考虑的因素，因为靠工资肯定没有办法财富自由，所以从工作中最重要是能力的成长。</p>
<p>在以前，总会下意识的觉得行业里面一些厉害的大佬会拒人千里之外，现在算是把这个观念打破了，只要不是去浪费他们的时间，而是有一些可以一起探讨的问题，他们还是很乐意帮忙的。比如今年我还认识了左耳朵这样的大牛，甚至还一起写了一篇文章，这不得不说，只要态度积极，总会有贵人帮忙。</p>
<p>另外很重要的事情是和爸妈的之间的沟通顺畅了很多，感觉和他们好好沟通之后，他们也慢慢开始理解我了，以前还经常会和爸妈之间有些争论，之前觉得他们什么都不懂，老是问一些奇怪的问题和一些不切实际的期望，对于这些问题总是没耐心回答。现在无论他们关心什么，我都可以静下心好好给他们解释，这可能是参加工作可以让人成长很快，当然也有可能是岁数到了。家庭幸福真的可以提升整个人的幸福感，毕竟家庭是我们在这个世界上最坚实的后盾。也感谢女朋友的陪伴，好的感情也可以让生活更加轻松，两个人一起成长的感觉也很棒。</p>
<p>然后就是关于自我成长的方面。换完工作，整个人也就沉下来了，所以在下半年的时候，最明显的就是阅读量飙升，完成了 50 本书的阅读计划，这 50 本书里面有很多书是重复读过的。最近体会到，一昧追求阅读数量没有太大的意义，很多书用一辈子的时间来读都不一定能读完，比如红楼梦。</p>
<p>英语的学习进度也还算可以，从新概念英语开始学习，新概念英语学起来真的很有趣，在工作之余每天学习一篇，感觉很棒，等过完年，就开始准备备考雅思了，想考雅思并不是有出国的打算，而是觉得得给自己一个目标，这样英语的水平才能被量化，这样学习起来的效率也会比较高。</p>
<p>换完工作后，终于可以让好好用空闲的时间来写作。大致估计估计了一下，今年写下的文字超过了 10 万，还是在有这么多事情需要处理的情况下。其中大部分是技术博客，也写了不少微信公众号文章。写作这件事，只要开始了就不难了。对于新年的目标，也立下了一个 flag，要写 50 万字，按照目前产出的速度来看，应该是可以完成的。</p>
<p>摄影一直说要学，一直被鸽，今年好歹把单反的灰擦了擦，重新捡起来了，现在已经可以使用单反的手动模式拍照了，别说，这感觉真好。用摄影来记录生活，我觉得可以，这对我来说也是一个可以长期积累的技能。</p>
<p>学习投资也是去年立的 flag，这里说投资其实有点浮夸了，其实目前主要就是理财，主要是股票，也会涉及一些数字货币，这方面目前还是一个新手，不过已经从学习看财报开始了。投资分两个方面，投资的技巧当然需要学习，但对于资本的深入理解也是非常有必要的。比如会买卖股票和懂股票其实是两码事，如果看不懂一个公司的财报，也就只能随随大流买股票了。从另外一个方面来说，每个人其实都是一个无限责任公司，只能活一次，而且永远要为自己的行为负责。既然是一家公司，自然也需要自己的资产负债表，学习投资，从管理自己的资产负债表开始。</p>
<p>身体是革命的本钱，运动当然不用说，频率保持的不错。另外今年也好好学习了保险的相关知识，增强了保险意识，还为爸妈和自己配备一些基本的保险，主要是重疾险和医疗险。后续在经济能力允许的范围内还会不断买一些新的保险。合理的保险能为我们增加抗风险的能力，现在国内的保险已经慢慢走向成熟，只要选择正规的保险公司，被骗的可能性也不大。</p>
<p>好了，差不多就是这些了，用一句话总结今年就是：换了工作买了房，认识了不少大牛，家庭和谐，感情稳定，最重要的是在不断提升自己的认知。</p>
<p>用我最喜欢的作家，王小波的话说，生活就是一个挨锤的过程。希望在新的一年可以锤炼出更强的自己，而不是被锤干了锐气。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Cas 认证过程研究</title>
    <url>/2018/12/16/Cas-%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h3>Cas 认证</h3>
<blockquote>
<p>本文所讨论的 Cas 系统版本是 5.1.x</p>
</blockquote>
<p>CAS 系统是单点登录（SSO）的一种实现。在开始深入研究 CAS 的认证过程之前，需要了解一下 CAS 系统的一些专有名词。</p>
<ul>
<li><strong>SSO Session</strong>：由 CAS 服务器维护的一个单点登录的 Session，在 CAS 服务器中记录用户的登录状态</li>
<li><strong>TGC</strong>(Ticket-Granting-Cookie)：由 SSO session 在浏览器端建立的一个 Cookie，这个 Cookie 用来维护客户端的登录状态</li>
<li><strong>TGT</strong>(Ticket-Granting-Ticket)：TGT 存储在 TGC 中，CAS 服务器通过 TGT 来判断客户端在 CAS 服务器中是否存在 SSO Session</li>
<li><strong>ST</strong>(Service-Ticket)：由 CAS 服务器为特定用户生成的用于访问特定客户端的凭证，ST 作为 GET 方法的参数进行传递</li>
</ul>
<h4>CAS 系统认证的环境</h4>
<ul>
<li><strong>CAS Server</strong>：CAS 认证的服务器，认证中心，用户输入的表单数据会在 CAS Server 中进行认证，认证成功后也由 CAS Server 发放（TGT），同时 CAS Server 也负责校验 TGT 的合法性。</li>
<li><strong>CAS Management</strong>：CAS Server 的应用管理中心，每一个通过 CAS Server 认证的应用都需要在 CAS Management 中进行注册，CAS Management 默认已经注册，并且 CAS Management也是通过 CAS Server 进行认证 。</li>
<li><strong>CAS Client</strong>：CAS Client 就是一个个应用，每一个 Client 在 cas-management 中进行注册之后，就可以在 CAS Server 中进行认证。</li>
</ul>
<p>CAS Server 和 CAS Management 官方都有提供开箱即用的程序，只要部署到 Tomcat 或者 Docker 中就行。</p>
<p>而CAS Client 就是我们自己开发的应用程序，应用如果要集成到 CAS Server 中，还需要集成一些官方提供的模块，具体的集成方式在<a href="https://apereo.github.io/cas/5.1.x/integration/CAS-Clients.html" target="_blank" rel="noopener">这里</a>。</p>
<p>在部署了 CAS Server 相关的程序后，访问应用程序就可以触发认证的过程。</p>
<h4>CAS 具体认证过程</h4>
<p>对于 CAS Server 来说，可以把认证的过程的分成三类，为了下文叙述方便，我们把 CAS Server 命名为 CS，应用1为 app1, 应用2为 app2：</p>
<ul>
<li>初次访问 app1</li>
<li>认证通过后访问app1</li>
<li>认证通过后访问应用群内的 app2</li>
</ul>
<p><strong>初次访问 app1</strong>：</p>
<ol>
<li>用户通过浏览器首次访问 app1，app1 检查用户的请求中是否包含认证信息，检查后发现没有，app1 就给浏览器返回了一个重定向，定向到 CS 的登录接口，并且携带一个 service 参数，参数的值为 app1 的 url。</li>
<li>浏览器通过重定向访问 CS 的登录接口，CS 在接收到访问请求之后会先检查服务器中是否有 app1 的SSO Session，检查后发现没有就会返回一个登录的表单。</li>
<li>用户在登录表单中填写用户名和密码。填写完成之后表单就会被提交到 CS，CS 对用户名和密码进行认证，如果认证通过 CS 就会为该用户生成一个 SSO Session、一个 ST。并且在浏览器中生成一个包含 TGT 的TGC Cookie。</li>
<li>然后浏览器继续访问 app1，app1接收到这个请求后拿到 ST 参数，就会拿着 ST 去 CS进行校验，校验通过后 CS 会给 app1 返回一个 http 状态为 200 的回复（代表认证成功），同时携带一些 app1 需要的其他数据。app1 接收到后就会在浏览器中生成一个 app1 的 Cookie。然后用户就可以正常的访问 app1，用户首次访问 app1 的流程到这里也就结束了。</li>
</ol>
<p><strong>认证通过后访问 app1</strong>：</p>
<ol>
<li>首先 app1 会检查用户的 TGC 有没有过期，如果 TGC 过期，那么就需要重新走一次 初次访问的流程。</li>
<li>如果 TGC 有效，那么 用户就可以继续访问 app1。</li>
</ol>
<p><strong>认证通过后访问 app2</strong>：</p>
<ol>
<li>用户通过浏览器访问 app2，然后 app2 会把这个请求重定向到 CS 的登录接口，CS 接收到请求后，会校验请求携带过来的 TGT，如果没有 TGT 或者 TGT 过期，那么就会重新走一次初次登录的逻辑。</li>
<li>如果 TGT 通过校验，那么 CS 就会为 app2 生成一个新的 ST。然后浏览器就会带着这个新的 ST 去访问 app2， app2 拿到 ST 后会再次去 CS 校验 ST 的合法性。</li>
<li>在 ST 得到了 CS 的验证后，app2 就会在浏览器中生成新的 cookie，然后让用户访问 app2。</li>
</ol>
<p>这三个过程基本就是 CAS 认证的所有过程了，任何的认证都可以归为这三类中的一类。虽然 CAS 认证的过程看起来很复杂，但是实际上可以总结为任何应用的访问权都需要 CS 来决定，在通过 CS 的认证后，每一个应用的访问就是一个普通 Web 程序的访问方式了。</p>
<h4>CAS Ticket 研究</h4>
<p>Ticket 可以算是 CAS 体系中最为核心的部分，那么对于 Ticket 来说，有两个重要的配置需要关注:</p>
<ul>
<li>TicketRegistry: Ticket 的存储</li>
<li>ExpirationPolicy：Ticket 的过期策略</li>
</ul>
<p>在 CAS 系统中，Ticket 的存储可以有多种方式：</p>
<p><strong>基于内存的存储</strong>：</p>
<p>这种方式只适合开发阶段或者小项目的部署，涉及到项目时就不适合使用这种方式。</p>
<p><strong>基于缓存的存储</strong>：
这个方式很适合在高可用的部署环境中使用（部署在 Docker 上）。支持以下的存储方式:</p>
<ul>
<li>Hazelcast</li>
<li>Encache</li>
<li>Ignite</li>
<li>Memcached</li>
<li>Infinispan</li>
</ul>
<p><strong>基于关系型数据库的存储</strong>：</p>
<p>这种方式适合在分布式部署中，有多个 CAS 节点的环境下：</p>
<ul>
<li>JPA</li>
</ul>
<p><strong>基于 NoSql 的存储</strong>：
支持以下的 NoSql数据库:</p>
<ul>
<li>Infinispan</li>
<li>Couchbase</li>
<li>Redis</li>
<li>MongoDb</li>
<li>DynamoDb</li>
</ul>
<p>对于 TGT 和 ST 有着不同的过期策略：</p>
<p><strong>TGT</strong>:</p>
<ul>
<li>Hard-Time：设定一个时间，到时间 TGT 就过期</li>
<li>Timeout: 超时策略，超过一定时间没有访问就会过期</li>
<li>Hard-Timeout：与 Hard-Time 类似，在 TGT 创建后的一段时间后就会过期</li>
<li>Throttled：设定 TGT 最多每 N 秒使用一次，超过这个次数 TGT 就会过期</li>
<li>Never: TGT 永不过期</li>
</ul>
<p><strong>ST</strong>:</p>
<p>ST 只有一个过期策略，ST 是依赖 TGT 存在的，所以 ST 的过期策略与 TGT 有关，当 TGT 过期后，ST也会一起过期。</p>
<p>（完）</p>
<p>[1]<a href="https://apereo.github.io/cas/5.1.x/planning/Architecture.html" target="_blank" rel="noopener">CAS 官方文档</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>cas</tag>
      </tags>
  </entry>
  <entry>
    <title>2020文章合集</title>
    <url>/2020/12/19/2020%E6%96%87%E7%AB%A0%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>2020 在很快就过去了，时间过的很快，这一年你有什么收获吗？虽然说这一年，发生了很多不好的事情，但这一年总归是过去了，希望新的一年一切顺利。</p>
<p>在过去的一年中，也产出了不少的文章，在这里将这些文章整理一下，方便搜索和查看。</p>
<h2>Java 基础篇</h2>
<p><a href="https://rayjun.cn/2020/05/06/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3-Java-%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97/" target="_blank" rel="noopener">你真的理解 Java 的基础数据类型吗</a></p>
<p><a href="https://rayjun.cn/2020/08/30/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82-Java-%E7%9A%84-main-%E6%96%B9%E6%B3%95%E5%90%97/" target="_blank" rel="noopener">你真的懂 Java 的 main 方法吗</a></p>
<p><a href="https://rayjun.cn/2020/05/10/Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8C%85%E8%A3%85%E7%B1%BB/" target="_blank" rel="noopener">Java 为什么需要包装类</a></p>
<p><a href="https://rayjun.cn/2020/05/17/Java%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/" target="_blank" rel="noopener">Java 如何处理异常情况</a></p>
<p><a href="https://rayjun.cn/2020/08/09/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Java8-%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" target="_blank" rel="noopener">如何理解 Java8 的函数式编程</a></p>
<p><a href="https://rayjun.cn/2020/06/07/HBase-%E5%B8%B8%E7%94%A8-shell-%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener">HBase 常用 Shell 命令手册</a></p>
<p><a href="https://rayjun.cn/2020/06/14/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%90%86%E8%A7%A3HBase%E5%92%8CBigTable/" target="_blank" rel="noopener">如何优雅的理解HBase和BigTable</a></p>
<p><a href="https://rayjun.cn/2020/11/14/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0/" target="_blank" rel="noopener">如何正确的关闭线程池</a></p>
<p><a href="https://rayjun.cn/2020/11/29/Spring%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" target="_blank" rel="noopener">Spring中的线程池与任务调度</a></p>
<p><a href="https://rayjun.cn/2020/12/06/Gson-%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/" target="_blank" rel="noopener">Gson 中的一个坑</a></p>
<h2>Java 原理篇</h2>
<p><a href="https://rayjun.cn/2020/07/25/JVM%E7%B3%BB%E5%88%97-%E8%AF%BB%E6%87%82-GC-%E6%97%A5%E5%BF%97/" target="_blank" rel="noopener">JVM系列-读懂 GC 日志</a></p>
<p><a href="https://rayjun.cn/2020/08/01/JVM%E7%B3%BB%E5%88%97-JVM%E5%8F%82%E6%95%B0%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener">JVM系列-JVM参数手册</a></p>
<p><a href="https://rayjun.cn/2020/05/24/%E4%BB%8E%E5%BC%95%E7%94%A8%E8%81%8A%E4%B8%80%E8%81%8A-Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" target="_blank" rel="noopener">从引用聊一聊 Java 垃圾回收</a></p>
<p><a href="https://rayjun.cn/2020/09/06/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8D%E7%94%A8%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/" target="_blank" rel="noopener">为什么Java二维数组不用指定列的长度</a></p>
<p><a href="https://rayjun.cn/2020/09/18/%E4%BB%8E-Java-%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%88%B0%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">从 Java 中的零拷贝到五种 IO 模型</a></p>
<p><a href="https://rayjun.cn/2020/10/16/Java-%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%98%AF%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">Java 中的反射是什么</a></p>
<p><a href="https://rayjun.cn/2020/10/27/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">什么是动态代理</a></p>
<p><a href="https://rayjun.cn/2020/10/30/cglib%E5%85%A5%E9%97%A8%E5%89%8D%E7%AF%87/" target="_blank" rel="noopener">cglib 入门前篇</a></p>
<p><a href="https://rayjun.cn/2020/11/10/cglib%E5%85%A5%E9%97%A8%E5%90%8E%E7%AF%87/" target="_blank" rel="noopener">cglib入门后篇</a></p>
<h2>系统篇</h2>
<p><a href="">你知道吗？缓存不只是用 Redis</a></p>
<p><a href="https://rayjun.cn/2020/05/31/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Apache-CXF-%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-WebService/" target="_blank" rel="noopener">如何使用 Apache CXF 快速实现一个 WebService</a></p>
<p><a href="https://rayjun.cn/2020/08/15/%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8F%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81/" target="_blank" rel="noopener">如何隐藏你的数据库密码</a></p>
<h2>分布式篇</h2>
<p><a href="https://rayjun.cn/2020/03/26/%E7%9C%8B%E5%92%96%E5%95%A1%E5%BA%97%E5%A6%82%E4%BD%95%E5%81%9A%E6%89%A9%E5%AE%B9/" target="_blank" rel="noopener">像经营咖啡店一样扩容 Web 系统</a></p>
<p><a href="https://rayjun.cn/2020/08/23/%E5%8F%AF%E4%BC%B8%E7%BC%A9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">可伸缩系统架构简介</a></p>
<p><a href="https://rayjun.cn/2020/06/21/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4/" target="_blank" rel="noopener">如何搭建一个本地服务器集群</a></p>
<p><a href="https://rayjun.cn/2020/06/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAHadoop%E9%9B%86%E7%BE%A4/" target="_blank" rel="noopener">如何搭建一个Hadoop集群</a></p>
<p><a href="https://rayjun.cn/2020/07/04/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAZookeeper%E9%9B%86%E7%BE%A4/" target="_blank" rel="noopener">如何搭建一个Zookeeper集群</a></p>
<p><a href="https://rayjun.cn/2020/07/11/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAHBase%E9%9B%86%E7%BE%A4/" target="_blank" rel="noopener">如何搭建一个HBase集群</a></p>
<p><a href="https://rayjun.cn/2020/07/12/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAHive%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">如何搭建Hive 环境</a></p>
<h2>工具篇</h2>
<p><a href="https://rayjun.cn/2020/07/18/tcpdump-%E5%AE%9E%E4%BE%8B-%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%8C%85%E7%9A%8450%E7%A7%8D%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">tcpdump 实例-获取网络包的50种方法</a></p>
<p><a href="https://rayjun.cn/2020/10/11/%E9%85%8D%E7%BD%AEUbuntu%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">配置Ubuntu工作环境</a></p>
<p><a href="https://rayjun.cn/2020/12/12/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%90%9C%E7%B4%A2%E7%A5%9E%E5%99%A8fzf/" target="_blank" rel="noopener">命令行搜索神器fzf</a></p>
<p><a href="https://rayjun.cn/2020/12/13/Vim%E6%90%9C%E7%B4%A2%E7%A5%9E%E5%99%A8fzf/" target="_blank" rel="noopener">Vim搜索神器fzf</a></p>
<h2>SQL 篇</h2>
<p><a href="https://rayjun.cn/2020/10/04/SQL%E6%98%AF%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">SQL是什么</a></p>
<p><a href="https://rayjun.cn/2020/09/25/SQL%E5%A6%82%E4%BD%95%E5%81%9AJoin/" target="_blank" rel="noopener">SQL如何做Join</a></p>
<p>新的一年顺利~</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>合集</tag>
      </tags>
  </entry>
  <entry>
    <title>Context 和 struct</title>
    <url>/2021/09/12/Context-%E5%92%8C-struct/</url>
    <content><![CDATA[<p>原文地址：<a href="https://go.dev/blog/context-and-structs" target="_blank" rel="noopener">https://go.dev/blog/context-and-structs</a></p>
<p>在很多 Go 的 API 中，特别是新的 API，函数或者方法的第一个参数通常是 <code>context.Context</code>。context.Context 可以在不同的 API 之间传递一些信号，比如 deadline、调用者的取消信号，也可以传递一些请求范围内的数据。在一个库需要直接或者间接的与数据库、远程 API 等等远程服务进行交互的时候会用到。</p>
<p>在 Context 的文档中这样说到：c<strong>ontext 只应该在每个函数需要用到它的时候传递，而不应该存储在 struct 中</strong>。</p>
<p>这篇文章会通过一些例子来说明为什么应该直接传递 context，而不是把它存储在另一个类型中。同时也会介绍一个把 context 安全存储在 struct 中的少见案例，并会解释为什么要这么做。</p>
<h2>把 context 作为参数</h2>
<p>我们先来看一个把 context 作为参数的例子，来看看把 context 当做参数传递传递的优点：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Worker 把 work 添加到远程的服务运行</span></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Work <span class="keyword">struct</span> &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Worker</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Worker&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Fetch</span><span class="params">(ctx context.Context)</span> <span class="params">(*Work, error)</span></span> &#123;</span><br><span class="line">  _ = ctx <span class="comment">// 一个提前传入的 ctx 用来控制请求的 deadline、取消以及元数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Process</span><span class="params">(ctx context.Context, work *Work)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  _ = ctx <span class="comment">// 一个提前传入的 ctx 用来控制请求的 deadline、取消以及元数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里 <code>(*Worker).Fetch</code> 和 <code>(*Worker).Process</code> 都直接把 context 作为第一个参数。用户可以为每一次调用设置 deadline、取消和元数据。并且这样可以很清晰的看到 context 在每个方法中的使用方式，这样就不会让传递到一个方法中的 context 会在其他的方法中被调用。这是因为 conetext 的作用域限制到了真正需要它的地方，这样 context 就会实用而清晰。</p>
<h2>把 context 存进 struct 会造成误解</h2>
<p>我们再看一下上面的例子，并做一点小改动，把 context 放进 struct 中。这样做问题在于这样会让调用者的生命周期变得模糊，或者会把这两者的作用域混在一起，这样更糟糕。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">  ctx context.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(ctx context.Context)</span> *<span class="title">Worker</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Worker&#123;ctx: ctx&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Fetch</span><span class="params">()</span> <span class="params">(*Work, error)</span></span> &#123;</span><br><span class="line">  _ = w.ctx <span class="comment">// 共享的 w.ctx 用来控制请求的 deadline、取消以及元数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">Process</span><span class="params">(work *Work)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  _ = w.ctx <span class="comment">// 共享的 w.ctx 用来控制请求的 deadline、取消以及元数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里 <code>(*Worker).Fetch</code> 和 <code>(*Worker).Process</code> 共用一个存储在 Worker 中的 context。这将会让 Fetch 和 Process 的调用者无法指定 deadline、取消请求或者获取元数据，因为一个请求中可能有不同的 context。举个例子来说，无法只为 (*Worker).Fetch 指定 deadline，也无法只取消 (*Worker).Process。调用者的生命周期被一个共享的 context 打乱了，而且 context 的生命周期与 Worker 的生命周期相同。</p>
<p>相比于之前的那种写法，这种更容易让人疑惑。用户可能会问他们自己：</p>
<ul>
<li>在创建一个新的 context 的时候，怎么知道后面是需要取消请求还是设置一个 deadline</li>
<li>这个 context 能不能在 (*Worker).Fetch 和 (*Worker).Process 继续传递，两个都不能？还是一个可以，一个不行</li>
</ul>
<p>在这个 API 中，我们就需要在文档中明确的告诉用户这里的 context 是用来做什么的。用户可能得通过阅读代码，而不是直接通过 API 的结构来判断 context 的用途。</p>
<h2>例外：向后保持兼容性</h2>
<p>当 Go1.17 发布的时候，大量的 API 需要添加 context 以保证 API 的向后兼容性。比如 net/http 中的 Client 方法，Get、Do 都需要添加 context。每一个通过这些方法发送的外部请求，都可以通过 context 来传递 deadline、取消请求、传递元数据。</p>
<p>这里有两种可以保持向后兼容的方式来添加对 context 的支持：第一个方法就是把 context 放在一个 struct 中，就像我们前面看到的那样，另一种方法就是重新写一个不同名称的方法，添加 context 参数。就像我们在如何保证模块的兼容性中讨论的那样，第二种方法应该要优于第一种方法。但是在一些情况下，是无法这样实现的：比如你的 API  暴露了大量的方法，然后把它们全部都重写一遍，这样可能会让代码很混乱。</p>
<p>net/http 包选则了第一种方法，这里也提供了一个很值得学习的例子。我们来看一下其中的 Do 方法，在添加 context 之前，它是这样定义的：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Do 发送 http 请求并且返回 http 的响应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Do</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>在 Go1.17 之后，如果我们不管向后的兼容性，Do 的定义可能是下面这样：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Do 发送 http 请求并且返回 http 的响应 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Do</span><span class="params">(ctx context.Context, req *Request)</span> <span class="params">(*Response, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>但为了保护兼容性，并且遵守 Go 对标准库兼容性的保证非常重要。所以，维护者选择在 http.Request 中添加一个 context 来保证这个 API 的向后兼容性：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">  ctx context.Context</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 context 用于这个请求的生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequestWithContext</span><span class="params">(ctx context.Context, method, url <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(*Request, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Simplified for brevity of this article.</span></span><br><span class="line">  <span class="keyword">return</span> &amp;Request&#123;</span><br><span class="line">    ctx: ctx,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Do</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>当你在为你的 API 添加对 context 的支持时，可以选择把 context 添加到 struct 中。然而，在不破坏代码的可用性和可读性时，为了保证代码的向后兼容，还是应该重新创建一个方法，像下面这样：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Call</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> c.CallContext(context.Background())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">CallContext</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>小结</h2>
<p>在一个调用栈中，Context 在跨库或者跨 API 传递信息时非常有用。但为了保证可读性、可调试性和有效性，它必须保持简洁和连贯。</p>
<p>当通过参数传递 context 而不是存储在 Context 中时，用户可以完全利用它的扩展性在调用栈中构造一个由取消、deadline 和元数据信息组成的树，并且在通过参数传递时，它们的作用域是非常清晰，这让代码的可读性和可调试性都非常好。</p>
<p>当在设计一个带 context 的 API 时，记住一点：通过参数传递 context，不要把它存在 struct 中。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Context 详解</title>
    <url>/2021/08/30/Context-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Go 中有一个 Context 接口，配合 goroutine 使用，主要是用来协调 goroutine 的执行，但是比较难理解，这篇文章中来详细分析一下。</p>
<h2>1. Context 是什么</h2>
<p>在 Go 1.7 版本，引入了一个接口 context.Context。 Context 从字面意思来看，就是上下文的意思，可以理解为它就是某个请求的上下文。</p>
<p>它主要的作用是在 Go 进程中<strong>传递信号</strong>。这里需要注意，虽然也可以传递参数，但主要传递信号，Context 不推荐用来传递大量的参数。</p>
<p>Context 接口有四个方法：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	Err() error</span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这四个方法看起来有点抽象：</p>
<ul>
<li>Deadline：这个方法返回 Context 被取消的时间，也就是 Context 生命周期结束的时间</li>
<li>Done：返回一个 channel，这个 channel 会在 Context 生命周期结束之后被关闭，多次调用 Done 返回的是同一个 channel</li>
<li>Err：返回 Context 结束的原因，这里只会在 Done 方法返回的 channel 关闭之后才返回非空的值</li>
<li>Value：从 Context 中获取对应 Key 的值，这里面最好放入不可变的值，因为 Context 会在多个 goroutine 中传递，如果值是经常变化的话，有可能会带来意外的结果</li>
</ul>
<h2>2. 为什么需要 Context</h2>
<p>以服务端为例，服务端在接收一个请求之后，就需要启动新的 goroutine 来处理这个请求，有可能会启动多个 goroutine。</p>
<p>多个 goroutine 启动之后，很难再去协调这些 goroutine，比如这个请求结束或者被终止，在这样的情况下，所有相关的 gouroutine 都应该被终止。</p>
<p>下面是一个简单的 http 服务，访问 <code>[http://localhost:8080/index](http://localhost:8080/index)</code> 之后，请求很快就返回了，正常情况下，在代码中启动的 goroutine 都应该结束，但是实际上，里面的 goroutine 还是会执行，最后会打印 &quot;goroutine2 invoke&quot;。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"goroutine1 invoke"</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">// 模拟费时操作</span></span><br><span class="line">			<span class="keyword">case</span> &lt;- time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">				fmt.Println(<span class="string">"goroutine2 invoke"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;()</span><br><span class="line">	writer.Write([]<span class="keyword">byte</span>(<span class="string">"index"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"server starting"</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>但这种情况不是我们希望看到的，理想的情况下一个请求的结束，那么这个请求启动的 goroutine 都应该结束。这里就需要通过 Context 来做到。</p>
<h2>3. Context 能做什么</h2>
<p>可以使用 Context 来解决上面的问题，简单来说就是通过 Context 来串联所有的 goroutine，所有的goroutine 根据 Context 的状态来决定是否还要继续执行。</p>
<p>在一个请求中，不使用 Context，执行的状态是这样的：</p>
<p><img src="0.png" alt=""></p>
<p>在使用 Context 之后，执行的状态是这样的：</p>
<p><img src="1.png" alt=""></p>
<h3>3.1 创建一个 Context</h3>
<p>在使用 goroutine 之前，需要先创建 Context，Go 提供了两种创建 Context 的方法，使用 <code>context.Background()</code> 或者 <code>context.ToDo()</code> 方法：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个方法生成的 Context 其实都是 emptyCtx，这是一个 Context 接口的空实现：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在功能的角度，context.Background 和 context.Todo 没有区别，只是用来表达不同的用途，Background 表示是最顶层的 Context，其他的 Context 都应该由 Background 衍生而来，关于衍生的概念我们下面会讲到。而 Todo 用于还不确定定使用哪个 Context。</p>
<p>通常，如果没有通过参数接收到 Context，我们就会使用 Background 作为初始的 Context 向后传递。</p>
<h3>3.2 衍生 Context</h3>
<p>通过上面的 Background 创建的 Context 实际上是一个空实现，无法用来执行具体的逻辑。那么就需要根据具体的场景，衍生出相应的 Context。</p>
<p>每个衍生出来的 Context 都和父 Context 的状态保持一致，如果一个 Context 状态变化，那么通过这个 Context 衍生出来的所有 Context 都会改变。</p>
<p>衍生 Context 可以通过 4 个方法来完成：</p>
<ul>
<li>WithCancel</li>
<li>WithTimeout</li>
<li>WithDeadline</li>
<li>WithValue</li>
</ul>
<p>使用 WithCancel 来衍生新的 Context:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">background := context.Background()</span><br><span class="line">child1, cancelFunc := context.WithCancel(background)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 继续衍生 Context</span></span><br><span class="line">	child2, _ := context.WithCancel(child1)</span><br><span class="line">	<span class="comment">// 继续衍生 Context</span></span><br><span class="line">	child3, _ := context.WithCancel(child2)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 接收到取消信号</span></span><br><span class="line">	<span class="keyword">case</span> &lt;- child3.Done():</span><br><span class="line">		fmt.Println(<span class="string">"context canceled"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用取消方法</span></span><br><span class="line">cancelFunc()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br></pre></td></tr></table></figure></p>
<p>使用 WithTimeout 来衍生新的 Context:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">background := context.Background()</span><br><span class="line"></span><br><span class="line">child1, _ := context.WithTimeout(background, <span class="number">3</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 继续衍生 Context</span></span><br><span class="line">	child2, _ := context.WithCancel(child1)</span><br><span class="line">	<span class="comment">// 继续衍生 Context</span></span><br><span class="line">	child3, _ := context.WithCancel(child2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// context 超时的时间</span></span><br><span class="line">	timeout, _ := child3.Deadline()</span><br><span class="line">	fmt.Printf(<span class="string">"timeout is %+v\n"</span>, timeout)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 接收到超时</span></span><br><span class="line">	<span class="keyword">case</span> &lt;- child3.Done():</span><br><span class="line">		fmt.Println(<span class="string">"context timeout"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br></pre></td></tr></table></figure></p>
<p>使用 WithDeadline 来衍生新的 Context:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">background := context.Background()</span><br><span class="line">child1, _ := context.WithDeadline(background, &lt;-time.After(<span class="number">3</span> * time.Second))</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 继续衍生 Context</span></span><br><span class="line">	child2, _ := context.WithCancel(child1)</span><br><span class="line">	<span class="comment">// 继续衍生 Context</span></span><br><span class="line">	child3, _ := context.WithCancel(child2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// context 超时的时间</span></span><br><span class="line">	timeout, _ := child3.Deadline()</span><br><span class="line">	fmt.Printf(<span class="string">"timeout is %+v\n"</span>, timeout)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 接收到超时</span></span><br><span class="line">	<span class="keyword">case</span> &lt;- child3.Done():</span><br><span class="line">		fmt.Println(<span class="string">"context timeout"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br></pre></td></tr></table></figure></p>
<p>还有最后一个方法比较特殊，WithValue 在衍生 Context 的同时，可以放入键值对:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">background := context.Background()</span><br><span class="line">child1 := context.WithValue(background, <span class="string">"ray"</span>,<span class="string">"jun"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := child1.Value(<span class="string">"ray"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"values is %+v\n"</span>, v)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码可以看到，只要一个 Context 取消，或者设置了超时之后，后面衍生出来的所有 Context 都可以获取到这个状态，Context 是线程安全的，可以在多个 goroutine 之间使用。</p>
<p>上面的 http 服务可以使用 Context 来结束内部的 goroutine 执行，每个 request 中都有一个 Context，可以直接使用：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">	c := request.Context()</span><br><span class="line">	cancelContext, cancelFunc := context.WithCancel(c)</span><br><span class="line">	<span class="keyword">defer</span> cancelFunc()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"index goroutine1"</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			    <span class="keyword">case</span> &lt;-cancelContext.Done():</span><br><span class="line">				    fmt.Println(<span class="string">"request is done"</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> &lt;- time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">					fmt.Println(<span class="string">"goroutine is invoke"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	writer.Write([]<span class="keyword">byte</span>(<span class="string">"index"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">"server starting"</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>请求结束之后，里面的 goroutine 就不会继续执行。</p>
<h2>4. Context 内部实现</h2>
<p>下面来看一下，Context 是如果实现的，使用 Background 生成的 Context 是一个空实现。而且 Background 生成的 Context 无法被取消，也不会过期。</p>
<p>通常在都会使用 With 系列方法来衍生 Context 来使用，下面就来看一下几个 With 方法的实现，四个方法的实现都差不多，这里我们以 WithCancel 方法为例：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)</span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进入到方法之后，首先会生成一个新的 cancelCtx，这是一个内部的结构体，另外 WithDeadline 会创建一个 timerCtx，WithTimeout 会直接调用 WithDeadline，WithValue 则会创建一个 valueCtx。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context                        <span class="comment">// 保存父 Context</span></span><br><span class="line">	mu       sync.Mutex            <span class="comment">// 这个锁用来保证下面变量的方式是安全的</span></span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// 用来表示 Context 是否结束</span></span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// 保存衍生的 Context </span></span><br><span class="line">	err      error                 <span class="comment">// Context 结束时的错误信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后会调用 propagateCancel 方法来构建子 Context 和父 Context 的关系：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	done := parent.Done()</span><br><span class="line">	<span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// 空的 Context 无法被取消</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-done:</span><br><span class="line">		<span class="comment">// 这里表示父 Context 已经结束，直接返回错误</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里找出父 Context 是可取消的 Context</span></span><br><span class="line">	<span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 如果父 Context 已经结束，这里直接结束</span></span><br><span class="line">			child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则就把这个当前的这个 Context 加入到 map 中</span></span><br><span class="line">			<span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">				p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果父类型不是可取消的类型，直接启动一个新的 goroutine 来监听父 Context 是否结束，以及监听当前 Context 是否已经结束</span></span><br><span class="line">		atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">				child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">			<span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>当父 Context 是不可取消的类型，直接返回，否则检查父 Context 是否已经结束，如果结束，直接返回错误信息</li>
<li>然后找出父 Context 中是否有 Cancel 类型的 Context：
<ol>
<li>如果有，且被取消，当前 Context 会直接被取消</li>
<li>如果没有被取消，那么当前 Context 会被直接添加到父 Context 的 map 中</li>
</ol>
</li>
<li>当父 Context 中没有可取消的 Context 时，直接监听父 Context 的状态，当父 Context 关闭时，直接取消当前的 Context</li>
</ol>
<p>与父 Context 建立联系后，会返回 Context 和一个 cancel 方法：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line">	c.err = err</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = closedchan</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(c.done)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	c.children = <span class="literal">nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当在代码中主动调用 cancel 方法时，会关闭 Done 通道，同时会把由当前 Conetx 衍生出来的可取消的 Context 都关闭，同时将这个 Context 从父 Context 中移除。</p>
<h2>5. 小结</h2>
<p>Context 提供了一种协调多个 goroutine 的运行，可以在多个 goroutine 之间安全的传递，让那些没必要执行 goroutine 尽快停止，释放系统资源。Context 主要用来传递信号，虽然也提供了传递值的方法，但不推荐使用这个方法来传递大量的数据，通常只用来传递简单不可变的数据，比如用户的认证 token 和请求的 traceId。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>FaceBook的扩容策略</title>
    <url>/2020/04/01/FaceBook%E7%9A%84%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>这是一篇<a href="http://highscalability.com/blog/2010/8/2/7-scaling-strategies-facebook-used-to-grow-to-500-million-us.html" target="_blank" rel="noopener">译文</a>，虽然写这篇文章时， Facebook 用户才增长到 5 亿，但是文章依然值得参考，毕竟即使在如今，用户能到 5 亿的应用依然凤毛麟角。</p>
<hr>
<p>在 2010 年，Facebook 达到了一个里程碑，用户数超过了 5 亿。</p>
<blockquote>
<p>PS: 这个时候微信估计才刚刚立项</p>
</blockquote>
<p>在这样的里程碑上，Facebok 分享了构建这样一个可扩展系统的 7 条策略。可能 5 亿用户这个数字很难让人直观的感受到这个系统的复杂性，那么可以来看看下面这些指标：</p>
<ul>
<li>一个工程师需要负责 100 万用户</li>
<li>5 亿活跃用户</li>
<li>每天 1 千亿的点击量</li>
<li>50 亿照片</li>
<li>2 万亿对象缓存，每秒需要处理几百万用户请求</li>
<li>每天 130 TB 的日志</li>
</ul>
<p>Facebook 是如何处理这个情况的：</p>
<ol>
<li>
<p>人最重要
系统是通过人来构建和运行的，最好的扩容工具是工程和运维团队，他们可以处理一切事情。</p>
</li>
<li>
<p>水平扩容
处理指数级增长的流量需要在许多机器上任意分配负载。对帐户和用户信息等表使用不同的数据库只能使容量增加一倍。这种方法会影响效率，但是效率是与可伸缩性无关的，效率本身不会对可伸缩性产生实质性的影响。</p>
</li>
<li>
<p>快速行动
在扩容的每一个层面上都会有意外。对于这些意外的情况，需要一个可以处理任何问题的高度水平的、灵活的、足够熟练的跨项目团队。灵活性比任何单独的技术决策都重要。Facebook 通过快速行动也能快速试错，然后找出最好的方法。</p>
</li>
<li>
<p>增量变更
做出小的改变并且量化结果是快速行动的关键。大的事情需要分解成不同的部分，变更不能成批的出现。这些小变更可以通过少量机器向少量的用户推送。新的系统可以和旧系统并存，通过对新系统结果的量化，慢慢将流量向新系统迁移。整个系统的稳定性会通过增量变更来提高，因为你可以快速的知道一个特定的策略是否有效果。使用较小的增量变化，更容易找到出错的地方。</p>
</li>
<li>
<p>量化一切
线上环境时收集有用数据的好地方。量化系统和应用程序级别的数据就可以了解发生了什么。检查第95或第99百分位的情况，因为平均值隐藏了重要的问题。</p>
</li>
</ol>
<blockquote>
<p>PS: 要检查那些出现的次数不是很多的问题，因为在这个背后可能隐藏着更大的问题</p>
</blockquote>
<ol start="6">
<li>
<p>小而独立的团队
小团队可以高效、快速、谨慎地完成工作。举例来说，在最大的照片网站上（<strong>指 Facebook</strong>），只有三个人在负责照片方面的工作。</p>
</li>
<li>
<p>职责控制
控制职责。如果一个团队为某事负责，他们必须能够控制它。举例来说，Facebook 每天都会向生产环境中发布代码。那么编写代码的人就需要负责修复任何出错的地方。如果写代码和发布代码的职责是分离的，那么写代码的人就无法感受到坏代码会对系统造成什么样的影响。罗伯特（Facebook 的工程主管）说的很好：我们所知道的为 5 亿人做一个好软件的最好方法是让工程师理解他们所做事情的重要性，从而让他们在可以控制的范围内做出好的决定。</p>
</li>
</ol>
<p>这些原则并不是什么新点子，但是这些原则可以很轻易的组合在一起，然后形成一个自我强化的良性循环。如果没有小团队和清晰的职责，就无法快速行动。如果你不把这些变更提交到生产环境然后量化结果，你就无法知道这些变更是好是坏。除非工程师知道自己有责任去修改生产环境的代码，否则就很难向生产环境发布代码。如果你无法实现横向扩展，快速行动，然后量化结果，你就无法处理好系统的扩容。当然，做好这一切都需要优秀的人。</p>
<p>这些原则可以支持再增长 5 亿用户吗？根据第一条原则，我认为答案时肯定的。世界正在快速变化，在未来将会有不可预见的挑战，但是优秀的人会根据环境来学习和进化。目前来说，Facebook 面临的挑战是如何持续的去实践这些原则，并且要避免组织的规模和复杂度达到临界点后出现组织腐败，然后影响其他组织。</p>
<blockquote>
<p>PS: 归根结底，人才是一个公司中最重要的部分，公司对人才的要求时不能放松的。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式 扩容</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系列-deamon详解</title>
    <url>/2016/03/18/2016-03-18-LinuxService%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3>daemon 与 service</h3>
<p>在 Linux 系统中，常驻在内存中，提供一些系统或者网络功能的程序就称之为 service，而这个运行的程序我们就称之为 daemon。
实际上，这两个概念没有必要分得那么清楚，这两个名称只是在不同角度的不同的称谓， service 是在系统角度来看的， daemon 则是
在程序的角度上来看的。</p>
<p>在这篇文章中，我们主要详细介绍一下常规 daemon 的详细配置以及开机启动配置，在后续的文章中，我会详细介绍 deamon。</p>
<h3>deamon 的启动脚本与启动方式</h3>
<p>deamon 程序通常是由一个脚本来启动，在启动 deamon 的时候，脚本会完成以下的工作:</p>
<ul>
<li>环境的侦测</li>
<li>配饰文件的分析</li>
<li>PID 文件的放置</li>
<li>以及给程序运行过程中相关的文件上锁</li>
</ul>
<table>
<thead>
<tr>
<th>目录</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/init.d/*</td>
<td>启动脚本放置的地方</td>
<td></td>
</tr>
<tr>
<td>/etc/sysyconfig/*</td>
<td>各服务的初始化环境配置文件</td>
<td></td>
</tr>
<tr>
<td>/etc/xinetd.conf /etc/xinted.d/*</td>
<td>super deamon</td>
<td></td>
</tr>
<tr>
<td>/etc/*</td>
<td>各服务各自的配置文件</td>
<td></td>
</tr>
<tr>
<td>/var/lib/*</td>
<td>各服务器产生的数据库</td>
<td></td>
</tr>
<tr>
<td>/var/run/*</td>
<td>各服务的程序的 PID 文件目录</td>
<td></td>
</tr>
</tbody>
</table>
<p>所以在启动后台程序的时候，可以使用 /etc/init.d/* 里面的脚本来完成 deamon 程序：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;syslog start</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;syslog restart</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;syslog stop</span><br></pre></td></tr></table></figure></p>
<p>这是启动的一个方法，还可以利用其他的方法来完成以上的功能，那就是 service 程序，service 本身
其实也是一个脚本，最后实际调用的还是 /etc/init.d/* 中的脚本。</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service syslog start</span><br><span class="line"></span><br><span class="line">service syslog restart</span><br><span class="line"></span><br><span class="line">service syslog stop</span><br></pre></td></tr></table></figure></p>
<h3>chkconfig 管理系统服务是否默认启动</h3>
<p>当我们的 deamon 程序的脚本加入到 /etc/init.d/ 中后，我们就可以通过 chkconfig 命令很好的将这些程序
管理起来，比如将一些 deamon 程序配置成开机启动。</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig  [--level [0123456]] [服务名称] [on|off]</span><br></pre></td></tr></table></figure></p>
<p>上面的命令就可以让某个服务在特定的运行等级下默认启动或者默认不启动。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Cas 系统简介</title>
    <url>/2018/12/09/Cas-%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3>CAS 系统</h3>
<h4>单点登录</h4>
<p>单点登录（SSO）的全称是 Single Sign On，是指在应用群中只需要登录一次就可以访问该应用群中所有应用的技术。Cas 是 SSO 的一种实现。</p>
<h4>CAS 基础架构</h4>
<blockquote>
<p>本文所讨论的 Cas 系统版本是 5.1.x</p>
</blockquote>
<h5>1. CAS 系统分为两部分：</h5>
<ul>
<li><strong>CAS server</strong>: 基于 Spring 框架构建，主要用于让通过认证的用户访问注册了的系统（CAS client）,认证用户的方式通过分发和验证票据（TGT）。</li>
<li><strong>CAS client</strong>：通常在 CAS server 上注册了应用系统。这些应用系统都可以通过 CAS server 支持的协议与 CAS server 进行通信。</li>
</ul>
<h5>2. CAS 支持的协议如下：</h5>
<ul>
<li>CAS 1, 2, 3</li>
<li>SAML 1.1, 2</li>
<li>OpenID Connect</li>
<li>OpenID</li>
<li>OAuth 2.0</li>
<li>WS Federation</li>
</ul>
<h5>3. CAS server 主要组成部分</h5>
<ul>
<li>Web(SpringMVC/SpringWebflow)</li>
<li>Ticketing</li>
<li>Authentication</li>
</ul>
<p><strong>Web</strong> 部分主要是与外部进行交互，包括登录页面或者登录的接口，<strong>Ticketing</strong> 部分主要用于票据的分发和验证，<strong>Authentication</strong> 部分主要用于登录的验证过程。在通过验证之后，用户就可以拿到 CAS server 分发的（TGT） 票据。用户拿到票据后，在访问其他的系统时不需要再次进行登录，只需要到 CAS server 验证票据即可。</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/cas_architecture.png" alt=""></p>
<h4>Cas 安装</h4>
<p>Cas 系统的安装分为两部分，一部分是 Cas Server 的安装，一部分是 Cas client 的安装。Cas Server 是一个独立的 Java Web 应用。而 Cas client 则支持不同的语言，可以嵌入到不同语言的应用中去。</p>
<p>官方提供的 Cas Server 是开箱即用的，如果没有需要定制的认证逻辑，基本可以使用官方包直接部署，官方称这种方式为 Overlay 部署方式。具体可以基于 Docker 部署和 Servlet 容器（Tomcat等）进行部署。</p>
<p>如果采用官方提供的包进行部署，只需要在配置文件里面修改一下数据库账号和密码就可以。</p>
<p>在部署了 Cas server 系统之后，还需要部署一个 cas-managment Web 应用，这个应用用来管理在 Cas server 中注册的应用。</p>
<h4>Web 端</h4>
<p>Cas Server 面向用户的模块采用了 Spring 框架，提供了 SpringMVC 和 SpringWebflow 两种选择。</p>
<h4>Cas 认证过程</h4>
<h5>Cas 1.0</h5>
<p>下面这张图展示了 Cas 系统的工作方式，首先，用户在首次访问系统群中的一个应用1时，会跳转到 Cas 系统的登录页面。在用户名和密码得到 Cas 系统的认证了之后，就会拿到 Cas 系统生成一个票据 TGT（Ticket Granting Ticket），然后就会跳转回应用1，应用1会去 Cas server 验证票据的有效性，如果有效就可以访问应用1了。</p>
<p>接下来如果用户关闭了应用1，在票据的有效期内再次访问了应用1，那么应用这时候只会验证 cookie， 而不需要再次验证票据了。</p>
<p>但是如果应用此时访问了应用群里的应用2，那么还是需要先跳转到 Cas server 验证票据，验证通过后才会跳转到应用2。</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/cas_flow_diagram.png" alt=""></p>
<h5>Cas 2.0</h5>
<p>以上的过程是标准的 Cas 认证过程，Cas 还支持通过代理的方式来实现的认证，也就是说，应用不需要直接和 Cas 系统进行通信，只需要和代理进行通信就行。但是产生的票据不是 TGT，在代理服务器上会产生一个 PGT（Proxy Granting Ticket）。在代理认证中，所有的应用不直接通过 Cas server 认证，而是与通过认证的代理应用进行交互。其他的认证的过程与直接通过 Cas server 基本没有差别，疼哦这种方式，可以完成非 Web 应用之间的单点登录。</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/cas_proxy_flow_diagram.jpg" alt=""></p>
<p>通过上面的认证过程，也就完成了单点登录。那么登出功能自然也是要在一个应用中退出之后，在所有其他的应用中也需要退出。在退出的过程中，实际就是将 SSO session（一般存储在redis中） 删除的过程。</p>
<h4>应用注册</h4>
<p>每一个嵌入 Cas client 的应用都称之为 service，在 service 接入到 Cas server 之前，都需要在系统中进行注册。需要通过 cas-managment 应用进行注册。</p>
<p>参考文献:</p>
<p>【1】<a href="https://apereo.github.io/cas/5.1.x/planning/Architecture.html" target="_blank" rel="noopener">Cas 5.1x 官方文档</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>cas</tag>
      </tags>
  </entry>
  <entry>
    <title>Disruptor为何这么快</title>
    <url>/2020/04/12/Disruptor%E4%B8%BA%E4%BD%95%E8%BF%99%E4%B9%88%E5%BF%AB/</url>
    <content><![CDATA[<p>Disruptor 是一个开源并且高效的<strong>生产者-消费者</strong>框架，很难直接解释这个框架是做什么的，但是可以把这个框架理解成 Java 中的 <code>BlockingQueue</code>。这样理解起来是不是轻松多了，这就是一个生产者-消费者队列，只不过它的性能要比 <code>BloockingQueue</code> 好很多，号称单机器可以有百万的 TPS。</p>
<h2>Disruptor 的特点</h2>
<p>Disruptor 有以下主要三个特点：</p>
<ul>
<li>事件多播</li>
<li>为事件提前分配内存</li>
<li>无锁操作</li>
</ul>
<p>一般我们在使用队列的时候，队列中的消息只会被一个<code>消费者</code>使用，但是在 Disruptor 中，同一个消息可以被多个消费者同时处理，多个消费者之间是并行的。</p>
<p>因为可能在同一时间，一份数据要在多个地方被用到，比如一个请求数据需要同时<strong>被存入日志</strong>、<strong>备份到远程机器</strong>、<strong>进行业务处理</strong>，如下图所示：</p>
<p><img src="disruptor.png" alt=""></p>
<p>如果是一条消息只能被一个消费者处理，那么上面说的三个处理逻辑就得线性的完成或者放到一个消费者中再异步进行处理。如果可以把这些操作拆成多个消费者来<strong>并行</strong>消费同一条消息，处理效率就会提高很多。</p>
<p>这样要确保一条消息在都被所有消费者处理之后才能开始处理下一条，不能出现消费者在同时处理不同的消息，所以需要类似 Java 中 CyclicBarrier 一样的工具来保证所有消费者能够同时处理下一个消息，Disruptor 中实现了 SequenceBarrier 来完成这个功能。</p>
<p>Disruptor 目标是应用于低延迟的环境中。在低延迟的系统中需要减少或者完全不进行内存分配，在 Java 中，就是要减少垃圾回收所带来的停顿时间。在 Disruptor 中，使用 RingBuffer 来达成这个目标，在 RingBuffer 中提前创建好对象，后续通过反复利用这些对象来避免垃圾回收，这个实现是线程安全的。</p>
<p>在 Disruptor 中，实现线程安全基本不使用锁，而是使用 CAS 等无锁机制来保证线程安全。</p>
<h2>核心概念</h2>
<p>在正式了解 Disruptor 之前，我们需要了解一些核心的概念，Disruptor 的代码并不复杂，基本是围绕这些核心概念来展开的。</p>
<ul>
<li>Producer: 数据的生产者，生产者本身与 Disruptor 无关，可以是任何生产数据的代码，甚至可以是一个 for 循环</li>
<li>Event: Producer 产生的数据，用户可以根据自己的需要自行进行定义</li>
<li>RingBuffer: 用来存储 Event 的数据结构，提前分配好内存，避免在程序运行的过程中创建对象</li>
<li>EventHandler: 消费者，由用户自己实现</li>
<li>Sequence: 用来标识 Disruptor 中的组件，多个组件之间的协同依靠它来实现</li>
<li>Sequencer: Disruptor 中的核心机制，实现了核心的并发算法，保证消息在生产者和消费之间正确的进行传递</li>
<li>SequenceBarrier: 用来保证所有的消费这能够同时处理新的消息</li>
<li>WaitStrategy: 消费者等待策略</li>
<li>EventProcessor: 将消息传递到消费者的具体实现</li>
</ul>
<p>上面的这些组件组成了 Disruptor，整个框架的代码量其实很少，应该不到 7000 行，而且代码很干净。代码基本没有使用继承，而是使用了<strong>面向接口编程</strong>以及<strong>组合</strong>，所以代码之间的耦合度很低。</p>
<p>RingBuffer 和 Sequencer 是其中最重要的两个组件，前者用于存储消息，后者控制消息有序的生产和消费。</p>
<h2>性能提升策略</h2>
<p>Disruptor 的核心目标就是提升消息的吞吐量，所以框架也是围绕这些目标来实现的，主要做了如下的事情：</p>
<ul>
<li>减少垃圾回收</li>
<li>让消息可以通过被多个消费者并行处理</li>
<li>使用无锁算法来实现并发</li>
<li>缓存行填充</li>
</ul>
<p>RingBuffer 是用来存储消息的容器，内部实现使用了一个数组：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object[] entries;</span><br></pre></td></tr></table></figure></p>
<p>在 Disruptor 启动之前，需要指定数据的大小以及，初始化这个数组：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(EventFactory&lt;E&gt; eventFactory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bufferSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        entries[BUFFER_PAD + i] = eventFactory.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数组在初始化之后就不再回收了，所有的消息会循环利用这些已经创建好的对象，所以这是一个<strong>循环数组</strong>，RingBuffer 的实现如下图所示：</p>
<p><img src="ringbuffer.png" alt=""></p>
<p>那么在对循环数组进行操作的时候，需要对生产者和消费者对数组的访问进行控制。一方面，因为 Disruptor 支持多个生产者和多个消费者，所以要保证线程安全，为了保证性能，并没有使用锁来保证线程安全（只有 BlockingWaitStrategy 使用了锁），在对 RingBuffer 的访问控制中，主要使用 CAS 来完成:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">long</span> sequence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) UNSAFE.getObject(entries, REF_ARRAY_BASE + ((sequence &amp; indexMask) &lt;&lt; REF_ELEMENT_SHIFT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一方面对于生产者和消费者的速度进行访问，生产者不能对未消费的消息进行写入，这样会造成消息的丢失，在 RingBuffer 中，没有使用 head 和 tail 指针进行控制，而是通过 Sequence 来进行控制，生产者写入数据的时候，会通过当前的序列号加上需要写入的数据量，与消费者的位置进行对比，看看是否有足够的空间进行写入。</p>
<p>在 RingBuffer 中，有这样一段代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBufferPad</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码就称之为缓存行填充，说到这个就需要了解 CPU 的缓存机制，因为内存的访问速度与 CPU 的速度相差太远，所以在 CPU 和内存之间还加上了 CPU 缓存，现在一般会加上 3 级，第一级和第二级是 CPU 核独享的，第三级缓存则是多个核之间共享。</p>
<p>在很多情况下，我们想把一些不会变化的值缓存到 CPU 缓存中，比如 Java 中的 final 变量，这样就可以最大化的利用 CPU 缓存的速度，但是 CPU 缓存有一个特点，缓存数据的时候会以 <strong>CPU 缓存行</strong>为单位，所以如果一个 final 变量的附近定义了会变化的变量，每次变量变化的时候，数据就会重新被写回到内存中，那么 final 变量同样也不会再缓存在 CPU 缓存中了，所以在缓存行的前后部分都需要填充，确保不会缓存到其他的数据：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBufferPad</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 填充缓存行的前部分</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBufferFields</span> <span class="keyword">extends</span> <span class="title">RingBufferPad</span></span>&#123; </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 下面需要被缓存到 CPU 缓存的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> indexMask; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] entries; </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> bufferSize;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Sequencer sequencer; </span><br><span class="line">    ...... </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBuffer</span> <span class="keyword">extends</span> <span class="title">RingBufferFields</span> <span class="keyword">implements</span> <span class="title">Cursored</span>, <span class="title">EventSequencer</span>, <span class="title">EventSink</span></span>&#123; </span><br><span class="line">    ...... </span><br><span class="line">    <span class="comment">// 填充缓存行的后部分</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7; </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样 RingBufferFields 的数据被加载到 CPU 缓存中之后，就不会再需要从内存中读取了。</p>
<p>Disruptor 通过各方面的措施来提升性能，这就是为什么这么快的原因。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java Disruptor</tag>
      </tags>
  </entry>
  <entry>
    <title>Disruptor如何搭配Log4j2</title>
    <url>/2020/04/17/Disruptor%E5%A6%82%E4%BD%95%E6%90%AD%E9%85%8DLog4j2/</url>
    <content><![CDATA[<p>日志对大型系统很重要，在排查系统问题的时候，主要依靠日志。</p>
<p>日志很重要，但又能不影响程序的性能，比如一个接口的响应时间本来是 50 ms，结果加了日志之后，变成了 100 ms，这肯定没办法接受。</p>
<p>让日志不影响系统性能的方式有以下的思路：</p>
<ul>
<li>减少日志量</li>
<li>不在日志中做字符串拼接，而使用占位符的方式来拼接日志</li>
<li>将日志记录的方式从同步变成异步</li>
</ul>
<p>减少日志量不是非常可行，在某些情况下，就是需要记录比较多的日志，而且这种方式需要依靠开发人员的自觉，很难完全控制。</p>
<p>不使用字符串拼接的方式比较好实现，现在主流的日志框架中都实现了使用占位符的方式来记录日志信息，这样能够节省大量拼接字符串的时间，这种方式好实现，这种方式已经成为日志记录中的标配。</p>
<p>而本文重点要说的是第三点，这种方式对性能的提升也是最大的，但不是所有的日志框架都支持，而 Log4j2 就支持，之前我写过一篇对 <a href="https://juejin.im/post/5dc62b6c51882506785746b2" target="_blank" rel="noopener">Log4j2 的简介</a>，可以点击查看。</p>
<h2>Log4j2 工作流程</h2>
<p>Log4j2 运行的流程如下所示：</p>
<p><img src="1.png" alt=""></p>
<p>Log4j2 主要由三个组件组成，Logger、Layout、Appender。</p>
<p>Logger 就是在程序中用来记录日志的对象：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger(Log4j2HelloWorld.class);</span><br></pre></td></tr></table></figure></p>
<p>Layout 则用来对日志信息进行格式化：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d %p %c&#123;1.&#125; [%t] %m%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
Appender 用来配置日志的展现形式，可以将日志在控制台打印，也可以将存储到文件，数据库，或者外部的消息队列等等。</p>
<p>默认情况下，一条日志信息需要被 Appender 处理完成之后才算是记录完成，在记录日志的过程中，程序不会往下执行，如果日志很大，就会对程序的性能造成影响，整个过程是同步的，所以优化的思路是把日志记录的过程变成异步，让日志记录不会影响程序的执行。</p>
<p>所以 Logger 在获取到日志信息之后，不会立马进行日志格式化和存储，会先把日志信息放到一个队列中，如下图所示：</p>
<p><img src="2.png" alt=""></p>
<p>因为系统中日志产生的速度非常快，所以要求这个队列的性能很好，如果日志的处理跟不上日志的产生速度，那么就会造成日志的信息的丢失，这也是我们不希望看到的。</p>
<h2>Disruptor 对 Log4j2 的改造</h2>
<p>Disruptor 有着非常好的性能，刚好满足上面我们所提到的要求，在 Log4j2 中加上 Disruptor 之后，我们的日志处理流程就变成了下面这样：</p>
<p><img src="3.png" alt=""></p>
<p>比较有意思的是，Log4j2 中只在 Logger 这块使用了 Disruptor，按照上面的思路，其实 Appender 也可以进行异步处理，Log4j2 也确实提供了异步的方式，但是是使用 <code>ArrayBlockingQueue</code>，而没有使用 Disruptor， 而且官方也不推荐使用异步 Appender。</p>
<p>我理解为既然要进行异步，那么就彻底一点，就应该把日志的所有处理都异步进行处理，如果使用异步 Appender，日志的格式化还是要进行同步处理。</p>
<p>回到正题，Disruptor 是如何在 Log4j2 中使用的呢？</p>
<p>在 Log4j2 中，有一个 <code>AsyncLogger</code>，这个类完成了对 Disruptor 的包装，类结构如下：</p>
<p><img src="4.png" alt=""></p>
<p>AsyncLogger 中调用了 AsyncLoggerDisruptor，这个类才真正了完成异步日志处理。</p>
<p>一个 Disruptor 官方 Demo 如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LongEventFactory factory = <span class="keyword">new</span> LongEventFactory();</span><br><span class="line"><span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;LongEvent&gt;(factory, bufferSize, DaemonThreadFactory.INSTANCE);</span><br><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> LongEventHandler());</span><br><span class="line">disruptor.start();</span><br><span class="line"></span><br><span class="line">RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">LongEventProducerWithTranslator producer = <span class="keyword">new</span> LongEventProducerWithTranslator(ringBuffer);</span><br><span class="line"></span><br><span class="line">ByteBuffer bb = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> l = <span class="number">0</span>; <span class="keyword">true</span>; l++) &#123;</span><br><span class="line">    bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">    producer.onData(bb);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是官方的一个例子，从上面可以发现，使用 Disruptor 时，需要以下这些组件：</p>
<ul>
<li>Factory: 用户创建消息对象</li>
<li>Disruptor 对象: disruptor 启动之后会以一个独立的线程在后台运行</li>
<li>Rinbuffer: 很明显，用来作为消息队列</li>
<li>Producer: 生产者，用来生产消息</li>
<li>EventHandler: 消费者，处理消息</li>
</ul>
<p>同样，在 Log4j2 中，也是同样的使用方式，AsyncLoggerDisruptor 中有一个 start 方法，在这个方法中，同样也是完成了对这些组件的初始化：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(RingBufferLogEvent.FACTORY, ringBufferSize, threadFactory, ProducerType.MULTI, waitStrategy);</span><br></pre></td></tr></table></figure>
生成对象的工厂使用的是 <code>RingBufferLogEvent.FACTORY</code>，这是 RingBufferLogEvent 中的工厂单例，主要用来生成日志对象实例。</p>
<p><code>RingBufferLogEventHandler</code> 是日志的消费者，用来处理日志信息，这里的实现很有意思，在 Handler 中，还是调用了 RingBufferLogEvent 的 execute 方法来进行日志的处理，而实际日志会被怎么处理，还是要看具体的配置，这在程序运行的时候才能决定。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">final</span> RingBufferLogEvent event, <span class="keyword">final</span> <span class="keyword">long</span> sequence,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        event.execute(endOfBatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用过日志就知道，日志有很多的重载方法，这是为了应对更多的场景，所以对应 Disruptor 中的生产者也有很多的实现，生产者都在 <code>AsyncLogger</code> 中实现，</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TranslatorType threadLocalTranslatorType = <span class="keyword">new</span> TranslatorType() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(String fqcn, StackTraceElement location, Level level, Marker marker, Message message,</span></span></span><br><span class="line"><span class="function"><span class="params">        Throwable thrown)</span> </span>&#123;</span><br><span class="line">        logWithThreadLocalTranslator(fqcn, location, level, marker, message, thrown);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(String fqcn, Level level, Marker marker, Message message, Throwable thrown)</span> </span>&#123;</span><br><span class="line">        logWithThreadLocalTranslator(fqcn, level, marker, message, thrown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码就是生产者的一种实现。</p>
<p>其实 Log4j2 中使用 Disruptor 也没有什么特别的地方，但是却把同步记录日志的机制换成了高性能的异步记录方式。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Modules 常见使用陷阱</title>
    <url>/2021/03/27/Go-Modules-%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<p>Go Modules 是 Go 官方推出的依赖管理工具，Go Modules 的使用可以参见我之前翻译的<a href="https://">官方博客</a>。</p>
<p>Go Modules 在使用的过程中还是会有一些坑，这篇文章将会介绍一些我踩过的坑。</p>
<h2>1. Go mod 命令详解</h2>
<p>在 Go 中，提供了 <code>go mod</code> 命令来使用 Go Modules，可以通过 <code>go help mod</code> 来查看支持的命令：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">help</span> mod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方式</span></span><br><span class="line">go mod &lt;<span class="built_in">command</span>&gt; [arguments]</span><br><span class="line"></span><br><span class="line"><span class="comment"># commands</span></span><br><span class="line">download <span class="comment"># 将远程的包下载到本地缓存中</span></span><br><span class="line">edit     <span class="comment"># 编辑 go.mod 文件，其实使用编辑器编辑会更方便</span></span><br><span class="line">graph    <span class="comment"># 查看所有依赖的关系</span></span><br><span class="line">init     <span class="comment"># 用来创建一个使用 Go Modules 的项目</span></span><br><span class="line">tidy     <span class="comment"># 添加缺失的包，以及移除不再使用的包</span></span><br><span class="line">vendor   <span class="comment"># 将依赖的包拷贝到项目的 vendor 目录下</span></span><br><span class="line">verify   <span class="comment"># 验证依赖包与预期的一致</span></span><br><span class="line">why      <span class="comment"># 解释为什么需要这个包</span></span><br></pre></td></tr></table></figure></p>
<p>go mod download 会将依赖缓存到本地，缓存的目录是 <code>$GOPATH/pkg/mod/cache</code>，这些被缓存的依赖可以被多个项目使用。</p>
<p>go mod graph 可以用来查看项目的依赖，但看起来不是很直观，希望后续能够继续改进。</p>
<p>go mod init 和 go mod tidy 最常用，分别用来初始化一个 Go Modules 以及添加和删除无用的依赖。</p>
<p>go mod vendor 可以将项目的依赖打包放到当前项目的根目录下，这样可以防止项目的依赖被修改。</p>
<p>go mod verify 和 go mod why 相对来说用的就比较少。</p>
<h2>2. 如何获取新的依赖</h2>
<p>在使用了 Go Modules 以后，go get 依然是获取依赖常用的方法。</p>
<p>使用也很简单:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/rayjun/go-mod-demo</span><br></pre></td></tr></table></figure></p>
<p>这样会直接去拉取 go-mod-demo 的最新 tag，如果没有 tag，就会去拉取最新一次 commit。</p>
<p>也可以直接去拉取某个指定的分支，下面的命令会拉取分支 v1.0.1 的代码：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/rayjun/go-mod-demo@v1.0.1</span><br></pre></td></tr></table></figure></p>
<p>如果 tag 和分支同名时，会优先去拉取 tag 下的代码，一般情况下，不要让 tag 和分支同名，而且同名会导致推送代码到分支失败。</p>
<p>在一些情况下，我们可以需要删除 tag 名，更新代码后再使用这个相同的 tag 名，这样就会导致之前已经下载了这些代码的人无法获取到最新的代码，所以需要先清空本地的缓存，然后再重新下载依赖：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go clean --modcache <span class="comment"># 将本地缓存的所有依赖都清空</span></span><br><span class="line">go get -u github.com/rayjun/go-mod-demo@v1.0.1 <span class="comment"># 获取最新的代码</span></span><br></pre></td></tr></table></figure></p>
<h2>3. Go Modules 中的版本号</h2>
<p>Go Modules 使用的是<a href="https://semver.org/" target="_blank" rel="noopener">语义版本号</a>来实现对代码版本的管理，语义版本号由三个部分组成:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MAJOR.MINOR.PATCH <span class="comment"># 主版本号.次版本号.补丁版本号</span></span><br></pre></td></tr></table></figure></p>
<p>在一些情况下，还可以配置 alpha 等来表示一些先行版本:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">v1.0.2-alpha.1</span><br></pre></td></tr></table></figure></p>
<p>每个 Go Modules 都应该使用这样的版本号来管理代码。如果出现了 v1.0.2.1 这样的版本号，Go Modules 就无法识别：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/rayjun/go-mod-demo@v1.0.2.1</span><br></pre></td></tr></table></figure></p>
<p>实际在 go.mod 中显示的版本号是这样的:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">github.com/rayjun/go-mod-demo v1.0.3-0.20210327072248-86af6328b20f</span><br></pre></td></tr></table></figure></p>
<p>对于一个良好的 Go Modules，应该使用 master 分支 + 多 tag 的形式来管理代码，意思就是 master 保持最新的代码，然后每一个已经发布的代码使用 tag 的形式发布出来。tag 的版本号应该符合语义版本号的规则。</p>
<p>文/Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简明教程</title>
    <url>/2019/01/12/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>Git</strong> 是当前用的最多，最好用（应该没有争议吧？！）的分布式版本控制系统。git 的底层数据原理很复杂，但是上手 Git 却很简单。Git 不需要网就能够 <strong>commit</strong>(提交)，这一点与 <strong>SVN</strong> 有着很大的差别，SVN 需要一个远程服务器，所有的 commit 都会直接到远程服务器，而 Git 则不需要， Git 可以有无数个远程服务器，也可以一个都不需要, Git 太棒了，使用了 Git 后，你再也不会想使用其他的版本管理工具。</p>
<p>其实不仅仅只是代码需要版本管理，文档，写作，知识库等等需要多人协作或者个人多次操作的工作都需要版本管理。</p>
<p>下面的内容不会涉及到任何 Git 原理性的东西，只会介绍 Git 的基本概念以及版本管理需要用到的常用命令。Git 的命令很多，加上每个命令有不同的参数，所以 Git 会让人感觉很难学，所以下面的内容会首先介绍最常用的命令，然后再介绍 Git 的一些高级用法。</p>
<blockquote>
<p>由于不把 Git 的应用场景仅限于写代码，那我们就把需要版本管理的过程称之为创作。</p>
</blockquote>
<blockquote>
<p>注意：这篇文章用于学习基础的 Git 操作，不能帮助你成为一个 Git 专家</p>
</blockquote>
<h3>创作的四个阶段</h3>
<ul>
<li>思路整理</li>
<li>内容创作</li>
<li>里程碑</li>
<li>优化更新</li>
</ul>
<p>创作的过程可以映射到 Git 的四个阶段中：</p>
<ul>
<li>项目初始化</li>
<li>内容的 commit/push 与分支管理</li>
<li>Git 标签管理</li>
<li>迭代</li>
</ul>
<p>在开始一项创作之前，我们需要初始化一个 Git 项目来存放创作的相关文件，然后在项目里进行内容创作，每完成一部分内容就需要进行 commit 和 push。在完成一个阶段性的目标后，就需要打上一个版本号，宣告一个里程碑的诞生。然后在这个基础之上进行再次的创作和标签化。</p>
<h3>Git 初级用法</h3>
<h4>Git 专用名词</h4>
<ul>
<li>工作区</li>
<li>暂存区</li>
<li>本地仓库</li>
<li>远程仓库</li>
</ul>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/git/git.png" alt=""></p>
<p>其实本地工作区、暂存区和本地仓库只是逻辑上的区分，对于 Git 的使用者来说基本是无感的，也就是说你记不住上面几个术语也不会影响使用。</p>
<h4>Git 项目初始化</h4>
<p>项目的初始化分为两种情况，一种是<strong>重头开始创建一个新项目</strong>，二是<strong>从远程服务器获取一个现有的项目</strong>。</p>
<h5>新建项目</h5>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir project-name &amp;&amp; <span class="built_in">cd</span> project-name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure>
或者</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init project-name</span></span><br></pre></td></tr></table></figure></p>
<h5>拉取现有项目</h5>
<p>可以直接从远程仓库拉取一个项目到本地进行协作，url 就是远程仓库的项目地址。</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> url</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>当前 Git 使用的最多的远程协议是 https 和 ssh，使用 https 时需要手动输入远程服务器的账号和密码，相对比较麻烦，而使用 ssh 使用起来则更加方便一些。</p>
</blockquote>
<h5>Git 配置</h5>
<p>Git 的配置分为<strong>当前项目配置</strong> 和<strong>全局配置</strong>，Git 会优先使用当前项目的配置，当前项目缺少的配置会使用全局的配置。</p>
<p>使用以下的命令查看和修改当前 Git 的配置：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --list</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改配置，加上 --global 表示修改全局的配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config -e [--global]</span></span><br></pre></td></tr></table></figure>
有 <strong>user.name</strong> 和 <strong>user.email</strong> 的配置需要单独说明，如果在项目中没有这两个配置，那么就会使用全局的配置，如果全局也没有，那就必须要配置，否则不能够进行提交。</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置 user.name 和 user.email，不加 --global 表示当前项目配置，加上 --global 表示全局配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.name <span class="string">"ray"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.email <span class="string">"ray@gmail.com"</span></span></span><br></pre></td></tr></table></figure>
到这里，Git 项目的初始化就完成了。</p>
<h4>内容的 commit/push 与分支管理</h4>
<h5>Git 的基本工作流</h5>
<p>在创建了一个 Git 的项目之后，就可以在这个 Git 项目内进行创作了。</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加文件，可以向 Git 项目中添加任何文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch reade.md</span></span><br></pre></td></tr></table></figure>
在添加完文件后，这些文件还没有纳入到版本管理中，需要使用 以下的命令将新添加的文件纳入到<strong>暂存区</strong>中：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加单个文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add file-name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加 整个项目中的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看文件变动状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure>
然后需要将新增加的文件提交本地仓库：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">'Message'</span></span></span><br></pre></td></tr></table></figure>
执行完这条命令后，就表示新增加的内容已经提交到本地的仓库了。如果这是一个多人协作的项目，那就还需要将这些新的内容提交到远程仓库。</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果当前项目还没有远程分支，那就需要添加一个, origin 是远程分支的名称，这个名称可以随意起</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin url</span></span><br></pre></td></tr></table></figure>
提交内容到远程仓库（这里涉及到一个分支的概念，下面马上讲到）:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure></p>
<h5>Git 分支管理</h5>
<p>分支是 Git 的一个很重要的特性。在使用 <strong>git init</strong>进行项目初始化时，Git 会默认创建一个 <strong>master</strong> 分支。为什么 Git 需要多个不同的分支呢？设想一个场景，你用 Git 作为版本管理创作了一本书，这本书是基于 master 分支进行创作的。你已经完成了这本书的第一个版本并且对外发布了，然后你开始准备写这本书的第二个版本，如果你还继续在 master 分支上进行修改的话，那么就会影响到当前正在读这本书的读者，这个时候分支就能很好的解决这个问题。</p>
<p>只需要创建一个新的分支，然后新的工作在新分支上进行，而且不会影响原来分支上的内容，而且在新分支上的工作完成后，还可以直接将新的内容合并回原来的分支。</p>
<p>分支的新建:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash"> 新建一个分支</span></span><br><span class="line"><span class="meta"> $</span><span class="bash"> git branch branch-name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支并且切换到新的分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b branch-name</span></span><br></pre></td></tr></table></figure>
分支基本操作:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看本地和远程的所有分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout branch-name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d branch-name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete branch-name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr remote/branch-name</span></span><br></pre></td></tr></table></figure>
上面这些操作就是分支的基本操作了，学会了这些操作，就可以很方便的管理自己的创作状态，并且彼此不会相互影响。但是还有一个问题没有解决，那就是如果想把两个分支的内容合并到一起该怎么操作，很简单，如下:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把其他分支的内容合并到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge branch-name</span></span><br></pre></td></tr></table></figure></p>
<h4>Git 标签管理</h4>
<p>在经过了很多次的 commit 和 push 后，你觉得创作的差不多了，是时候发布这些内容了。为了让这次发布的内容可以在以后很方便的找到，那就需要在当前这个点上打上一个标签，Git 会维护一个 标签列表，打过的标签都可以轻易的找到。</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag tag-name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前的所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag - d tag-name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin tag-name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete tag-name</span></span><br></pre></td></tr></table></figure>
学会了这些命令后，就可以轻松的操作 git 的标签了。</p>
<h4>迭代</h4>
<p>Git 的命令的数量很大，每个命令又可以有很多的参数，所以不太可能记住所有的参数。
所以学习 Git 最好的方式就是用，先从基本的命令开始，在使用的创作中将 Git 使用起来，然后再进一步去探究 Git 内部的原理。</p>
<p>上面介绍的命令基本已经够日常的使用了，你可以用这些工具去帮助你不断的优化自己的创作。当你可以把这些命令练成自己的本能反应时，你会对 Git 的高阶用法和内部原理感兴趣的。</p>
<p>（完）</p>
<ul>
<li>https://github.com/progit</li>
<li>http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 高阶教程</title>
    <url>/2019/02/17/Git-%E9%AB%98%E9%98%B6%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>在之前的两篇文章中，详细介绍了 Git 的入门和 Git 的底层数据结构。在掌握了 Git 的基本命令后，基本就可以使用 Git 进行版本管理了。</p>
<p>当然，如果你需要将 Git 使用的更强大以及更有效率。那么你就需要这篇文章。</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/git/git-flow.png" alt=""></p>
<p>上图是 Git 的关键流程流转图，本文内容按照 Git 的关键流程进行。</p>
<h3>本地操作</h3>
<p>在将修改的内容提交到远程仓库之前，我们所有的操作都在暂存区、工作区以及本地仓库之中进行。</p>
<p>首先我们先来理解一下分支和 HEAD。HEAD 通常执行<strong>当前分支</strong>的最后一次提交。也就是说 HEAD 指向<strong>本地仓库</strong>的<strong>最新提交</strong>。</p>
<p><strong>比较工作区和暂存区的文件差异</strong>：</p>
<p>比较所有文件:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure>
比较单个文件:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff -- filename</span></span><br></pre></td></tr></table></figure></p>
<p><strong>比较暂存区和 HEAD 的文件差异</strong>：</p>
<p>比较所有文件：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br></pre></td></tr></table></figure>
或者</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --staged</span></span><br></pre></td></tr></table></figure>
比较单个文件:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached -- filename</span></span><br></pre></td></tr></table></figure></p>
<p><strong>让暂存区恢复成与 HEAD 一样</strong></p>
<p>恢复所有文件:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD</span></span><br></pre></td></tr></table></figure>
恢复部分文件:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD -- filenames</span></span><br></pre></td></tr></table></figure></p>
<p><strong>让工作区的文件恢复为暂存区一样</strong></p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">   git checkout -- filename</span></span><br></pre></td></tr></table></figure></p>
<p><strong>缓存暂存区和工作区的内容</strong></p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br></pre></td></tr></table></figure>
恢复并且保留缓存</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash apply</span></span><br></pre></td></tr></table></figure>
恢复并且删除缓存</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure></p>
<p><strong>隔离不需要纳入到版本管理的文件</strong></p>
<p>通过创建 .gitignore 文件，该文件中存储不需要纳入到版本管理的文件名称，可以使用正则表达式。</p>
<p><strong>从 HEAD 中删除文件</strong></p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm filename</span></span><br></pre></td></tr></table></figure></p>
<p><strong>查看不同 commit 的指定文件的差异</strong></p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff commit1 commit2  -- filename</span></span><br></pre></td></tr></table></figure></p>
<p><strong>查看不同分支的指定文件的差异</strong></p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff branch1 branch2 -- filename</span></span><br></pre></td></tr></table></figure></p>
<p><strong>修改最新的 commit 的 message</strong></p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure>
<strong>修改旧的 commit 的 message</strong></p>
<p>parentCommitId 是指要修改的 commit 的上一次 commit的哈希值。</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase -i parantCommitId</span></span><br></pre></td></tr></table></figure>
进入交互式界面后修改 pick 为 reward，然后修改 commit 的 message。</p>
<p><strong>合并连续的 commit</strong></p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase -i parantCommitId</span></span><br></pre></td></tr></table></figure>
进入交互式界面后把需要合并的commit 的 pick 修改为 squash，然后合并 commit。</p>
<p>**删除最近几次 commit **</p>
<p>强制回到某一次 commit，该 commit 之后的 commit 会小时，commitId 为该commit 的哈希值。
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard  commitId</span></span><br></pre></td></tr></table></figure></p>
<p><strong>查看 Git 的提交历史</strong></p>
<p>查看所有的提交历史:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure>
下面的命令表示查看最近的三次提交:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -n3</span></span><br></pre></td></tr></table></figure>
所有的 commit 只展示一行数据:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --oneline</span></span><br></pre></td></tr></table></figure>
图形化展示提交记录:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph</span></span><br></pre></td></tr></table></figure></p>
<p>上述的命令都可以组合使用。</p>
<h3>多人协作环境</h3>
<p><strong>不同的人修改了相同文件的不同区域或者不同的文件</strong>:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge otherBranch</span></span><br></pre></td></tr></table></figure></p>
<p><strong>不同的人修改了相同文件的相同区域</strong></p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure>
然后进行手动解决冲突。解决冲突后提交修改</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -am<span class="string">"Resolved conflict"</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>变更了文件名，并且其他人基于文件做出了修改</strong></p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure></p>
<p><strong>不同的人修改同一文件的文件名</strong></p>
<p>手动处理，选择其中一个文件名，然后解决冲突，提交。</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -am<span class="string">"Resolved conflict"</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>集成分支</strong></p>
<p>禁止向集成分支进行 git push -f
集成分支不能进行 git rebase 操作（修改历史）</p>
<p>(完)</p>
<p><strong>参考文献:</strong></p>
<ol>
<li>https://github.com/progit/progit2</li>
<li>https://git-scm.com/docs</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Go http 包详解</title>
    <url>/2021/08/30/Go-http-%E5%8C%85%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Go 语言中的 http 包提供了创建 http 服务或者访问 http 服务所需要的能力，不需要额外的依赖。在这篇文章中，我们会介绍这些功能的使用，以及看一下 http 包的设计思路。</p>
<h2>1. http 的客户端</h2>
<h3>1.1 发送普通请求</h3>
<p>在 Go 语言中发送请求很简单，如果不需要额外的配置，可以直接使用 http 包封装的 http Client 发送请求，比如发送 GET 请求：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, _ := http.Get(<span class="string">"https://golang.org"</span>)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure></p>
<p>发送 POST ，并携带 JSON 数据的请求：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">dataJson, _ := json.Marshal(data)</span><br><span class="line">reader := bytes.NewBuffer(dataJson)</span><br><span class="line"></span><br><span class="line">resp, _ := http.Post(<span class="string">"https://golang.org"</span>, <span class="string">"application/json;charset=utf-8"</span>, reader)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure></p>
<p>发送 POST 表单请求：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, _ := http.PostForm(<span class="string">"https://golang.org"</span>, url.Values&#123;<span class="string">"username"</span>:&#123;<span class="string">"rayjun"</span>&#125;, <span class="string">"password"</span>:&#123;<span class="string">"password"</span>&#125;&#125;)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure></p>
<p><strong>在每个请求发完之后，需要手动关闭响应。</strong></p>
<h3>1.2 客户端配置</h3>
<p>在实际使用的过程中，我们通常不会直接上面的方法，而是会自己做一些 Client 的配置，比如调整超时时间：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">	Timeout: <span class="number">5</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line">resp, _ := client.Get(<span class="string">"https://golang.org"</span>)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure></p>
<p>另外在很多时候，我们需要使用 GET 和 POST 之外的 http 方法，那就需要下面这样的配置：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">	Timeout: <span class="number">5</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req, _ := http.NewRequest(<span class="string">"PUT"</span>, <span class="string">"https://golang.org"</span>, <span class="literal">nil</span>)</span><br><span class="line">resp, _ := client.Do(req)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure></p>
<p>比如还需要在请求的 Header 中增加一些字段：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">	Timeout: <span class="number">5</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line">req, _ := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"https://golang.org"</span>, <span class="literal">nil</span>)</span><br><span class="line">req.Header.Add(<span class="string">"User-Id"</span>, <span class="string">"userid123456"</span>)</span><br><span class="line">resp, _ := client.Do(req)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure></p>
<p>或者更进一步，我们需要自定义<strong>传输层</strong>的一些配置：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tr := &amp;http.Transport&#123;</span><br><span class="line">	MaxIdleConns:       <span class="number">10</span>,</span><br><span class="line">	IdleConnTimeout:    <span class="number">30</span> * time.Second,</span><br><span class="line">	DisableCompression: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">resp, _ := client.Get(<span class="string">"https://golang.org"</span>)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure></p>
<p>http 包中发送请求，提供了不同层次的配置，满足不同场景的使用。</p>
<h2>2. http 的服务端</h2>
<p>除了客户端，使用 http 包来创建 http 服务也很方便。</p>
<h3>2.1 一行代码创建 http 服务</h3>
<p>创建一个 http 服务，在 Go 代码中，只需要一行代码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 main 方法中，写下上面那行代码，然后运行 main 方法，端口号为 8080 的 http 服务就运行起来了， 但目前还处理不了任何请求。</p>
<h3>2.2 添加请求路径</h3>
<p>在上面代码的基础上，需要添加一个路径，这样服务才可以开始处理请求：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.Handle(<span class="string">"/index"</span>, &amp;CustomerHandler&#123;&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomerHandler <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomerHandler)</span> <span class="title">ServeHTTP</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"implement http server by self"</span>)</span><br><span class="line">	writer.Write([]<span class="keyword">byte</span>(<span class="string">"server echo"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加了 <code>/index</code> 路径，在这种方式下，需要为每一个请求都定义一个 Handler，然后 Handler 需要实现 ServeHttp 方法。</p>
<p>Handler 是一个请求处理器，我们如果使用这种方式，就需要为每一个请求的 url 实现一个 Handler，这样实现很繁琐。</p>
<p>但我们还有另一个选择，就是使用 HandlerFunc，添加另外一个路径：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">		writer.Write([]<span class="keyword">byte</span>(<span class="string">"HandleFunc implement"</span>))</span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用这种方式很简洁，值需要实现 HandlerFunc 类型的一个匿名方法就可以了，HandlerFunc 是一个适配器，可以让我们把一个与 ServeHTTP 签名相同的函数作为一个处理器。</p>
<p>Handler 和 HandlerFunc 都是通过 DefaultServeMux 来实现的。 DefaultServeMux 才是上面服务的核心。</p>
<p>在上面的代码，http.ListenAndServe 的第二个参数传入的是 nil，通常情况下，这个参数都是 nil，跟进代码，发现这个参数为 nil 的时候，就是使用 DefaultServeMux 来作为服务端的实现：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">	handler := sh.srv.Handler</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = DefaultServeMux</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">		handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DefaultServeMux 的类型是 ServeMux，这是 Go 语言原生包中 http 服务端的默认实现。ServeMux 同样实现了ServeHttp 这个方法。</p>
<p>ServeHttp 方法才是整个 http 服务的核心，只要需要处理请求，就必须实现这个方法。Handler 和 HandlerFunc 只是 Go 语言提供的两种实现。</p>
<h2>3. http 的反向代理</h2>
<p>反向代理在开发 Web 应用，特别是开发网关类应用的时候会经常用到， Go 也提供了实现，基本上开箱即用。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/formawd"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">		director := <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request)</span></span> &#123;</span><br><span class="line">			req.URL.Scheme = <span class="string">"https"</span></span><br><span class="line">			req.URL.Host = <span class="string">"golang.org"</span></span><br><span class="line">			req.URL.Path = <span class="string">"upload"</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		proxy := &amp;httputil.ReverseProxy&#123;Director: director&#125;</span><br><span class="line">		proxy.ServeHTTP(writer, request)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码会把所有的请求都转发到一个地方，当然也可以通过配置，将请求转发到不同的地方。</p>
<h2>4. 小结</h2>
<p>Go 语言原生的包就自带了 http 包，这个包提供 http 编程所需要的基础能力，开箱即用，不需要额外的依赖。在实际项目中使用，做个简单的封装即可。而且还自带反向代理的能力，可以很方便的写出一个 API 网关。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go error的四种处理方式</title>
    <url>/2021/12/05/Go-error%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>Go 的 error 处理一直是被人诟病的地方，但换个角度其实 Go 的 error 还是挺好用的，error 有两个很重要的特性：</p>
<ul>
<li>error 就是一个普通的值，处理起来没有额外的开销</li>
<li>error 的扩展性很不错，可以按照不同的场景来自定义错误</li>
</ul>
<p>而且在 Go1.13 之后，在 errors 包中提供了一些函数，让错误的处理和追踪更加方便一些。这篇文章会结合 errors 中函数，来讨论一下  Go 中常见的 error 使用方式。</p>
<p>需要注意，这里说的 errors 包是指 Go 中的原生 errors 包，而不是 <a href="https://github.com/pkg/errors" target="_blank" rel="noopener">https://github.com/pkg/errors</a>，后者是对原生 errors 的一些封装，使用起来会更加方便。</p>
<h2>1. 原生 error</h2>
<p>在 Go 的错误处理中，下面的代码占绝大多数：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在满足业务需求的情况下，这种错误处理其实是最推荐的方式，这种直接透传的方式让代码之间的耦合度更低。在很多情况下，如果不关心错误中的具体信息，使用这种方式就可以了。</p>
<h2>2. 提前定义好 error</h2>
<p>原生的 error 在有些情况下使用起来就不是很方便，比如我需要获得具体的错误信息，如果还用上面的方式来使用 error，可能会出现下面的代码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() == <span class="string">"invalid param"</span> &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写过代码的都知道上面的代码很不优雅，一方面，使用了魔法值，另外如果错误的信息变化之后，这里的代码逻辑就会出错。</p>
<p>可以通过把错误定义成一个变量：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrInvalidParam = errors.New(<span class="string">"invalid param"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>那么上面的代码就可以变成这样：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err == ErrInvalidParam &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果一次性需要处理的错误比较多，还可以使用 switch 进行处理：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> err &#123;</span><br><span class="line">		<span class="keyword">case</span> ErrInvalidParam:</span><br><span class="line">			<span class="comment">//..</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> ErrNetWork:</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> ErrFileNotExist:</span><br><span class="line">			<span class="comment">//..</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这种方式还不完美，因为 error 在传递的过程中，有可能会被包装，以携带更多的堆栈信息，比如下面这样：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 在包装错误的时候，这里格式化错误要使用 %w</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"add error info: %+v, origin error: %w"</span>, <span class="string">"other info"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设上面被包装的错误是 ErrInvalidParam，那么在调用的地方判断错误，就不能使用下面的代码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err == ErrInvalidParam &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了解决这个问题， <a href="http://errors.Is" target="_blank" rel="noopener">errors.Is</a> 函数可以判断被包装的 error 中是否有预期的 error:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> errors.Is(err, ErrInvalidParam) &#123;</span><br><span class="line">		<span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽量使用 <a href="http://errors.Is" target="_blank" rel="noopener">errors.Is</a> 来替代对 error 的比较。</p>
<h2>3. 使用自定义的错误类型</h2>
<p>上面的 error 使用方式在某些情况下还是不能满足要求。假如对于上面的无效参数 error，业务方想要知道具体是哪个参数无效，直接定义的错误就无法满足要求。</p>
<p>error 本质是一个接口，也就是是说，只要实现了 Error 方法，就是一个 error 类型：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么就可以自定义一种错误类型：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ErrInvalidParam <span class="keyword">struct</span> &#123;</span><br><span class="line">    ParamName  <span class="keyword">string</span></span><br><span class="line">    ParamValue <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ErrInvalidParam)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"invalid param: %+v, value: %+v"</span>, e.ParamName, e.ParamValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就可以使用<strong>类型断言机制</strong>或者<strong>类型选择机制</strong>，来对不同类型的错误进行处理：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e, ok := err.(*ErrInvalidParam)</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; e != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样可以在 switch 中使用：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *ErrInvalidParam:</span><br><span class="line">		<span class="comment">//..</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里 error 同样会存在被包装的问题，而 <a href="http://errors.As" target="_blank" rel="noopener">errors.As</a> 刚好可以用来解决这个问题，可以判断出被包装的错误中是否存在某个 error 类型：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e *ErrInvalidParam</span><br><span class="line"><span class="keyword">if</span> errors.As(err, &amp;e) &#123;</span><br><span class="line">	<span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>4. 更灵活的 error 类型</h2>
<p>上面的方式已经可以解决大部分场景的 error 处理了，但是在一些复杂的情况下，可能需要从错误中获取更多的信息，还包含一定的逻辑处理。</p>
<p>在 Go 的 net 包中，有这样的一个接口：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">    error</span><br><span class="line">    Timeout() <span class="keyword">bool</span>  </span><br><span class="line">    Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个接口中，有两个方法，这两个方法会对这个错误类型进行处理，判断是超时错误还是临时错误，实现了这个接口的 error 要实现这两个 方法，实现具体的判断逻辑。</p>
<p>在处理具体 error 时，会调用相应的方法来判断：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123; </span><br><span class="line">     <span class="comment">// 对临时错误进行处理 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Timeout() &#123; </span><br><span class="line">     <span class="comment">// 对超时错误进行处理 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种类型的 error 相对来说，使用的会比较少，一般情况下，尽量不要使用这么复杂的处理方式。</p>
<h2>5. errors 中的其他能力</h2>
<p>在 errors 包中，除了上面提到的 <a href="http://errors.Is" target="_blank" rel="noopener">errors.Is</a> 和 <a href="http://errors.As" target="_blank" rel="noopener">errors.As</a> 两个很有用的函数之外，还有一个比较实用的函数 errors.Unwrap。这个函数可以从包装的错误中将原错误解析出来。</p>
<p>可以使用 fmt.Errorf 来包装 error，需要使用 %w 的格式化：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"add error info: %+v, origin error: %w"</span>, <span class="string">"other info"</span>, err)</span><br></pre></td></tr></table></figure></p>
<p>在后续的 error 处理时，可以调用 errors.Unwrap 函数来获得被包装前的 error:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = errors.Unwrap(err)</span><br><span class="line">fmt.Printf(<span class="string">"origin error: %+v\n"</span>, err)</span><br></pre></td></tr></table></figure></p>
<p>文 / Rayjun</p>
<p>[1] <a href="https://go.dev/blog/errors-are-values" target="_blank" rel="noopener">https://go.dev/blog/errors-are-values</a></p>
<p>[2] <a href="https://go.dev/blog/go1.13-errors" target="_blank" rel="noopener">https://go.dev/blog/go1.13-errors</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Gas 机制是如何运作的</title>
    <url>/2021/10/17/Gas-%E6%9C%BA%E5%88%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<p>以太坊是目前第二大公链，它和比特币不一样，以太坊上的可以实现的功能更多，如果比特币是一个可以进行加减乘除的计算器，那么以太坊就是一台功能完备的计算机。以太坊系统的复杂度超过比特币好几个数量级。</p>
<p>在以太坊中，用户可以自己写一个智能合约，然后把智能合约放到以太坊中执行。智能合约的执行需要消耗资源，而以太坊上的资源是有限的。</p>
<p>在计算机系统中，停机问题（<a href="https://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/停机问题</a>）目前还没有办法完全证明。这个问题简单来说就是没办法判断一个程序是否能够在有限的时间内结束运行。</p>
<p>如果一个用户提交了一个死循环程序到以太坊中，那么就会无限的执行下去，从而将以太坊网络击垮。而使用 gas 机制则可以解决这个问题，智能合约中，每段代码的执行都会消耗一定量的 gas，在用户提交交易的时候需要指定好。如果 gas 消耗完了，那么智能合约就必须停止，交易也会被撤销，如果智能合约执行完成， gas 还有剩余，就会退还给用户。</p>
<p>需要特别说明的是，即使交易失败，用户也需要支付 gas 费用，因为以太坊为这些错误的交易也付出了计算资源。</p>
<p>除了这点之外，gas 还可以用来激励矿工，用户提交交易所消耗的 gas 费用最后都会给到矿工，矿工会优先去打包那些提供了更高 gas 价格的交易，在以太坊中，如果希望自己的交易早点被打包，可以设置更高的 gas 价格。</p>
<p>g<strong>as 机制是以太坊系统的命脉。</strong></p>
<p>gas 本质就是维护以太坊网络安全，这是从两个方面来做到的，一方面通过 gas 来衡量计算量，一方面使用 gas 来吸引更多的矿工，矿工的数量越多，以太坊网络就越安全。</p>
<p>gas 只能用于交易中，用户不会接触到 gas，gas 会在交易的提交的时候直接通过以太币来兑换。</p>
<h2>衡量 Gas 量</h2>
<p>智能合约中，每个操作都会消耗一定的 gas 。每个操作都对应一个 Opcode，下面是一些常见的 gas 消耗，完整的 gas 消耗说明看这里：<a href="https://github.com/crytic/evm-opcodes" target="_blank" rel="noopener">https://github.com/crytic/evm-opcodes</a></p>
<ul>
<li>0x00：停止执行，消耗 0 gas</li>
<li>0x01：加法运算，消耗 3 gas</li>
<li>0x02：乘法运算，消耗 5 gas</li>
<li>0x03：减法运算，消耗 3 gas</li>
<li>0x04：整数除法运算，消耗 5 gas</li>
<li>0x0a：指数运算，消耗 10^*（这里取决于具体的次方）</li>
<li>0x20：计算 Keccak-256 哈希，消耗 30 gas</li>
<li>0x31：获得给定账户的余额， 消耗 400 gas</li>
</ul>
<h2>以太坊区块的限制</h2>
<p>以太坊中的交易最后会被确认，打包成区块，这样交易才算是完成，但是在一个区块中，可以打包的交易是有限的，以太坊通过 gas 来限制可以打包的交易数。这样就让被打包的机会成为了一个稀缺的资源。</p>
<p>用户提交一个交易后，gas 量可以看做是一个固定的值，矿工为了做到最大收益，就会选择那些 gas 价格更高的交易。</p>
<h2>Gas 的价格如何决定</h2>
<p>很多以太坊的用户经常吐槽 gas 费过高，其实这里的过高不是指 gas 本身过高，而是指 gas 对应的以太坊价格过高。</p>
<p>因为 Gas 的价格不是固定的，而是波动的，简单来说就是根据供需关系来决定的，如果同时需要用以太坊的用户多，那么Gas 的价格就贵，如果用户的人少，那么 Gas 的费用就会少。</p>
<p>以太币的最基本单位是 wei，1 ETH = 10 ^18 wei，而衡量 gas 价格的单位则是 gwei，1 ETH = 10 ^ 9 gwei。</p>
<p>在提交交易的时候，需要设定两个参数，一个是 gas 的最大消耗量（gas limited）和 gas 的价格，gas 的消耗量通常情况下会比较固定，不会有太大的变化，主要是 gas 的价格会波动很大。</p>
<p>在上面我们说到矿工会挑选那些 gas 费用比较高的交易进行打包。所以 gas 的价格设置的越高，那么总的 gas 费用就会越高。如果想让当前的交易尽快被确认，那么就需要设置一个当前相对来说比较高的 gas 价格。</p>
<p>其实对当前 gas 价格最清楚的就是那些矿工，所以矿工们也提供了一些服务，让用户可以实时的了解到当前 gas 价格的分布。比如 GasNow 就是一个比较常用的服务，现在很多钱包中都在使用这个来为钱包的用户提供 gas 价格建议。</p>
<p>如果你提交的交易不紧急，那么使用当前的平均 gas 价格就可以，如果需要提交紧急的交易，那么就需要设置更高的 gas 价格。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Modules v2 及后续版本</title>
    <url>/2021/02/05/Go-Modules-v2-%E5%8F%8A%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>在代码发布到 v2 之后，发布的策略与之前稍有不同，这篇文章介绍了 v2 之后版本的发布方法。</p>
<p>原文地址：<a href="https://blog.golang.org/v2-go-modules" target="_blank" rel="noopener">https://blog.golang.org/v2-go-modules</a></p>
<hr>
<h2>简介</h2>
<p>这个系列的文章总共有五篇，这是第四篇：</p>
<ul>
<li><a href="http://">使用 Go Modules</a></li>
<li><a href="http://">迁移到 Go Modules</a></li>
<li><a href="http://">发布 Go Modules</a></li>
<li><strong>Go Modules：V2 及后续版本</strong></li>
<li>保持 Modules 的兼容性</li>
</ul>
<p>随着一个项目的成熟和新需求的增加，过去的特性和设计决策可能要被废弃。开发人员可能希望通过删除弃用的函数、重命名类型或将复杂的包拆分为可管理的部分来实践所学。这些的更改需要下游用户将他们的代码迁移到新的 API 中，因此应该仔细考虑收益与成本，在收益大于成本的情况下才进行更改。</p>
<p>对于仍处于试验阶段的项目（主版本号是 v0），用户期望偶尔会有突破性的变化。对于那些被声明为稳定的项目，在主版本 v1 或更高版本中，更改必须在新的主版本中完成。这篇文章探讨了主版本的语义，如何创建和发布一个新的主版本，以及如何维护一个模块的多个主版本。</p>
<h2>主版本和模块路径</h2>
<p>模块形成了了 Go 中的一个重要原则，即<a href="https://research.swtch.com/vgo-import" target="_blank" rel="noopener">导入兼容性规则</a>:</p>
<p>如果旧的包和新的包有同样的导入路径，新的包必须兼容旧的包。</p>
<p>根据定义，包的新主版本与以前的版本不向后兼容。这意味着模块的新主版本必须具有与前一个版本不同的模块路径。从 v2 开始，主版本必须出现在模块路径的末尾（在 go.mod 文件的 module 语句中声明）。例如，当模块 github.com/googleapis/gax-go 的作者开发 v2 版本时，他们使用了新的模块路径 github.com/googleapis/gax-go/v2。想要使用 v2 的用户必须将他们的包导入和模块需求更改到 github.com/googleapis/gax-go/v2。</p>
<p>Go 模块与其他依赖管理系统的不同之处在于，需要使用主版本后缀。后缀需要解决<a href="https://research.swtch.com/vgo-import#dependency_story" target="_blank" rel="noopener">菱形依赖问题</a>。在 Go 模块出现之前，gopkg.in 允许包的维护者遵循我们现在所说的导入兼容性规则。在 gopkg.in，如果你同时依赖一个导入 gopkg.in/yaml.v1  和另一个 gopkg.in/yaml.v2 包，这不会冲突，因为两个 yaml 包有不同的导入路径，它们使用了版本后缀，就像 Go模块一样。因为 gopkg.in 与 Go 模块使用相同的版本后缀方法，Go 命令接受 gopkg.in/yaml.v2 中的 v2 作为有效的主版本后缀。这是为了兼容 gopkg.in 的特殊情况：托管在其他地方的模块需要使用 /v2 这样的后缀。</p>
<h2>主版本策略</h2>
<p>在包括 v2 版本的更高版本中，推荐在以主版本号命名的目录下进行开发：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">github.com/googleapis/gax-go @ master branch</span><br><span class="line">/go.mod    → module github.com/googleapis/gax-go</span><br><span class="line">/v2/go.mod → module github.com/googleapis/gax-go/v2</span><br></pre></td></tr></table></figure></p>
<p>这个方法与对模块无感知的工具兼容：代码仓库中的文件路径与 GOPATH 模式下使用 go get 相匹配。这个策略还允许不同目录下的主版本同时进行开发。</p>
<p>其他策略可能将主版本保留在单独的分支上。但是，如果 v2+ 版本的源代码在仓库的的默认分支上（通常是 master 分支），那么不支持版本感知的工具——包括 GOPATH 模式下的 go 命令——可能无法区分主要版本。</p>
<p>这篇文章中的例子将遵循主版本子目录策略，因为它有最好的兼容性。我们建议模块作者，如果有用户在 GOPATH 模式下进行开发，就遵循这种策略。</p>
<h2>发布 v2 及后续版本</h2>
<p>这篇文章以 github.com/googleapis/gax-go 项目为例：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/tmp/gax-go</span><br><span class="line">$ ls</span><br><span class="line">CODE_OF_CONDUCT.md  call_option.go  internal</span><br><span class="line">CONTRIBUTING.md     gax.go          invoke.go</span><br><span class="line">LICENSE             go.mod          tools.go</span><br><span class="line">README.md           go.sum          RELEASING.md</span><br><span class="line">header.go</span><br><span class="line">$ cat go.mod</span><br><span class="line">module github.com/googleapis/gax-go</span><br><span class="line"></span><br><span class="line">go 1.9</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/golang/protobuf v1.3.1</span><br><span class="line">    golang.org/x/exp v0.0.0-20190221220918-438050ddec5e</span><br><span class="line">    golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3</span><br><span class="line">    golang.org/x/tools v0.0.0-20190114222345-bf090417da8b</span><br><span class="line">    google.golang.org/grpc v1.19.0</span><br><span class="line">    honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099</span><br><span class="line">)</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>在开始开发 github.com/googleapis/gax-go 的 v2 版本时，我们会创建一个 v2 目录，并把所有的包都拷贝进来：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir v2</span><br><span class="line">$ cp *.go v2/</span><br><span class="line">building file list ... <span class="keyword">done</span></span><br><span class="line">call_option.go</span><br><span class="line">gax.go</span><br><span class="line">header.go</span><br><span class="line">invoke.go</span><br><span class="line">tools.go</span><br><span class="line"></span><br><span class="line">sent 10588 bytes  received 130 bytes  21436.00 bytes/sec</span><br><span class="line">total size is 10208  speedup is 0.95</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>然后把当前的 go.mod 文件也拷贝到 v2 目录下，并在模块路径后面增加 v2 后缀：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp go.mod v2/go.mod</span><br><span class="line">$ go mod edit -module github.com/googleapis/gax-go/v2 v2/go.mod</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>需要注意 v2 版本与 v0/v1 版本都是是被当做一个单独的模块：但两者可能使用了相同的构建。因此，如果你的 v2+ 版本模块有多个包，你应该更新它们以使用新的 /v2 导入路径。否则，你的 v2+ 模块就依赖你的 v0 / v1 模块。所以要将所有 github.com/my/project 引用更新到github.com/my/project/v2，可以使用 find 和 sed :</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f \</span><br><span class="line">    -name <span class="string">'*.go'</span> \</span><br><span class="line">    -<span class="built_in">exec</span> sed -i -e <span class="string">'s,github.com/my/project,github.com/my/project/v2,g'</span> &#123;&#125; \;</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>现在我们有了一个 v2 版本的模块，但是我们想在发布一个版本之前进行试验和修改。在我们发布v2.0.0（或任何没有预发布后缀的版本）之前，我们可以在决定新 API 之前进行开发或做出破坏性的更改。如果我们想让用户在我们正式发布新 API 之前能够试用它，我们可以发布一个 v2 的预发布版本:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag v2.0.0-alpha.1</span><br><span class="line">$ git push origin v2.0.0-alpha.1</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>一旦 v2 版本的 API 已经稳定，并确定不需要做任何破坏性的更改，我们可以发布正式版本，标记 v2.0.0：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag v2.0.0</span><br><span class="line">$ git push origin v2.0.0</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>到目前为止，有两个主版本需要维护。向后兼容的更改和错误修复将产生新的次版本和补丁版本（例如，v1.1.0, v2.0.1，等等）。</p>
<h2>结论</h2>
<p>主版本变更会产生更多的开发和维护开销，并需要下游用户配合迁移。项目越大，这些管理代价就越大。只有在确定非做不可的原因之后，才应该进行主版本的变更。一旦修改原因被确定是一个破坏性变更，我们建议在主分支中开发多个主版本，因为这种方式能够最大化的与现有工具兼容。</p>
<p>对 v1+ 版本模块的破坏性更改应该总是发生在 vN+1 版本模块中。当新模块发布时，这意味着模块的维护者和需要迁移到新版本的用户需要做额外的工作。因此，维护者应该在发布一个稳定的版本之前验证他们的 API，并仔细考虑在 v1 版本之外是否真的有必要做大版本的变更。</p>
<hr>
<p>另外，腾讯云区块链方向在大量招人，包括前端、后端、架构师、产品等诸多岗位，如果感兴趣，请把简历投过来 <a href="mailto:rayjun0412@gmail.com">rayjun0412@gmail.com</a>。</p>
<p>译 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 并发编程 -goroutine 初体验</title>
    <url>/2021/05/23/Go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-goroutine-%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>说到 Go 语言，被人讨论最多的就是 Go 很擅长做高并发，并且不需要依赖外部的库，语言本身就支持高并发。</p>
<p>Go 中实现这一能力的秘密是 goroutine，也经常被称之为协程，goroutine 是 Go 对协程的实现。在这篇文章中，会介绍协程的基本概念，以及 goroutine 的基本使用。</p>
<h2>1.什么是协程</h2>
<p>协程（Coroutine），又被称之为微线程，这个概念出现的时间很早，在 1963 年就有相关的文献发表，但协程真正被用起来的时间很短。</p>
<p>对于操作系统来说，线程是最小的调度单位，但对于一些高并发的环境，线程处理起来就比较吃力，一方面操作系统能够分配的线程数量有限，另外线程之间的切换相对来说也比较大。</p>
<p>所以对于 Java 这类以线程为调度单位的语言，一般会依靠外部的类库来做到高并发，比如 Java 的Netty 就是一个开始高并发应用必不可少的库。</p>
<p>协程和线程非常类似，只是比线程更加轻量级，具体表现在协程之间的切换不需要涉及系统调用，也不需要互斥锁或者信号量等同步手段，甚至都不需要操作系统的支持。</p>
<p>协程与线程的行为基本一致，但是协程是在语言层面实现的，而线程是操作系统实现的。</p>
<h2>2. Go 语言的协程</h2>
<p>在 Go 语言中，支持两种并发编程的模式，一种就是以 goroutine 和 channel 为主，这种方式称之为 CSP 模式，这种方式的核心是在 goroutine 之间传递值来来实现并发。</p>
<p>还有一种方式是传统的共享内存式的模式，通过一些同步机制，比如锁之类的机制来实现并发。</p>
<p>Go 程序通过 main 函数来启动，main 函数启动的时候也会启动一个 goroutine，称之为<strong>主 goroutine</strong>。然后在主 goroutine 中通过 go 关键字创建新的 goroutine。go 语句是立马返回的，不会阻塞当前的 goroutine。</p>
<p>一个 Go 程序中可以创建的 goroutine 数量可以比线程数量多很多，这也是 Go 程序可以做到高并发的原因，goroutine 的实现原理，我们后续的文章再详细聊，下面来看看看 goroutine 的使用。</p>
<h2>3. goroutine 的基本使用</h2>
<p>goroutine 的使用很简单，只需要在调用的函数前面添加 go 关键字，就会创建一个新的 goroutine：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutine1</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello goroutine"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> goroutine1()</span><br><span class="line">	fmt.Println(<span class="string">"Hello main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但运行上面的代码之后，输出的结果为：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello main</span><br></pre></td></tr></table></figure></p>
<p>预想中的 <code>Hello goroutine</code> 并没有出现，因为 main 方法执行完成之后，main 方法 所在的 goroutine 就销毁了，其他的 goroutine 都没有机会执行完。</p>
<p>可以通过设置一个休眠时间来阻止主 goroutine 执行完成。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutine1</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello goroutine"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> goroutine1()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"Hello main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，输出结果就和我们预想的一样了:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello goroutine</span><br><span class="line">Hello main</span><br></pre></td></tr></table></figure></p>
<p>但是这种方法也存在一些问题，这个休眠时间不太好设置，设置的过长，会浪费时间，设置的过短， goroutine 还没运行完成，所以最好的方式是让 goroutine 自己来决定。我们再改动一下代码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutine2</span><span class="params">(isDone <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"child goroutine begin..."</span>)</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"child goroutine end..."</span>)</span><br><span class="line">	isDone &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	isDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> goroutine2(isDone)</span><br><span class="line">	&lt;-isDone</span><br><span class="line">	<span class="built_in">close</span>(isDone)</span><br><span class="line">	fmt.Println(<span class="string">"main goroutine end.."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，我们使用了 <code>chan</code> 类型，这个类型我们后续会详细讲解，暂时只需要知道创建一个 chan 类型的变量，传入到一个子 goroutine 之后，它就会阻塞当前的 goroutine，直到子 goroutine 执行完成。这种方式比上面设置休眠时间的方式要优雅很多，也不会产生一些意料之外的结果。</p>
<p>结果输出为：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">child goroutine begin...</span><br><span class="line">child goroutine end...</span><br><span class="line">main goroutine end..</span><br></pre></td></tr></table></figure></p>
<p>但这种方式还是不完美，现在只启动了一个 goroutine，如果要启动多个 goroutine，这种方式就不管用了。当然，肯定还是有解决办法的，看下面的代码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutine3</span><span class="params">(id <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	fmt.Printf(<span class="string">"child goroutine %d begin...\n"</span>, id)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">"child goroutine %d end...\n"</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> goroutine3(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个代码看起来要复杂不少，其中 <code>sync</code> 包中包括了 Go 语言并发编程的所有工具，我们用到的 <code>WaitGroup</code> 就是其中的一个工具。</p>
<p>首先创建一个 WaitGroup 类型的变量 wg，每创建一个 goroutine，就向 wg 中加 1，每个 goroutine 执行完成之后，就调用 wg.Done，这样 wg 就会减 1，wg.Wait() 会阻塞当前 goroutine，直到 wg 中的值清零。</p>
<p>如果熟悉其他语言同步机制的人就会想到，这不就是信号量么，是的，这就是使用信号量来实现的。这个 WaitGroup 与 Java 语言中的 <code>CountDownLatch</code> 功能是一样的。</p>
<p>输出的结果也很漂亮：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">child goroutine 4 begin...</span><br><span class="line">child goroutine 0 begin...</span><br><span class="line">child goroutine 3 begin...</span><br><span class="line">child goroutine 2 begin...</span><br><span class="line">child goroutine 1 begin...</span><br><span class="line">child goroutine 1 end...</span><br><span class="line">child goroutine 2 end...</span><br><span class="line">child goroutine 3 end...</span><br><span class="line">child goroutine 4 end...</span><br><span class="line">child goroutine 0 end...</span><br></pre></td></tr></table></figure></p>
<p>到这里，我们了解了 goroutine 的基本使用，但很多情况下，goroutine 不是独立运行的，而经常需要与其他的 goroutine 通信，在下一篇文章中，我们将详细的聊一聊 goroutine 之间的通信方式。</p>
<h2>4. 小结</h2>
<p>在这篇文章中，我们了解了协程的概念，并且知道了 goroutine 是 Go 语言对协程的实现。也知道了如何通过启动一个新的 goroutine 并发的去做一些事情，同时也知道了如何让 main  goroutine 来等待其他 goroutine 工作完成再退出的几种方法。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 底层数据结构研究</title>
    <url>/2019/02/10/Git-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>Git 作为当前最好用的版本管理工具，在之前的文章中，已经介绍了基本的用法，在这篇文章中，我们来探究一下 Git 的底层是如何构成的。</p>
<p>任意一个使用 git 进行版本管理的目录都会有一个 .git 目录，在这个目录中存储了这个项目的所有的版本管理的信息。</p>
<h3>.git 目录解析</h3>
<p>使用 <strong>git init git-test</strong> 初始化一个 git 项目后，在项目目录底下的 .git 目录中发现有如下的内容:</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/git/git-ls.png" alt=""></p>
<p>在上面的图片中，有多个文件和文件夹，咱们现在只看最重要的那几个。</p>
<ul>
<li>HEAD</li>
<li>branches</li>
<li>config</li>
<li>objects</li>
<li>refs</li>
</ul>
<p>执行以下命令:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat HEAD</span></span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure></p>
<p>通过上面的操作我们发现 HEAD 的值是一个引用，指向了 <code>refs/heads/master</code>，而我们当前所在的分支就是 <strong>master</strong>，也就是说 HEAD 的值就是当前所处的分支。</p>
<p>进入 refs 目录发现有如下内容:</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/git/git-refs.png" alt=""></p>
<p>再进入 <strong>heads</strong> 目录中，内容如下:</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/git/git-refs-heads.png" alt=""></p>
<p>heads 目录中有 <strong>dev</strong> 和 <strong>master</strong> 两个文件。也就是对应我们的 <strong>dev</strong> 和 <strong>master</strong> 两个分支。那么这两个文件中存储的到底是什么内容呢:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat master</span></span><br><span class="line">9fa28775a75a2a0d156e0c37a9b20f04ec94b47a</span><br></pre></td></tr></table></figure>
可以看到 master 文件中储存的是一个哈希值。这个哈希值代表了什么呢？可以通过 Git 提供的接口进行查询:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t 9fa28775a75a2a0d156e0c37a9b20f04ec94b47a</span></span><br><span class="line">commit</span><br></pre></td></tr></table></figure>
结果得到了一个叫做 commit 的东西，至于这个 commit 时什么我们稍后再说。</p>
<p>在 <strong>heads</strong> 目录中，还有一个 <strong>tags</strong> 目录，这里面存储的就是而我们之前的创建的 tag。来看一下 tag 中存储的内容:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat v0.0.1</span></span><br><span class="line">9fa28775a75a2a0d156e0c37a9b20f04ec94b47a</span><br></pre></td></tr></table></figure>
tag 本身也是一个哈希值。同样来看一下 tag 的类型:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t 9fa28775a75a2a0d156e0c37a9b20f04ec94b47a</span></span><br><span class="line">tag</span><br></pre></td></tr></table></figure>
这里出现了一个 tag 类型（需要注意的是轻量级的标签指向的是一个 commit 而不是单独创建一个 tag 对象，所以在创建 tag 的使用建议带上 -m 参数）。</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 9fa28775a75a2a0d156e0c37a9b20f04ec94b47a</span></span><br><span class="line">object 9fa28775a75a2a0d156e0c37a9b20f04ec94b47a</span><br><span class="line">type commit</span><br><span class="line">tag v0.0.2</span><br><span class="line">tagger rayjun &lt;leijun19930412@sina.com&gt; 1549899267 +0800</span><br><span class="line"></span><br><span class="line">第二个标签</span><br></pre></td></tr></table></figure>
通过将 <strong>git cat-file</strong> 的 -t 参数改成 -p，可以看到 tag 储存的其实就是一个 commit。</p>
<p>那么 commit 中储存了什么呢？来看一下:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 9fa28775a75a2a0d156e0c37a9b20f04ec94b47a</span></span><br><span class="line">tree 291f8d9c7f50c3ab750c2ef8dd182b3903d13292</span><br><span class="line">author rayjun &lt;leijun19930412@sina.com&gt; 1549894768 +0800</span><br><span class="line">committer rayjun &lt;leijun19930412@sina.com&gt; 1549894768 +0800</span><br><span class="line"></span><br><span class="line">Update</span><br></pre></td></tr></table></figure>
通过 <strong>git cat-file</strong> 的 -p 参数，可以看到 commit 中储存了一个 tree 类型的对象。 继续往下看:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 291f8d9c7f50c3ab750c2ef8dd182b3903d13292</span></span><br><span class="line">100644 blob d67064b5343698146a1d22c063f80b039020314a	readme.md</span><br></pre></td></tr></table></figure>
然后发现这个 tree 中出现了一个 blob 的类型，并且指向一个文件名。再往下看:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p d67064b5343698146a1d22c063f80b039020314a</span></span><br><span class="line">Read me</span><br></pre></td></tr></table></figure>
发现 blob 对象存储的就是文件的内容。看到这里，基本就明白了，git 的整个数据结构就是由tag、commit、tree 和 blob 等几类基础的数据结构构成。但 tag 其实也就是 commit，所以基础的数据结构也就是 commit、tree 和 blob。这些类型的对象都存储在 <strong>objects</strong> 文件夹中。也就是是说在 <strong>objects</strong> 存储了所有文件的版本信息。</p>
<p>config 中保存着当前仓库的配置。</p>
<h3>commit、tree 和 blob</h3>
<p>Git 有着丰富的操作，那么底层的数据结构是如何支撑起这些复杂的操作的。其实 Git 底层的数据结构很简单，但是却足够灵活，所有的其他复杂的功能都是在这简单的数据结构上构建起来的。主要有 <strong>commit</strong> 和 <strong>tree</strong> 和 <strong>blob</strong> 三种数据结构组成。</p>
<p>commit 的概念很简单，在每次执行 <strong>git commit</strong> 之后都会生成一个 commit 对象，每一个commit 对象都会对应一个仅一个 tree。而 blob 对象就是具体的文件了，每一个文件都是一个 blob 对象。</p>
<p>这三者的关系如下图所示:</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/git/git-commit.png" alt=""></p>
<p>在 Git 中，如果一个文件没有被改变，那么在每次提交 commit 时，Git 不会为这个文件生成新的对象，而是使用之前的对象。</p>
<p>随着项目的进行，被添加进文件越来越多，那么 Git 需要管理的对象也就越来越多。那么势必会降低效率。所以 Git 使用了两个方式来提高效率:</p>
<ul>
<li>除了初始对象外，后续的对象存储的都是文件的差异，而不是全部的文件</li>
<li>Git 自带 gc，随着需要管理的对象数量的增加，Git会将部分对象进行打包存储，提高效率</li>
</ul>
<p>Git 最创建一个新的对象时在磁盘中存储的称之为<strong>松散对象</strong>，随着对象数量的增加，Git 会自动将这些对象打包成二进制文件，当然也可以手动执行 <strong>git gc</strong> 来进行对象的打包。如果有远程服务器，每次推送到远程服务器时，都会触发打包过程。************</p>
<p>(完)</p>
<p><strong>参考文献:</strong></p>
<ol>
<li>https://github.com/progit/progit2</li>
<li>https://git-scm.com/docs</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 并发编程-channel 连接一切</title>
    <url>/2021/05/28/Go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-channel-%E8%BF%9E%E6%8E%A5%E4%B8%80%E5%88%87/</url>
    <content><![CDATA[<p>在上一篇文章中，我们介绍了 Go 并发编程的基础—goroutine，同时也介绍 goroutine 的几种使用方式，但没有说明 goroutine 之间是如何通信的。</p>
<p>Go 语言中有一句经典的话，<strong>不要通过共享内存来通信，而应该通过通信来共享内存</strong>。这个原则让 channel 成为了 Go 语言中非常重要的一个组件。</p>
<p>goroutine 之间的通信主要是通过 channel 来完成的，这篇文章中，我们来认识一下 channel，以及channel 的基本使用。</p>
<h2>1. 什么是通道（channel）</h2>
<p>Go 语言中，并发模式有两种实现方式，一种是传统的通过锁和信号量等手段，来实现对个共享变量（内存）的同步访问，从而实现并发。还有一种通过 goroutine + channel 的组合方式，传递值的方式来实现并发。</p>
<p>goroutine + channel 是对 CSP（Communicating Sequential Process）模式的一种实现。CSP 模式中，有两个核心的概念，process 和 channel，process 对应 groutine，所有的 process 之间的通信通过 channel 来实现。</p>
<p>channel 是可以被单独创建的，可以用来连接任意两个 goroutine，channel 也有自己的数据类型，被称之为<strong>通道的元素类型</strong>。</p>
<p>创建一个通道很简单，比如下面创建了传递 int 值的通道:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p>
<p>chan 表示通道，int 表示通道中传递的元素类型，使用 make 就可以创建一个新的通道。make 返回的结果是通道的引用，当复制这个通道或者把通道作为函数参数的时候，传递的都是引用，这点很重要，需要重点理解一下。这里顺便说一下，channel 是可比较的，也就是说可以通过 == 来比较。</p>
<p>通道有两个操作，一个是发送，一个是接收，都使用 &lt;- 来表示，区别在于发送时，通道在前，接收时通道在后。向一个通道中发送数据：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">5</span></span><br><span class="line">ch &lt;- x</span><br></pre></td></tr></table></figure></p>
<p>从通道中接收一个结果，如果不把结果赋值给一个变量，结果就会被抛弃，这样也是合法的：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := &lt;-ch</span><br><span class="line">&lt;-ch <span class="comment">// 这样也是合法的</span></span><br></pre></td></tr></table></figure></p>
<p>一个完整的发送和接收的例子如下：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		x := <span class="number">5</span></span><br><span class="line">		ch &lt;- x</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	y := &lt;-ch</span><br><span class="line">	fmt.Println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在使用通道的过程中，可能会出现死锁，具体的原因我们下文再详细说。对于通道来说，还有一个操作，就是关闭通道，对于一个已经关闭的 channel，无法再发送数据，否则会发生 panic，但是可以进行接收操作，下面的程序可以正常运行：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		x := <span class="number">5</span></span><br><span class="line">		ch &lt;- x</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	y := &lt;-ch</span><br><span class="line">	fmt.Println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>2.  无缓冲通道</h2>
<p>上面用来创建通道的 make 其实还有第二个参数，用来指定通道容量。如果不指定这个参数或者指定的参数是 0，那么就表示这个通道是无缓冲通道：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面两种创建方式是等价的</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>在无缓冲通道上的发送操作会阻塞，直到接收端的接收操作完成，然后才会继续执行</strong>。在上一篇文章中，我们为了解决主 goroutine 等待子 goroutine 执行完成用的就是这个方法。代码如下：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutine2</span><span class="params">(isDone <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"child goroutine begin..."</span>)</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"child goroutine end..."</span>)</span><br><span class="line">	isDone &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	isDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> goroutine2(isDone)</span><br><span class="line">	&lt;-isDone</span><br><span class="line">	fmt.Println(<span class="string">"main goroutine end.."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以对于无缓冲通道来说，不能在同一个 goroutine 中使用，否则会造成死锁。关于死锁的问题，下文再详细讨论。</p>
<h2>3. 缓冲通道</h2>
<p>在创建缓冲通道时，需要指定通道的容量：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面的代码创建了容量为 3 的通道，可以直接向通道中发送值，发送的前 3 个操作不会阻塞：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>如果在发送的过程中，如果接收端没有接收，那么此时通道就是满的，在发送第 4 个值的时候就会阻塞。</p>
<p>对于缓冲通道，可以使用 <code>cap</code> 方法得到通道的容量，可以使用 <code>len</code> 方法得到当前通道中元素的个数：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cap</span>(ch) <span class="comment">// 获取容量</span></span><br><span class="line"><span class="built_in">len</span>(ch) <span class="comment">// 获取元素个数</span></span><br></pre></td></tr></table></figure></p>
<p>对于一个缓冲通道，在同一个 goroutine 中使用也有造成死锁的风险，所以最好不要在同一个 goroutine 中使用通道。</p>
<h2>4. 单向通道</h2>
<p>在默认情况下，创建的通道可以发送数据，可以接受数据，但是在一些情况下，我们值需要通道的发送或者接收能力。这个时候，就需要单向通道。</p>
<p>单向通道的表示起来很简单，把 &lt;- 放在 chan 前，表示只接收，放在 chan 后表示只发送：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sendCh := male(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>) <span class="comment">// 表示只发送的通道</span></span><br><span class="line">recCh := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 表示只接收的通道</span></span><br></pre></td></tr></table></figure></p>
<p>但实际的使用中，我们不需要去创建这种单向通道，只是在某些情况下，我们把通道转成单向通道就行。比如下面的代码中，在 sendData 方法中，我只需要用到通道的发送能力，所以可以通道改成发送的单向通道，其他人阅读代码的时候，也更能理解：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	sendData(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(sendCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		sendCh &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>双向通道可以转成转成单向通道，但反过来却不行。</p>
<h2>5. 小结</h2>
<p>这篇文章介绍了通道，通道对于 Go 语言来说很重要，是实现高并发的基础，通道为 goroutine 之间提供了一种高效安全的通信方式。但在使用通道的时候需要注意死锁问题。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 字符串拼接最佳实践</title>
    <url>/2021/08/30/Go-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>字符串是一个常见的数据类型，在 Go 语言在内的很多语言中，为了安全，都把字符串设计为不可变。每生成一个字符串都是在创建一个新的字符串，而不是在原有字符串的基础上修改。</p>
<p>在 Go 中，字符串拼接的方式很多，可以直接使用 +，也可以使用 fmt.SPrintf，还可以使用 strings.Builder 和 bytes.Buffer。</p>
<p>在这篇文章中，来讨论一下在代码中如何做字符串拼接效率最好。</p>
<h2>1. 做一个基准测试</h2>
<p>在开始分析每种拼接方法的优劣之前，先跑一个简单的基准测试，来看一下每种字符串拼接方法的性能。</p>
<p>Go 中提供了基准测试框架，测试文件需要以 test 结尾，然后每个测试方法以 Benchmark 开头，这次对加号、fmt.SPrintf、和 strings.Builder 三种方式进行基准测试，代码如下：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPlus</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	str := <span class="string">"this is just a string"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		stringPlus(str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSPrintf</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	str := <span class="string">"this is just a string"</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		stringSprintf(str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringBuilder</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	str := <span class="string">"this is just a string"</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		stringBuilder(str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringPlus</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	s := <span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		s += str</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringSprintf</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	s := <span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> i :=<span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		s += str</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringBuilder</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	builder := strings.Builder&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">		builder.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基准测试需要使用 <code>*testing.B</code> ，其中 b.N 不是一个固定的值，这个值的大小由框架自己来决定。</p>
<p>在这里，我们分别测试用不同的方式拼接一个固定的字符串 10000 次，然后统计平均的代码执行时间，内存消耗情况。使用如下的命令运行基准测试：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test -bench=. -benchmem</span><br></pre></td></tr></table></figure></p>
<p>-bench=. 参数运行当前包中所有基准测试，-benchmem 表示对测试的内存使用情况进行统计。运行上面的命令之后，输出结果如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: zxin.com/zx-demo/string_benchmark</span><br><span class="line">BenchmarkPlus-12                      12          96586447 ns/op        1086401355 B/op    10057 allocs/op</span><br><span class="line">BenchmarkSPrintf-12                   12          97037216 ns/op        1086402698 B/op    10065 allocs/op</span><br><span class="line">BenchmarkStringBuilder-12            655           1713353 ns/op        11671537 B/op         35 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      zxin.com/zx-demo/string_benchmark       6.186s</span><br></pre></td></tr></table></figure></p>
<p>第一列表示基准测试的方法名称和所用的 GOMAXPROCS 的值，第二列表示这次测试循环的次数，第三列表示平均每次测试所用的时间，单位为纳秒，第四列表示平均每次运行所分配的内存，第五列表示每次运行所分配内存的次数。</p>
<p>通过上面的测试，可以发现 strings.Builder 的表现是最好的，比直接使用加号来拼接字符串的内存消耗要小 100 倍。</p>
<h2>2. 为什么性能的差异这么大</h2>
<p>通过上面的基准测试可以发现，使用不同的方式来拼接字符串，性能差异很大。</p>
<p>Go 的字符串是不可变的，如果使用加号的方式来拼接字符串，那么每次拼接都需要重新分配内存。而 strings.Builder 会对内存预分配，在字符串不断写入的过程中，会自动扩容长度。</p>
<p>strings.Builder 的底层存储使用的是 []byte，初始的长度分配是 32，然后每次扩容时都会翻一倍。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Builder <span class="keyword">struct</span> &#123;</span><br><span class="line">	addr *Builder</span><br><span class="line">	buf  []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当长度到大 2048 时，再扩容就不会直接翻倍，而是每次增加 640 的倍数，第一次增加 640，第二次增加 1280，以此类推。</p>
<p>在大量拼接字符串的时候 strings.Builder 会比直接拼接的效率更高。</p>
<p>bytes.Buffer 是另一个类似的库，与 strings.Builder 性能相当，但如果是对于纯拼接字符串的场景，还是推荐使用 strings.Builder。</p>
<h2>3. 拼字符串的最佳实践</h2>
<p>虽然 strings.Builder 的性能很高，但并不是所有的场景都是合这个。如果只是一次简单的字符串拼接，直接使用加号就够了。</p>
<p>如果涉及到一些字符串的格式化，那么使用 fmt.Sprintf 就更合适了。</p>
<p>那么在大量拼接字符串的场景，直接使用 strings.Builder 就完事了么，其实还可以继续优化一下。在使用 strings.Builder 时，如果字符串在不断的增加，底层的存储还是要不断的扩容。如果可以预估字符串的长度，就可以提前分配好内存。减少扩容的次数。</p>
<p>增加一个测试用例:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func BenchmarkStringBuilderPre(b *testing.B) &#123;</span><br><span class="line">	str := <span class="string">"this is just a string"</span></span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">		stringBuilderPre(str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func stringBuilderPre(str string) string &#123;</span><br><span class="line">	builder := strings.Builder&#123;&#125;</span><br><span class="line">	builder.Grow(1000000)</span><br><span class="line">	<span class="keyword">for</span> i := 0; i &lt; 100000; i++ &#123;</span><br><span class="line">		builder.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> builder.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是基准测试的结果：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg: zxin.com/zx-demo/string_benchmark</span><br><span class="line">BenchmarkPlus-12                              12          96676019 ns/op        1086401676 B/op    10057 allocs/op</span><br><span class="line">BenchmarkSPrintf-12                           12          96693407 ns/op        1086402022 B/op    10058 allocs/op</span><br><span class="line">BenchmarkStringBuilder-12                    607           1822282 ns/op        11671543 B/op         35 allocs/op</span><br><span class="line">BenchmarkStringBuilderPre-12                 860           1393689 ns/op         8257539 B/op          5 allocs/op</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在提前指定长度的情况下，性能又提升了不少，内存的占用量和分配次数下降了不少，运行时间也有所提升。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 的 UTF-8 实现</title>
    <url>/2021/04/24/Go-%E7%9A%84-UTF-8-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>计算机刚开始诞生的时候，计算机内的字符可以全部由 ASCII 来表示，ASCII 字符的长度是 7 位，可以表示 128 个字符，对于美国等国家来说是够了，但是对于世界上的其他国家，特别是东亚国家，文字不是由字母组成，汉字就有几万个，ASCII 码根本不够用。</p>
<p>字符本质就是对应计算机中的一个数值，既然不够用，那么解决方法就是把这个范围扩大，Unicode 的出现就解决了这个问题，它包括了世界上所有的字符，每一个字符都对应一个数值，这个数值被称之为 <strong>Unicode 码点</strong>。</p>
<p>但是 Unicode 也不是没有缺点，因为表示的范围大，所以每一个 Unicode 都需要 4 个字节来表示，但是对于原本的 ASCII 编码，本来只需要一个字节，现在也需要 4个字节，这样会浪费很多存储。</p>
<p>UTF-8 的出现解决了这个问题，它解决问题的思路是让每个字符选择自己的大小，需要多少字节就用多少。对于占不同字节的字符，有不同的表示格式：</p>
<ul>
<li>1 字节：0xxxxxxx</li>
<li>2 字节：110xxxxx 10xxxxxx</li>
<li>3 字节：1110xxxx 10xxxxxx 10xxxxxx</li>
<li>4 字节：11110xxx 10 xxxxxx 10xxxxxx 10xxxxxx</li>
</ul>
<p>通过识别每个字符串的头部来判断占几个字节。</p>
<p>每个 Unicode 字符都对应一个码点，在字符串中，可以对码点进行转义，使用 <code>\uhhhh</code> 表示 16 位码点，使用 <code>\Uhhhhhhhh</code> 来表示 32 位码点，每一个 h 都代表一个十六进制的数字。</p>
<p>这里有一点比较特殊，对于码点值小于 256 的文字符号可以使用单个十六进制的数字来表示，比如 'A' 可以使用 '\x41' 来表示，对于大于 256 的码点，就必须使用 \u 或者 \U 来转义。</p>
<p>Go 语言对于 UTF-8 的支持很好，这里有一点很有意思，Go 语言的两位作者 Ken Thompson 和  Rob Pike 同时也是 UTF-8 的发明者，Go 语言对 UTF-8 的支持赢在起跑线。</p>
<p>Go 语言总是使用 UTF-8 来处理源文件，同时也是优先使用 UTF-8 来处理字符串。所以上面说到的那些 Unicode 字符的转义被 Go 直接处理，比如下面三个字符串在 Go 语言中是等价的:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">"世界"</span></span><br><span class="line"><span class="string">"\u4e16\u754c"</span></span><br><span class="line"><span class="string">"\U00004e16\U0000u754c"</span></span><br></pre></td></tr></table></figure></p>
<p>Go 字符串使用只读的 []byte 来存储，所以字符串值是不变的，这样做更安全，效率也很高：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">"left root"</span></span><br><span class="line">t := s</span><br><span class="line">s += <span class="string">", right root"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(s) <span class="comment">// left root, right root</span></span><br><span class="line">fmt.Println(t) <span class="comment">// left root</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中， s 的值出现了变化，但是 t 的值还是旧的字符串。由于是 [] byte 是 slice 类型，所以字符串的截取操作效率很高，但是在字符串截取的过程中，就会出现一些坑。</p>
<p>Go 中的字符串底层使用了只读的 []byte 来存储，所以**本质上 Go 语言中的字符串是使用字节来表示，而不是字符表示，**理解这一点很重要。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">"hello world"</span></span><br><span class="line">fmt.Println(str[:<span class="number">2</span>]) <span class="comment">// he</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">"你好，世界"</span></span><br><span class="line">fmt.Println(str[:<span class="number">2</span>]) <span class="comment">// ��，这个符号用来表示 UTF-8 里面的未知字符，码点是</span></span><br></pre></td></tr></table></figure></p>
<p>非 ASCII 码的字符一般占用的字节会超过一个，如果直接截取，就会导致截取不到正确的位置，从而乱码。在上面的例子中，一个中文字符占 3 个字节，只有严格按照字节数来截取才能获取到显示正常的字符：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"你好，世界"</span></span><br><span class="line">fmt.Println(str[:<span class="number">3</span>]) <span class="comment">// 你</span></span><br></pre></td></tr></table></figure></p>
<p>那么在这个时候，如果要按照字符截取，就需要把字符串转成 []rune，每个 rune 都代表一个 UTF-8 中的码点，对 []rune 按照字符截取就不会出现乱码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"你好，世界"</span></span><br><span class="line">runeStr := []<span class="keyword">rune</span>(str)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(runeStr[:<span class="number">1</span>])) <span class="comment">// 你</span></span><br></pre></td></tr></table></figure></p>
<p>把字符串转成 []rune，就是把字符串转成 UTF-8 码点，而不是 []byte，rune 其实就是 int32 类型。</p>
<p>Go 语言中有一个专门 <code>unicode/utf8</code> 包来处理 utf8 字符。由于每个字符占据的字节可能不一样，所以字符数和字节数大小是两回事：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">"Hello, 世界"</span> <span class="comment">// 逗号是半角符号</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))                    <span class="comment">// 13</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(s)) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></p>
<p>如果要获取字符占据的总字节数，就使用 len 方法，如果需要计算字符的个数，那就需要使用 utf8.RuneCountInString 方法。</p>
<p>这个包里面还提供了其他常用函数：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否符合 utf8 编码：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Valid</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ValidRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ValidString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">// 判断 <span class="title">rune</span> 所占的字节数</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">RuneLen</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">// 判断字节串或者字符串中的 <span class="title">rune</span> 字符数</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">RuneCount</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">RuneCountInString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">// 对 <span class="title">rune</span> 的编码和解码</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">EncodeRune</span><span class="params">(p []<span class="keyword">byte</span>, r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">DecodeRune</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">DecodeRuneInString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">DecodeLastRune</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">DecodeLastRuneInString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>除了 utf8 包之外， <code>unicode</code> 包对提供了一系列 IsXX 函数来 rune 的检查：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(rangeTab *RangeTable, r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否是 <span class="title">RangeTable</span> 类型的</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">In</span><span class="params">(r <span class="keyword">rune</span>, ranges ...*RangeTable)</span> <span class="title">bool</span>  // 是否是 <span class="title">ranges</span> 中任意一个类型的字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsControl</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>  // 是否是控制字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsDigit</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>  // 是否是阿拉伯数字字符，即 0-9</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsGraphic</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否是图形字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsLetter</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否是字母</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsLower</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否是小写字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsMark</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否是符号字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsNumber</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否是数字字符，包含罗马数字</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsOneOf</span><span class="params">(ranges []*RangeTable, r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否是 <span class="title">RangeTable</span> 中的一个</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsPrint</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否是可打印字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsPunct</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否是标点符号</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsSpace</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否是空格</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsSymbol</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否符号字符</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsTitle</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 字符串中的每个单词的第一个字符是否是大写</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsUpper</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span> // 是否是大写字符</span></span><br></pre></td></tr></table></figure></p>
<p>RangeTable 是对所有 Unicode 字符的分类，比如验证一个字符是否是汉字：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := <span class="string">'中'</span></span><br><span class="line">result := unicode.Is(unicode.Han, r)</span><br><span class="line">fmt.Println(result) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>其中 <code>unicode.Han</code> 就是 RangeTable 类型，表示汉字。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 的测试框架</title>
    <url>/2021/09/05/Go-%E7%9A%84%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>Go 语言中自带了测试框架，在不引入外部包的情况下，也可以编写完整的测试。这篇文章来看一下Go 提供原生测试能力，及其不足之处，以及补充这些不足的方法。</p>
<h2>1. 基本测试框架</h2>
<p>在 Go 语言中，所有的测试都需要以 <code>_test.go</code> 结尾，这样go build 不会去编译 <code>_test.go</code> 结尾的文件，而 go test 会去编译 <code>_test.go</code> 结尾的文件。</p>
<p>在编写测试的时候，我们都会用到 <code>testing</code> 这个包，在这个包中，常用的类型有下面这些:</p>
<ul>
<li>testing.T</li>
<li>testing.B</li>
<li>testing.M</li>
</ul>
<p>testing.TB 和 testing.PB 平时用的不多，在这里就不展开说，感兴趣的可以自行去搜索。上面的三类代表了三种不同的测试，分别是单元测试、基准测试和 TestMain 测试，对于不同的测试，在测试方法的入参中，必须带上这个类型。</p>
<p>有一类测试例外，那就是 Example 测试，这个测试主要用来在文档中输出一些测试案例，Example 测试必须以 Example 开头，方法不需要任何参数，同时要指明这个实例的输出，像下面这样：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"run example test"</span>)</span><br><span class="line">	<span class="comment">// Output:</span></span><br><span class="line">	<span class="comment">// run example test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有的测试都可以通过 <code>go test</code> 来发起，例如，在当前包下发起测试 <code>go test -v ./</code> ，-v 参数表示打印测试的过程，会把测试过程中的标准输出都打印出来。</p>
<h2>2. 单元测试</h2>
<p>单元测试的编写需要按照一定的规则来，所有的单元测试都需要以 Test 开头，后面加上测试的方法名称，就像下面这样：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">" run test demo"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是一个最简单的单元测试，在实际使用中，一组测试可能会有多个单元测试，而且要同时运行，这时我们就需要一个方法将这些测试串联起来，那就需要用到 TestMain 了，这个方法名称和签名是统一的，只能是下面的写法：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"begin test"</span>)</span><br><span class="line">	m.Run()</span><br><span class="line">	fmt.Println(<span class="string">"end test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TestMain(m *testing.M) 在一个包下只能有一个，测试执行的时候，会先执行这个方法，然后再去执行这个包下的所有 Test 测试和 Example 测试，基准测试则不会执行。</p>
<p>而且这个方法可以用来初始化和回收资源，有些测试在运行之前需要初始化一些配置，连接数据库、释放数据库连接等操作，就可以在这个测试中完成。</p>
<p>写完上面的测试之后，就可以运行测试了，这样会从 TestMain 开始，运行所有的 Test 和 Example 测试：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -v ./</span><br></pre></td></tr></table></figure></p>
<p>但有时候我们也会关心单元测试的覆盖率，只要加上一个参数就可以看到测试的覆盖率：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -cover -v ./</span><br></pre></td></tr></table></figure></p>
<h2>3. 基准测试</h2>
<p>基准测试通常用来测试某个程序的性能，基准测试必须要用 Benchmark 开头，同时方法的入参必须是 testing.B，就像下面这样：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDemo</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"run benchmark demo"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了更好的说明基准测试的功能，我用之前测试字符串拼接的基准测试的例子来说明：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPlus</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	str := <span class="string">"this is just a string"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		stringPlus(str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringPlus</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	s := <span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		s += str</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 b.N 不是一个固定的值，这个值的大小由框架自己来决定，上面这侧测试的内容是对于一个要拼接一万次字符传的函数进行性能测试，至于这个测试运行多少次，由框架自己决定。</p>
<p>运行基准测试的命令如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -bench=. -benchmem .</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: zxin.com/zx-demo/string_benchmark</span><br><span class="line">**BenchmarkPlus-12                      12          96586447 ns/op        1086401355 B/op    10057 allocs/op**</span><br><span class="line">PASS</span><br><span class="line">ok      zxin.com/zx-demo/string_benchmark       6.186s</span><br></pre></td></tr></table></figure></p>
<p>加粗的那行是基准测试的输出，每列信息的具体含义如下：</p>
<ul>
<li>第一列表示基准测试的方法名称和所用的 GOMAXPROCS 的值</li>
<li>第二列表示这次测试循环的次数</li>
<li>第三列表示平均每次测试所用的时间，单位为纳秒</li>
<li>第四列表示平均每次运行所分配的内存</li>
<li>第五列表示每次运行所分配内存的次数</li>
</ul>
<h2>4. 测试加强</h2>
<p>但原生的测试包不够完美，比如在单元测试中，就缺少断言机制，使得在判断测试结果的时候，非常不方便，有一个外部的包可以帮助完善测试的功能。</p>
<p>安装也很方便：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get github.com/stretchr/testify</span><br></pre></td></tr></table></figure></p>
<p>这个包从三个方面扩展了 Go 原生测试框架的能力：</p>
<ul>
<li><strong>断言</strong></li>
</ul>
<p>原生测试框架里面缺失断言功能，在很多场景下都不方便，testify 提供的断言功能开箱即用，与原生测试框架完美契合：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAssert</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	assert := assert.New(t)</span><br><span class="line"></span><br><span class="line">	assert.Equal(<span class="number">123</span>, <span class="number">123</span>, <span class="string">"they should be equal"</span>)</span><br><span class="line"></span><br><span class="line">	assert.NotEqual(<span class="number">123</span>, <span class="number">456</span>, <span class="string">"they should not be equal"</span>)</span><br><span class="line"></span><br><span class="line">	o := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	o[<span class="string">"ray"</span>] = <span class="string">"jun"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> assert.NotNil(o) &#123;</span><br><span class="line">		assert.Equal(<span class="string">"jun"</span>, o[<span class="string">"ray"</span>])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		assert.Nil(o)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Mock 能力</li>
</ul>
<p>testify 提供了Mock 的能力，可以很好的模拟测试需要的数据，对于一些需要复杂数据的测试很有帮助：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMockedObject <span class="keyword">struct</span>&#123;</span><br><span class="line">	mock.Mock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyMockedObject)</span> <span class="title">DoSomething</span><span class="params">(number <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	args := m.Called(number)</span><br><span class="line">	<span class="keyword">return</span> args.Bool(<span class="number">0</span>), args.Error(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSomething</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	testObj := <span class="built_in">new</span>(MyMockedObject)</span><br><span class="line"></span><br><span class="line">	testObj.On(<span class="string">"DoSomething"</span>, <span class="number">123</span>).Return(<span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	testMockObj(testObj)</span><br><span class="line"></span><br><span class="line">	testObj.AssertExpectations(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMockObj</span><span class="params">(mcObj *MyMockedObject)</span></span> &#123;</span><br><span class="line">	fmt.Println(mcObj.DoSomething(<span class="number">123</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>构建更完善的测试</strong></li>
</ul>
<p>即使有了 TestMain 来初始化配置，但也还是不够灵活，比如在一个包下，我需要包含多组测试，而且每组测试的初始化都不一样，而 testify 提供的 suite  包提供了更加面向对象的测试方式，并且也提供了 setup/teardown 等方法来初始化和回收资源，可以直接使用 <code>go test</code> 进行测试，不会对现有的测试框架有侵入性修改：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ExampleTestSuite <span class="keyword">struct</span> &#123;</span><br><span class="line">	suite.Suite</span><br><span class="line">	VariableThatShouldStartAtFive <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(suite *ExampleTestSuite)</span> <span class="title">SetupTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"run setup method"</span>)</span><br><span class="line">	suite.VariableThatShouldStartAtFive = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(suite *ExampleTestSuite)</span> <span class="title">TearDownTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"run tear down method"</span>)</span><br><span class="line">	suite.VariableThatShouldStartAtFive = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(suite *ExampleTestSuite)</span> <span class="title">TestExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">	assert.Equal(suite.T(), <span class="number">5</span>, suite.VariableThatShouldStartAtFive)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestExampleTestSuite</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	suite.Run(t, <span class="built_in">new</span>(ExampleTestSuite))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>5. 小结</h2>
<p>虽然 Go 原生测试框架已经支持编写很复杂的测试，但很多场景下还不是很方便，这时候就有必要引入新的测试加强包 testify，这个包基本做到了开箱即用，而且不会破坏现有的测试流程。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 并发编程-共享变量</title>
    <url>/2021/08/30/Go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>在之前的文章中，我们详细说了 Go 语言中 goroutine + channel 通过通信的方式来共享内存，从而实现并发编程。</p>
<p>但同时 Go 也提供了传统通过共享变量，也就是共享内存的方式来实现并发。这篇文章会介绍 Go</p>
<p>提供的相关机制。</p>
<h2>1. 什么是竞态</h2>
<p>在一个 Go 程序运行起来之后，会有很多的 goroutine 同时运行，每个 goroutine 中代码的执行是顺序的，如果我们无法确定两个 goroutine 中代码的执行顺序。就可以说这两个 goroutine 是并发执行的。</p>
<p>如果一段代码无论是顺序执行还是并发执行，结果都是正确的，那就可以说这个代码是并发安全的。</p>
<p>并发不安全的代码出现的问题有多种，比如死锁、活锁、经态等等。死锁和活锁都表示代码已经无法继续执行了，而竞态则表示代码是可以执行的，但是有可能会出现错误的结果。</p>
<p>有一个典型的例子就是向银行账户中存款：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    balance = balance + amount</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假如现在有两个人同时向这个账户中存款，各自存了 100 次：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		Deposit(<span class="number">100</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		Deposit(<span class="number">100</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 休眠一秒，让上面的 goroutine 执行完成</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Println(Balance())</span><br></pre></td></tr></table></figure></p>
<p>如果程序正确，那么最后的输出应该是 20000，但多次运行，结果可能是 19800、19900 或者其他的值。这个时候，我们就会说这个程序存在数据竞态。</p>
<p>这个问题的根本原因是 <code>balance = balance + amount</code> 这行代码在 CPU 上的执行操作不是原子的，有可能执行到一半的时候会被打断。</p>
<h2>2. 如何消除竞态</h2>
<p>发生了竞态，就要想办法解决。总的来说，解决竞态有三种办法：</p>
<ul>
<li>
<p>不要修改变量</p>
<p>如果一个变量不需要修改，在任何地方访问都是安全的，但这个方法却无法解决上面的问题。</p>
</li>
<li>
<p>不要多个 goroutine 中去访问同一个变量</p>
</li>
</ul>
<p>我们前面说聊过的 goroutine + channel 就是这样的一个思路，通过 channel 阻塞来更新变量，这也符合 Go 代码的设计理念：<strong>不要通过共享内存来通信，而应该通过通信来共享内存</strong>。</p>
<ul>
<li>同一时间只允许一个 goroutine 访问变量</li>
</ul>
<p>如果在同一时间只能有一个 goroutine 访问变量，其他的 goruotine 需要等到当前的访问结束之后，才能访问，这样也可以消除竞态，下面将要说到的工具就是用来保证同一时间只能有一个 goroutine 来访问变量。</p>
<h2>3. Go 提供的并发工具</h2>
<p>在上面我们已经说到了解决竞态的三种办法，下面的这些工具就是 Go 中用来实现同一时间只能有一个 goroutine 访问变量。我们分别来看一下：</p>
<h3>3.1 互斥锁</h3>
<p>这个是解决竞态最经典的工具，它的原理就是如果要访问一个资源，那么就必须要拿到这个资源的锁，只有拿到锁才有资格访问资源，其他的 goroutine 想要访问，必须等到当前 goroutine 释放了锁，抢到锁之后再访问</p>
<p>在使用之前，需要先为资源申请一把锁，使用的就是 sync.Mutex，这是 Go 语言中互斥锁的实现：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> balance <span class="keyword">int</span></span><br></pre></td></tr></table></figure></p>
<p>每个拿到锁的 goroutine 都需要保证在对变量的访问结束之后，把锁释放掉，即使发生在异常情况，也需要释放，这里可以使用 defer 来保证最终会释放锁：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	balance = balance + amount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把代码改完之后，再去运行上面存款的代码，无论运行多少遍，最终的结果都是 20000，到这里，我们竞态的问题就算是解决了，但是还有点小问题。</p>
<h3>3.2 读写互斥锁</h3>
<p>上面的互斥锁解决了访问数据的竞态问题，但是还有个小问题，就是读余额的操作有点低效，每次来读余额的时候，都还需要去抢锁，实际上，这个变量如果没有改变，即使同时被多个 goroutine 读，也不会产生并发安全的问题。</p>
<p>我们想要的一个理想的场景就是，如果这个变量没有在写入，就可以运行多个 goroutine 同时读，这样可以大大提高效率。</p>
<p>Go 也提供了这个工具，那就是<strong>读写锁</strong>。这个锁读与读是不互斥的，简单来说就是这个锁可以保证同时只能有一个 goroutine 在写入，如果有 goroutine 在写入，其他的 goroutine 既不能读，也不能写，但允许多个 goroutine 同时来读。</p>
<p>我们把上面的代码再改一下，只需要改一个地方：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex <span class="comment">// 替换 sync.Mutex</span></span><br><span class="line"><span class="keyword">var</span> balance <span class="keyword">int</span></span><br></pre></td></tr></table></figure></p>
<p>这样改完之后，上面存款的代码还是会一直输出 20000，但同时可以允许多个 goroutine 同时读余额。</p>
<p>大多数 Go 语言中的竞态问题都可以使用这两个工具来解决。</p>
<h3>3.3 Once</h3>
<p>Go 语言中还提供了这样的一个工具，可以保证代码只会执行一遍，多用于资源初始化等场景。使用的方式也很简单：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">o := &amp;sync.Once&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">	o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			Deposit(<span class="number">100</span>)</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			Deposit(<span class="number">100</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 休眠一秒，让上面的 goroutine 执行完成</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Println(Balance())</span><br></pre></td></tr></table></figure></p>
<p>如果上面的代码使用 Once 来控制之后，都只会存一次，所以上面的代码会永远输出 200。</p>
<h3>3.4 竞态检测器</h3>
<p>很多处在竞态的错误很难发现，Go 语言中提供了一个工具，可以帮忙检查代码中是否存在竞态。使用起来很简单，只需要在以下命令之后加上 <code>-race</code> 参数就可以：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run -race</span><br><span class="line"></span><br><span class="line">$ go build -race</span><br><span class="line"></span><br><span class="line">$ go <span class="built_in">test</span> -race</span><br></pre></td></tr></table></figure></p>
<p>加上这个参数之后，编译器会对代码在执行时对所有共享变量的访问，如果发现一个 goroutine 写入一个变量之后，没有任何同步的操作，就有另外一个 goroutine 读写了这个变量，那就说明这里存在竞态，就会报错。比如下面的代码：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">data := 1</span><br><span class="line"></span><br><span class="line">go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">	data = 2</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">	data = 3</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(2 * time.Second)</span><br></pre></td></tr></table></figure></p>
<p>运行 <code>go run -race main.go</code> 之后，会报下面的错误：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Found 1 data race(s)</span><br><span class="line"><span class="built_in">exit</span> status 66</span><br></pre></td></tr></table></figure></p>
<h2>4. 小结</h2>
<p>Go 中也提供了传统语言所提供的并发编程机制，也可以通过共享内存的方法来实现并发编程。Go 提供的接口相对来说比较简洁，提供的能力却足够强大。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Goroutine 是如何运行的</title>
    <url>/2021/08/30/Goroutine-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p>在 Go 语言中，没有线程，只有 goroutine，这也是 Go 语言原生支持高并发的关键。 goroutine 是 Go 语言对协程的实现。goroutine 非常轻量级，一般只有几 Kb 的大小，而一个线程最小都有 1 M。</p>
<p>goroutine 本身只是一个数据结构，真正让 goroutine 运行起来的是<strong>调度器</strong>。</p>
<h2>1. 为什么需要一个调度器</h2>
<p>在计算机上运行的程序最终都是需要 CPU 去执行，协程只是运行在操作系统的<strong>用户态</strong>。协程真正的执行依然需要依靠操作系统<strong>内核态</strong>的线程去执行。</p>
<p>操作系统并不知道协程的存在，会把协程当做普通的程序来执行。既然协程是为了提高程序的执行效率，那么一个理想的情况是一个线程上可以执行多个协程。</p>
<p>如果一个协程对于一个线程，那就相当于协程的创建和运行还是由内核态来执行，这样的代价有点高。但如果一个线程上可以运行多个协程，如果其中的一个协程发生了阻塞，那么其他的协程就都无法执行了。</p>
<p>所以理想的情况是协程是线程的关系是 m:n，这样就可以克服 m:1 和 1:1 的缺点。但 m:n 的情况最为复杂，需要自己来实现协程在多个线程的调度，充分利用计算机的多核能力，再配合协程的轻量级的特性，实现程序的高并发。</p>
<p>在 Go 的实现中，goroutine 与内核态线程的对应关系就是是 m:n，所以就需要自己实现一个协程的调度器。</p>
<p><img src="0.png" alt=""></p>
<h2>2. 调度器的结构</h2>
<p>Go 调度器从最开始到现在也经历了不断的演进，最初的那个版本已经被放弃，目前使用的版本是在 2012 重新设计的，然后沿用至今。</p>
<p>现在用的这个调度器也被称之为 GMP 模型，3 个字母分表代表一个关键部件的名称：</p>
<ul>
<li>G：表示 goroutine，就是代表待执行的协程</li>
<li>M：M 表示的是内核态的线程，goroutine 真正的执行需要依赖 M</li>
<li>P：P 是调度器的核心，它会把 G 调度到合适的  M 上去执行，让 G 的执行尽可能快的完成</li>
</ul>
<p><img src="1.png" alt=""></p>
<p>如果 M，也就是线程如果想要运行任务，就需要去获取一个 P，然后从 P 的任务队列中获取 goroutine 来执行。</p>
<p>在 P 上，会有一个正在 M 上执行的 G，但是同时也会维护一个本地的队列，里面都是待执行的 G，其中 P 的数量由 GOMAXPROCS 环境变量或者 runtime.GOMAXPROCS() 来决定，这表示在同一时间，只有 GOMAXPROCS 数量个 goroutine 在执行。</p>
<p>P 与 M 的数量没有固定的关系，如果当前的 M 阻塞了，P 就会去创建或者切换到另一个 M 上。</p>
<h2>3. 调度器是如何运作的</h2>
<p>在介绍完 GMP 的结构之后，我们再来看一下 GMP 调度器是如何运行起来的。</p>
<p>在 Go 语言中，我们创建一个 goroutine 非常简单，只需要使用 go 关键字:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"New goroutine"</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p>
<p>这样就会创建上面所说的一个 G，然后放进调度器中开始调度。</p>
<p><img src="2.png" alt=""></p>
<p>每个 G 在被创建之后，都会被优先放入到本地队列中，如果本地队列已经满了，就会被放入到全局队列中。</p>
<p>然后每个 M 就开始执行 P 的本地队列中的 G，如果某个 M 把任务都执行完成之后，然后就会去去全局队列中拿 G，这里需要注意，每次去全局队列拿 G 的时候，都需要上锁，避免同样的任务被多次拿。</p>
<p>如果全局队列都被拿完了，而当前 M 也没有更多的 G 可以执行的时候，它就会去其他 P 的本地队列中拿任务，这个机制被称之为 work stealing 机制，每次会拿走一半的任务，向下取整，比如另一个 P 中有 3 个任务，那一半就是一个任务。</p>
<p>这样还有一个特别的场景需要说明，当一个 M 被阻塞时，M 就会与 P 解绑，让 P 去找其他空闲的 M 绑定执行后面的 G，如果没有空闲的 M，就会创建一个新的 M。当 M 阻塞结束之后，就会把 G 放入到全局队列中，这个机制称之为 hand off 机制。</p>
<p>work stealing 和 hand off 机制提高了线程的使用效率，避免的线程重复创建和销毁。</p>
<p>当全局队列为空，M 也没办法从其他的 P 中拿任务的时候，就会让自身进入自选状态，等待有新的 G 进来。最多只会有 GOMAXPROCS 个 M 在自旋状态，过多 M 的自旋会浪费 CPU 资源，多余的 M 的就会与 P 解绑，进入到休眠状态。</p>
<h2>4. 小结</h2>
<p>为了让 goroutine 的运行更有效率，Go 实现了一个用户态的调度器，这个调度器充分利用现代计算机的多核特性，同时让多个 goroutine 运行，同时 goroutine 设计的很轻量级，调度和上下文切换的代价都比较小。 而且利用 work stealing 和 hand off 机制，对线程进行复用，避免了线程的重复创建。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 泛型初体验</title>
    <url>/2021/08/30/Go-%E6%B3%9B%E5%9E%8B%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>在 Go1.17 中，千呼万唤的泛型终于出来了，但又没有完全出来。在 Go1.17 的发布文档中，并没有提到泛型，但是眼见的网友发现，泛型相关的代码其实已经合并了，只是没有默认启用。目前来说，泛型的玩玩就行，不要用到生产中。</p>
<p>泛型有望在 Go1.18 版本中发布。</p>
<h2>1. 启用泛型</h2>
<p>泛型的功能虽然添加到 Go.1.17 中了，如果要使用，需要添加一些参数开启，首先需要安装 Go1.17:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go version                                                                                                                                                                                                                                                                       ~</span><br><span class="line">go version go1.17 darwin/amd64</span><br></pre></td></tr></table></figure></p>
<p>然后可以在编译 的参数中看到泛型的影子，下面的 -G 参数就是启用泛型所需要的参数：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go tool compile -h                                                                                                                                                                                                                                                               ~</span><br><span class="line">usage: compile [options] file.go...</span><br><span class="line">  -% int</span><br><span class="line">    	debug non-static initializers</span><br><span class="line">  -+	compiling runtime</span><br><span class="line">  -B	<span class="built_in">disable</span> bounds checking</span><br><span class="line">  -C	<span class="built_in">disable</span> printing of columns <span class="keyword">in</span> error messages</span><br><span class="line">  -D path</span><br><span class="line">    	<span class="built_in">set</span> relative path <span class="keyword">for</span> <span class="built_in">local</span> imports</span><br><span class="line">  -E	debug symbol <span class="built_in">export</span></span><br><span class="line">  -G	accept generic code</span><br></pre></td></tr></table></figure></p>
<p>看一个例子：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Addable <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>,</span><br><span class="line">		<span class="keyword">uint</span>, <span class="keyword">uint8</span>, <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span>, <span class="keyword">uintptr</span>,</span><br><span class="line">		<span class="keyword">float32</span>, <span class="keyword">float64</span>, <span class="keyword">complex64</span>, <span class="keyword">complex128</span>,</span><br><span class="line">		<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span>[<span class="title">T</span> <span class="title">Addable</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(add(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(add(<span class="string">"foo"</span>,<span class="string">"bar"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果直接运行上面的代码，会报下面的错误，这也说明 Go1.17 默认是不支持泛型的：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run main.go                                                                                                                                                                                                                       </span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./main.go:8:2: syntax error: unexpected <span class="built_in">type</span>, expecting method or interface name</span><br><span class="line">./main.go:14:6: missing <span class="keyword">function</span> body</span><br><span class="line">./main.go:14:9: syntax error: unexpected [, expecting (</span><br></pre></td></tr></table></figure></p>
<p>需要加上下面的参数：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run -gcflags=-G=3 main.go                                                                                                                                                                                                     ↵</span><br><span class="line">3</span><br><span class="line">foobar</span><br></pre></td></tr></table></figure></p>
<p>第一个泛型程序成功运行了。</p>
<h2>2. 类型参数和约束</h2>
<p>在 Go 泛型中，增加了两个新概念，一个是 type parameters，下面代码中的 T 就是类型参数，用来表示泛型：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span>[<span class="title">T</span> <span class="title">Addable</span>]<span class="params">(a, b T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以说 type parameters 在 Go 中就是泛型的意思。</p>
<p>再看一下下面这段代码，这里泛型的类型是 any，上面的代码则是自定义的 Addable。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(a T)</span></span> &#123;</span><br><span class="line">     fmt.Printf(<span class="string">"%v"</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的 add 函数是有约束的，只能使用 Addable 中定义的类型，如果我们把 Addable 中的 string 去掉，代码就会报下面的错误：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run -gcflags=-G=3 main.go</span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./main.go:24:20: string does not satisfy Addable (string not found <span class="keyword">in</span> int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr, float32, float64, complex64, complex128)</span><br></pre></td></tr></table></figure></p>
<p>而 print 函数则可以接受任何类型的参数。</p>
<p>这就是 Go 中泛型最重要的两个概念：<strong>类型参数</strong> 和 <strong>约束</strong>。</p>
<h2>3. 类型推断</h2>
<p>正常使用泛型的时候，其实要使用下面这种方式来调用的，以 add 方法为例：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">add[<span class="keyword">int</span>](<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">add[<span class="keyword">string</span>](<span class="string">"foo"</span>,<span class="string">"bar"</span>)</span><br></pre></td></tr></table></figure></p>
<p>但是按照下面的方式写代码也是合法的：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">add(<span class="string">"foo"</span>,<span class="string">"bar"</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以把泛型参数省略调，这不部分的工作其实是 Go 编译器来完成的，编译器会根据传入的实际类型来推断，而不用每次写代码的时候都指明泛型的类型。</p>
<p>类型推断可以让代码简洁不少。</p>
<h2>4. 小结</h2>
<p>Go 泛型涉及到的内容大致就是上面这些了，当然泛型也可以写出很复杂的代码，但实际上涉及到的内容也就是上面那些。总体来说还是比较简洁的，这也与 Go 的设计理念符合。</p>
<p>Go 泛型目前还没有正式发布，上面的内容在正式发布的时候可能也会有所调整，所以不要在生产中区使用泛型。</p>
<p>本文例子来源于：<a href="https://github.com/mattn/go-generics-example" target="_blank" rel="noopener">https://github.com/mattn/go-generics-example</a></p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go1.16 发布</title>
    <url>/2021/02/21/Go1-16-%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>原文地址：<a href="https://blog.golang.org/go1.16" target="_blank" rel="noopener">https://blog.golang.org/go1.16</a></p>
<p>今天 Go 团队很高兴的宣布 Go1.16 已经发布，你可以从<a href="https://golang.org/dl/" target="_blank" rel="noopener">这里</a>下载。</p>
<p>新版的 <a href="https://golang.org/doc/go1.16#library-embed" target="_blank" rel="noopener">embed 包</a>可以直接通过 // go:embed 在编译时嵌入文件。现在更容易打包数据文件到 Go 程序中，让使用 Go 开发更加丝滑。你可以从 <a href="https://pkg.go.dev/embed" target="_blank" rel="noopener">embed 包的文档</a>开始学习。Carl Johnson 也写了一篇很好的教程，<a href="https://blog.carlmjohnson.net/post/2021/how-to-use-go-embed/" target="_blank" rel="noopener">如何使用 Go embd</a>。</p>
<p>Go1.16 也开始支持 <a href="https://golang.org/doc/go1.16#darwin" target="_blank" rel="noopener">macOS ARM64 架构</a>（也被称之为苹果芯片）。自从苹果宣布了他们的 arm64 架构，我们就与他们开了密切的合作，确保 Go 可以被完全支持，详细内容看我们的 <a href="https://blog.golang.org/ports" target="_blank" rel="noopener">ARM 上的 Go</a>。</p>
<p>请注意，Go 1.16 默认情况下<a href="https://golang.org/doc/go1.16#modules" target="_blank" rel="noopener">需要使用 Go Modules</a>，根据我们的 2020 Go 开发者调查，96% 的 Go开发者已经改用了Go Modules。我们最近添加了<a href="https://golang.org/doc/modules/developing" target="_blank" rel="noopener">用于开发和发布模块</a>的官方文档。</p>
<p>最后，还有许多其他的改进和 bug 修复，包括构建速度提高了 25%，使用的内存减少了 15%。有关上述改进的完整列表和更多信息，请参见 Go 1.16 发布说明。</p>
<p>我们要感谢每一个通过编写代码修复 bug、提供反馈以及测试 beta 版而为这个发行版做出贡献的人。</p>
<p>您的贡献和勤奋可以确保 Go 1.16 尽可能稳定。也就是说，如果你注意到任何问题，请提交一个 <a href="https://golang.org/issue/new" target="_blank" rel="noopener">issue</a>。</p>
<p>我们希望你喜欢这个新版本。</p>
<p>译 / Rayjun
本文首发于我的微信公众号【Rayjun】，欢迎关注</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go1.16 中模块的新变化</title>
    <url>/2021/04/09/Go1-16-%E4%B8%AD%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B0%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<p>在前不久 Go1.16 发布了，其中模块的功能也得到了更新，来看看具体有哪些变化。</p>
<p>原文地址：<a href="https://blog.golang.org/go116-module-changes" target="_blank" rel="noopener">https://blog.golang.org/go116-module-changes</a></p>
<hr>
<p>我们希望你喜欢 Go1.16！这个版本中有很多的新特性，特别是在模块功能上。在<a href="https://golang.org/doc/go1.16" target="_blank" rel="noopener">发布备注</a>中简单的描述了这些改变，现在让我们来深入的研究一下。</p>
<h2>模块的默认设置</h2>
<p>现在 go 命令在编译代码时，会默认使用启用模块功能，即使没有 go.mod 文件。这促进了在所有的项目中使用模块功能。</p>
<p>如果把 GO111MODULE 设置为 off，就还可以在 GOPATH 下编译代码。也可以把 GO111MODULE 设置为 auto，这样就可以检测当前目录或者父目录中的 go.mod 文件。你可以使用 <code>go env -w</code> 来设置 GO111MODULE 或者其他变量的值:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go env -w GO111MODULE=auto</span><br></pre></td></tr></table></figure></p>
<p>我们计划在 Go1.17 中放弃对 GOPATH 的支持，换句话说，在 Go1.17 中，将会忽略 GO111MODULE 变量。如果你还有项目没有使用 Go Modules，现在是时候迁移了。如果在迁移的过程中，如果你遇到了问题，可以提交一个 issue 或者一个体验报告。</p>
<h2>不自动修改 go.mod 和 go.sum</h2>
<p>在之前，当 go 命令发现 go.mod 或者 go.sum 缺少了 require 命令或者缺少一个检验和，它会尝试自动去修复这个问题。我们收到了很多反馈，表示这种行为会让人意外，特别是还有 go list 这种本不该有副作用的命令。这种自动修复通常补充很准确，如果导入的包在依赖中找不到，go 命令就会添加一个新的依赖，可能会触发对其他依赖的升级。甚至一个拼写错误的导入路径都会触发一个失败的网络依赖查询。</p>
<p>在 Go1.16 中，模块的命令发现 go.mod 或者 go.sum 的错误之后会把错误抛出来，而不是自动去修复这个错误。在大多数情况下，报错信息会提示使用一些命令来修复错误。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build</span><br><span class="line">example.go:3:8: no required module provides package golang.org/x/net/html; to add it:</span><br><span class="line">    go get golang.org/x/net/html</span><br><span class="line">$ go get golang.org/x/net/html</span><br><span class="line">$ go build</span><br></pre></td></tr></table></figure></p>
<p>与之前一样，go 命令可以使用 vendor 目录（请参阅 vendor 获取更多信息）。像 go get 和 go mod   tidy 命令任然可以修改 go.mod 和 go.sum，因为他们的主要目的是管理依赖项。</p>
<h2>安装特定版本的依赖</h2>
<p>go install 命令现在可以通过指定 @version 后缀来安装一个特定版本的依赖。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install golang.org/x/tools/gopls@v0.6.5</span><br></pre></td></tr></table></figure></p>
<p>当使用这个语法时，go install 会按照执行的版本进行安装，忽略当前目录和父目录中的 go.mod 文件。（不使用 @version 后缀时，go install 与之前的行为一样，使用当前模块的 go.mod 中的版本来构建程序。）</p>
<p>我们以前推荐使用 go get -u 来安装依赖包，但 go get 命令会在 go.mod 中增加或者修改模块的依赖版本，会让人迷惑。为了避免这种意外的修改，有人开始使用下面这种复杂的命令：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$HOME</span>; GO111MODULE=on go get program@latest</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以用 go install program@latest 来进行安装。在 <a href="https://golang.org/ref/mod#go-install" target="_blank" rel="noopener">go install</a> 查看详情。</p>
<p>为了避免对使用哪个版本出现歧义，在使用 go install 命令时，在 go.mod 中设置了几个限制。特别是暂时不允许使用 replace 和 exclude。如果后续 go install program@version 的表现足够好，我们计划让 go get 不再用来安装程序。具体参见 <a href="https://golang.org/issue/43684" target="_blank" rel="noopener">issue 43684</a>。</p>
<h2>模块撤销</h2>
<p>你曾经有没有发布过没有准备好的版本？或者你在发布一个版本后发现了一个问题，需要快速修复？在发布的版本中修复错误通常很困难。为了保持模块构建的确定性，一个版本在发布后不能被修改。如果你删除或者修改版本的 tag，但在 proxy.golang.org 或者其他代理商可能已经有了原版本的缓存。</p>
<p>模块的作者现在可以在 go.mod 中使用 retract 撤回某个版本。一个被撤回的版本还会存在，也可以下载（依赖这个版本的程序不会崩溃），但是在使用 @latest 来下载依赖时，go 命令不会自动去选择这个被撤回的版本。对于已经在用这个版本程序，执行 go get 和 go list -m -u 命令时会出现警告。</p>
<p>举个例子，假设 <code>[example.com/lib](http://example.com/lib)</code> 的作者发布了 v1.0.5 版本，但同时发现了一个安全问题，他可以在 go.mod 中添加一个撤回指令，像下面这样：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// Remote-triggered crash <span class="keyword">in</span> package foo. See CVE-2021-01234.</span><br><span class="line">retract v1.0.5</span><br></pre></td></tr></table></figure></p>
<p>接下来，作者打了一个新的 tag v1.0.6，并发布了新版本。然后，已经在使用 v1.0.5 的用户在检查更新或者升级包的时候会收到一个撤回的通知。通知的信息包括 retract 指令下的注释：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go list -m -u all</span><br><span class="line">example.com/lib v1.0.0 (retracted)</span><br><span class="line">$ go get .</span><br><span class="line">go: warning: example.com/lib@v1.0.5: retracted by module author:</span><br><span class="line">    Remote-triggered crash <span class="keyword">in</span> package foo. See CVE-2021-01234.</span><br><span class="line">go: to switch to the latest unretracted version, run:</span><br><span class="line">    go get example.com/lib@latest</span><br></pre></td></tr></table></figure></p>
<p>想要在浏览器上查看指南，请查看 <a href="https://play-with-go.dev/" target="_blank" rel="noopener">play-with-go.dev</a> 上的<a href="https://play-with-go.dev/retract-module-versions_go116_en/" target="_blank" rel="noopener">模块版本撤回</a>。更多详细语法<a href="https://golang.org/ref/mod#go-mod-file-retract" target="_blank" rel="noopener">参见</a>。</p>
<h2>使用 GOVCS</h2>
<p>go 命令可以通过代理镜像（比如：<a href="https://proxy.golang.org/" target="_blank" rel="noopener">proxy.golang.org</a>）或者通过版本控制仓库（git、hg、svn、bzr、fossil 等等）下载源码。直接的版本控制访问很重要，特别是对于在代理上不可用的私有模块，但它也是一个潜在的安全问题，版本控制工具中的漏洞可能被恶意服务器利用来运行非预期的代码。</p>
<p>Go1.16 中新增了一个配置变量，GOVCS，可以让用户指定允许的版本控制工具。GOVCS 接受一个 pattern:vcslist 的列表，逗号隔开。pattern 是通过 path.Match 方法来匹配一个或多个模块路径的前缀。public 和 private 是两个特殊的 pattern，private 匹配私有的模块（private 匹配在 GOPRIVATE 中定义的，public 只所有可以访问模块）。vclist 是一个通过管道分隔符分割的列表，包含允许的版本控制命令或关键字 all 或 off。</p>
<p>比如：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GOVCS=github.com:git,evil.com:off,*:git|hg</span><br></pre></td></tr></table></figure></p>
<p>在上面的配置中，允许通过 git 下载 github.com 上的模块。evil.com 上的所有模块都不能下载，其它的路径（*表示匹配所有）可以通过 git 或者 hg 下载。</p>
<p>如果 没有设置 GOVCS，或者不匹配任何路径，go 命令就会使用默认值：git 和 hg 允许用于公共模块，而私有模块允许使用所有的工具。只允许 Git 和 Mercurial 用于公共模块的原因是，这两个工具在不受信任的服务器上运行的表现最好。相比之下，Bazaar、Fossil 和 Subversion 主要是在可信任的、经过验证的环境中使用的。默认的配置如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GOVCS=public:git|hg,private:all</span><br></pre></td></tr></table></figure></p>
<p>详细参见<a href="https://golang.org/ref/mod#vcs-govcs" target="_blank" rel="noopener">这里</a>。</p>
<h2>接下来</h2>
<p>我们希望这些特性对你有用。我们已经在努力的开发 Go1.17 中的新特性，特别是<a href="https://github.com/golang/go/issues/36460" target="_blank" rel="noopener">模块的延迟加载</a>，这会让模块的加载更快，更稳定。另外，如果你发现了 bug，请让我们<a href="https://github.com/golang/go/issues" target="_blank" rel="noopener">知道</a>。Happy coding！</p>
<p>译 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go并发编程-channel多路复用</title>
    <url>/2021/08/30/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-channel%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<p>在前面两篇文章中，已经详细的介绍了 goroutine 和 channel，它们是 Go 并发编程的基础。今天这篇文章会介绍 Go 并发编程中另一个重要的角色——多路复用。</p>
<h2>1. 为什么需要多路复用</h2>
<p>Go 程序在并发处理一些任务的时，会为每一个任务创建一个 goroutine，然后需要根据不同的 goroutine 的返回的结果做不同的处理。</p>
<p>如果按照通常的做法，分别获取每个 channel 的结果：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">taskCh1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">taskCh2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">taskCh3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> run(taskCh1)</span><br><span class="line"><span class="keyword">go</span> run(taskCh2)</span><br><span class="line"><span class="keyword">go</span> run(taskCh3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 接收通道 1 的结果</span></span><br><span class="line">    result1 := &lt;-taskCh1</span><br><span class="line">    <span class="comment">// 接收通道 2 的结果</span></span><br><span class="line">    result2 := &lt;-taskCh2</span><br><span class="line">    <span class="comment">// 接收通道 3 的结果</span></span><br><span class="line">    result3 := &lt;-taskCh3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后再根据不同 goroutine 返回的结果做后续的处理，这个代码有个问题，需要等待所有的 goroutine 都执行完成之后才能做出结果，这样实现的效率很低，因为每一个获取 channel 值的过程都是阻塞的。</p>
<p>在处理多个通道时，想同时接收多个通道的数据将会变的很困难。</p>
<p>而且在一些情况下，需要根据先返回通道的做出不同的处理，上面那种方式无法做到，这就<strong>需要使用多路复用</strong>。</p>
<p>Go 提供了 select 机制来解决这个问题。</p>
<h2>2. select 基本使用</h2>
<p>select 语法形式和 switch 很相似，switch 接收一个变量，然后根据变量的值做不同的处理，select 操作接收的是通道操作：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 这个例子中，这里必须用缓冲通道</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"case 1 invoke"</span>)</span><br><span class="line">	<span class="keyword">case</span> data := &lt;-ch:</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Printf(<span class="string">"case 2 invoke %d\n"</span>, data)</span><br><span class="line">	<span class="keyword">case</span> ch &lt;- <span class="number">100</span>:</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"case3 invoke"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 select 的 case 中，可以执行三种操作：</p>
<ol>
<li>&lt;- ch：接收通道，但是对值不处理</li>
<li>data := &lt;-ch：接收通道，并处理从通道中得到的结果</li>
<li>ch &lt;- 100：向通道中发送数据</li>
</ol>
<p>上面的程序运行起来之后，case 3 会首先执行，然后 case1 和 case2 会随机执行一个，程序就这样一直交替运行下去。</p>
<p>如果用 select 改造上面第一个例子中的代码，就是下面这样：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 接收通道 1 的结果</span></span><br><span class="line">		<span class="keyword">case</span> r := &lt;-taskCh1:</span><br><span class="line">			fmt.Printf(<span class="string">"task1 result %+v\n"</span>, r)</span><br><span class="line">		<span class="comment">// 接收通道 2 的结果</span></span><br><span class="line">		<span class="keyword">case</span> r := &lt;-taskCh2:</span><br><span class="line">			fmt.Printf(<span class="string">"task2 result %+v\n"</span>, r)</span><br><span class="line">		<span class="comment">// 接收通道 3 的结果</span></span><br><span class="line">		<span class="keyword">case</span> r := &lt;-taskCh3:</span><br><span class="line">			fmt.Printf(<span class="string">"task3 result %+v\n"</span>, r)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>select 会及时响应每一个就绪的 channel，无论是发送数据还是接收数据。</p>
<h2>3. 处理超时情况</h2>
<p>select 除了用于同时处理多个通道之外，还可以用来处理一些通道超时的情况，通道在阻塞的时候，如果没有外界的干扰，会一直等下去，但是可以通过 select 设置一个超时时间，来打断阻塞：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> data := &lt;- ch:</span><br><span class="line">	fmt.Printf(<span class="string">"case invoke %+v\n"</span>, data)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">	fmt.Println(<span class="string">"channel timeout"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码在创建了一个通道，但没有向通道中发送数据，如果不用 select，程序就会死锁。</p>
<p>select 中添加了两个 case，一个从通道中获取数据， 但肯定获取不到，所以在 3 秒钟之后，另一个 case 就会执行，返回通道超时的提示，这样就避免了程序会一直等待下去。</p>
<p>还有一个情况是我们有时候需用通过键盘获取其他输入设备向程序发送信号，也可以通过这种方式来实现，把上面的程序再修改一下：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">quitCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> quit <span class="keyword">string</span></span><br><span class="line">	fmt.Printf(<span class="string">"quit? are you sure?: "</span>)</span><br><span class="line">	fmt.Scanln(&amp;quit)</span><br><span class="line">	quitCh &lt;- <span class="literal">true</span></span><br><span class="line">&#125;(quitCh)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> data := &lt;- ch:</span><br><span class="line">	fmt.Printf(<span class="string">"case invoke %+v\n"</span>, data)</span><br><span class="line"><span class="keyword">case</span> &lt;-quitCh:</span><br><span class="line">	fmt.Println(<span class="string">"program quit"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这次不再通过超时来控制，而是通过键盘来控制，新建了一个通道，只有在键盘输入之后，才会向通道中发送数据，这样就可以做到自由控制程序的退出。</p>
<h2>4. 非阻塞的 select</h2>
<p>在上面的示例代码中，其实还少写了一部分，看下面的代码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">		fmt.Println(<span class="string">"case invoke"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码会出现死锁，因为这个 select 只有一个 case，而这个 case 永远都不会接收到数据，所以 select 本身也被阻塞了，程序无法继续运行，就会造成死锁，对于这种情况，我们设置一个可用的 case，让 select 变成非阻塞，就可以解决这个问题。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">		fmt.Println(<span class="string">"case invoke"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"default invoke"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，程序就不会死锁，而是不断的执行 default 中的内容。</p>
<h2>5. 小结</h2>
<p>在这篇文章中，我们介绍了通道的多路复用，并说明了可以用到多路复用的场景。下篇文章中，我们来详细聊一下 Go 是如何实现传统的并发模型。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go的声明语法为什么是这样</title>
    <url>/2021/01/09/Go%E7%9A%84%E5%A3%B0%E6%98%8E%E8%AF%AD%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%99%E6%A0%B7/</url>
    <content><![CDATA[<p>作为 Go 语言的初学者，一定觉得 Go 语言的声明语法很奇怪，我当然也不例外。对于这个问题，Go  语言官方写了一篇博客来回答这个问题，我觉得挺有意思的，就把博客翻译了一下。</p>
<p>总的来说， GO 的声明语法遵循一个原则，就是让声明可以从左往右读，由于指针沿用了 C 语言的风格，所以指针是一个例外，下面是原文的翻译。</p>
<p>原文地址：<a href="https://blog.golang.org/declaration-syntax" target="_blank" rel="noopener">https://blog.golang.org/declaration-syntax</a>、</p>
<hr>
<h2>简介</h2>
<p>很多 Go 语言的初学者都会奇怪，为什么声明语法与 C 语言族（Rayjun注：C++，Java 等语言）的差异这么大。在这篇文章中，我们会对比这两种方式，并且解释为什么 Go 语言要这样来实现。</p>
<h2>C 语法</h2>
<p>首先，让我们来讨论一下 C 语言的语法。C 语言选择了一种不寻常而且巧妙的方式来声明语法。不用特殊的语法来描述类型，而是写一个包含被声明项的表达式，并声明该表达式将具有什么类型，就像下面这样：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x</span><br></pre></td></tr></table></figure></p>
<p>把 x 声明为一个 int 意味着表达式 x 的类型是 int。通常，要写一个某种类型的变量，只需要将类型放在左边，将表达式放在右边。因此，声明的形式如下：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p>
<p>因为 *p 的类型是 int，所以 p 是一个指向 int 的指针，因为 a[3] 的类型是 int，所以 a 是一个 int 数组（忽略中括号中的这个数字，这个表示数组的长度）。</p>
<p>那么函数呢？本来，C 语言是把参数的类型写在括号之外，如下所示（看起来很奇怪）：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(argc, argv)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> argc</span>;</span><br><span class="line">    <span class="keyword">char</span> *argv[];</span><br><span class="line">&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再看一个方法，现在 C 语言的方法声明就是用的这种方式，因为这个表达式 main(argc, argv) 返回 int，所以最后会写成下面的形式：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这与上面第一个方法的基本结构是相同的。</p>
<p>对于简单类型，这是一个很好的方法，如果对于那些复杂类型，很容易让人迷惑。最有名的例子就是<strong>方法指针</strong>。如果按照这个结构来，就会得到下面的结果：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br></pre></td></tr></table></figure></p>
<p>在这里，fp 是一个指向函数的指针，编写表达式 (*fp)(a, b)，就会调用这个方法并返回一个 int。这样看起来也没有问题，但如果这里 fp 的参数本身也是一个方法呢？</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span> (*ff)(<span class="keyword">int</span> x, <span class="keyword">int</span> y), <span class="keyword">int</span> b)</span><br></pre></td></tr></table></figure></p>
<p>可读性就不好了。</p>
<p>当然，我们在声明一个方法的时候可以不用写参数的名称，所以 main 方法就可以被声明成：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> *[])</span></span></span><br></pre></td></tr></table></figure></p>
<p>回想一下， argv 参数是这样声明的：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *argv[]</span><br></pre></td></tr></table></figure></p>
<p>你可以删除中间的命名来构造它的类型，尽管你把这个命名放在中间并不明显。</p>
<p>看一下如果把所有参数的名称都删除会变成什么样子：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>), <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p>
<p>不仅不清楚把名字放在哪里：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p>
<p>而且所有方法指针的声明都会变的不清晰，特别是在返回类型也是函数指针的时候：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*(*fp)(<span class="keyword">int</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>), <span class="keyword">int</span>))(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p>
<p>甚至很难看清楚关于 fp 的声明了。</p>
<p>你当然可以用一些很好的例子来反驳我，但上面的这些例子也说明了 C 语法中不好的一些地方。</p>
<p>还有一点需要说明。因为类型和声明语法是相同的，所以很难解析中间有类型的表达式。这就是为什么 C 语言中类型转换总是用括号括起来的原因，如下：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span>)M_PI</span><br></pre></td></tr></table></figure></p>
<h2>Go 语法</h2>
<p>C 语言族以外的语法通常有不同的声明语法。名字通常放在前面，后面通常有一个冒号。因此，我们上面的例子就变成了(用一种虚构但具有说明性的语言)：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x: <span class="keyword">int</span></span><br><span class="line">p: pointer to <span class="keyword">int</span></span><br><span class="line">a: array[<span class="number">3</span>] of <span class="keyword">int</span></span><br></pre></td></tr></table></figure></p>
<p>这些声明是清晰的，只需从左到右读取即可，但有些冗长。Go从这里得到提示，但为了简洁起见，它去掉了冒号并删除了一些关键字：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x <span class="keyword">int</span></span><br><span class="line">p *<span class="keyword">int</span></span><br><span class="line">a [<span class="number">3</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure></p>
<p>这里看不出来 [3]int 的外观以及如何在表达式中使用 a（在下一节中我们会回到指针上）。为了获得清晰将付出一些语法的代价。</p>
<p>现在来看看方法。我们把 main 方法用 Go 语言来转写，尽管实际在 Go 语言中 main 方法是没有参数的：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">(argc <span class="keyword">int</span>, argv []<span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure></p>
<p>表面上看起来和 C 语言没有太多的不同，无非是从 char 数组到 string 数组的转变，但是它可以从左读到右：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">方法 main 有 <span class="keyword">int</span> 和 <span class="keyword">string</span> slice 参数，并且返回一个 <span class="keyword">int</span></span><br></pre></td></tr></table></figure></p>
<p>它们总是排在第一个，去掉参数名也一样清楚，这样就不会混淆了。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, []<span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure></p>
<p>这种从左读到右的风格在参数很复杂的时候也不会变得混乱。下面声明了一个方法变量（类似于 C 语言中的方法指针）：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">int</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure></p>
<p>或者返回一个方法：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">int</span>) <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure></p>
<p>从左到右读起来依然很清晰，声明的名字总是排在前面，很直观。</p>
<p>类型和表达式语法之间的区别使得 Go 在编写和调用闭包很简单：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> a+b &#125; (<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<h2>指针</h2>
<p>指针是一个意外情况。看下面的例子，注意在组数和 slice 中，Go 的声明语法把中括号放在类型的左边，而表达式语法把中括号放在了右边：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">x = a[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>Go 的指针使用了 C语言中的 * 符号，但是我们不能对指针类型进行类似的转换。所以指针是这样声明的：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">x = *p</span><br></pre></td></tr></table></figure></p>
<p>但不能这样用：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">x = p*</span><br></pre></td></tr></table></figure></p>
<p>因为后缀 * 会和乘法的语法冲突。如果不用 * ，我们可以用 Pascal 语言中 ^ 符号，就像下面这样：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p ^<span class="keyword">int</span></span><br><span class="line">x = p^</span><br></pre></td></tr></table></figure></p>
<p>也许我们应该为指针换一个操作符( 并为异或操作选择另一个操作符)，因为类型和表达式上的前缀星号在许多方面把事情变得复杂。例如，有人可能会这样写：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]<span class="keyword">int</span>(<span class="string">"hi"</span>)</span><br></pre></td></tr></table></figure></p>
<p>相反，如果类型以 * 开头，则必须将其括起来：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(*<span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果我们愿意放弃 * 作为指针语法，那么这些括号就没有必要了。</p>
<p>因此，Go 的指针语法与 C语言的指针形式绑定在一起，这种绑定意味着我们还需要使用圆括号来消除类型和表达式的歧义。</p>
<p>尽管如此，我们还是相信 Go 的类型语法比 C 语言更容易理解，特别是当声明变得复杂的时候。</p>
<h2>总结</h2>
<p>总而言之，Go 语言的声明语法是从左读到右。有人认为 C 语言的声明语法有些混乱，详情请看 David Anderson 写的<a href="http://c-faq.com/decl/spiral.anderson.html" target="_blank" rel="noopener">这篇</a>。</p>
<hr>
<p>另外，腾讯云区块链方向在大量招人，包括前端、后端、架构师、产品等诸多岗位，如果感兴趣，请把简历投过来 rayjun0412@gmail.com。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Gson 中的一个坑</title>
    <url>/2020/12/06/Gson-%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</url>
    <content><![CDATA[<p>Gson 是谷歌出品的 json 库，功能强大，也很安全，很少出现安全漏洞，使用的很广泛。Gson 对类型要求的很严格，所以才比较少出现安全漏洞。</p>
<p>但 Gson 使用起来也比较繁琐，没有 fastjson 之类的类库使用起来那么简单，本文介绍一些使用 Gson 在处理字符串类型时需要注意的事项。</p>
<p>本文基于 Gson 2.8.6</p>
<p>先来看段代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">HashMap&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">data.put(<span class="string">"ray"</span>, <span class="string">"jun"</span>);</span><br><span class="line"></span><br><span class="line">String jsonString = gson.toJson(data);</span><br><span class="line">JsonObject jsonObject = gson.fromJson(jsonString, JsonObject.class);</span><br><span class="line"></span><br><span class="line">String str = String.valueOf(jsonObject.get(<span class="string">"ray"</span>));</span><br><span class="line"></span><br><span class="line">assertTrue((str).equals(<span class="string">"jun"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码输出的结果是 <code>false</code>。</p>
<p>再看下面的这段代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">HashMap&lt;String, Integer&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">data.put(<span class="string">"ray"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">String jsonString = gson.toJson(data);</span><br><span class="line"></span><br><span class="line">JsonObject jsonObject = gson.fromJson(jsonString, JsonObject.class);</span><br><span class="line"></span><br><span class="line">Integer integer = Integer.valueOf(String.valueOf(jsonObject.get(<span class="string">"ray"</span>)));</span><br><span class="line"></span><br><span class="line">assertTrue(integer == <span class="number">18</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码输出的结果是 <code>true</code>。这两段代码基本一样，在结果上却不同，下面来看看问题出在哪里。</p>
<p>下面把第一段代码中两个值都打印出来：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = String.valueOf(jsonObject.get(<span class="string">"ray"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"jun"</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jun</span><br><span class="line"><span class="string">"jun"</span></span><br></pre></td></tr></table></figure></p>
<p>第二个值明显和预期的不一样，问题就出在这里。</p>
<p>JsonObject 的 get 方法返回的是一个 JsonElement 的类型，JsonObject 也实现了这个类型，是 Gson 中所有类型的父类。</p>
<p>在上面的代码中，如果直接对 JsonElement 类型使用 String.valueOf，就会调用 JsonElement 方法的 toString 方法，大概代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringWriter stringWriter = <span class="keyword">new</span> StringWriter();</span><br><span class="line">JsonWriter jsonWriter = <span class="keyword">new</span> JsonWriter(stringWriter);</span><br><span class="line">jsonWriter.setLenient(<span class="keyword">true</span>);</span><br><span class="line">Streams.write(<span class="keyword">this</span>, jsonWriter);</span><br><span class="line"><span class="keyword">return</span> stringWriter.toString();</span><br></pre></td></tr></table></figure></p>
<p>相当于会把当前的元素放入 StringWriter 中，然后再调用 StringWriter 的 toString 方法，获得结果。</p>
<p>到这里都没有问题，问题的关键在于对于字符串类型的值，在 JsonElement 中存储时，会在外面再加上一层引号。</p>
<p>所以字符串 &quot;jun&quot; 会被存储为 &quot;&quot;jun&quot;&quot;，所以如果直接使用 toString 方法获得值时，字符串会多一层引号。</p>
<p>对于其他非字符串类型的值，在调用 valueOf 时，反而可以获取到正确的值。</p>
<p>但上面的用法其实都是错误的，如果需要获取特定的值，还是应该使用 Gson 提供的 getAsxx 系列方法。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列-读懂 GC 日志</title>
    <url>/2020/07/25/JVM%E7%B3%BB%E5%88%97-%E8%AF%BB%E6%87%82-GC-%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>Java 生态发展到今天，JVM （Java Virtual Machine）的价值可能已经超过了 Java 语言本身。</p>
<p>而 GC （垃圾回收）机制也是 JVM 的核心之一，在程序运行的过程中，GC 的过程会以日志的形式记录下来，看懂 GC 日志是研究 GC 机制的基础，GC日志也是判断 Java 程序运行是否正常的重要依据。</p>
<p>这篇文章将会从多个方面来详细说明 GC 日志，本文基于 OpenJDK1.8 和 HotSpot 虚拟机。</p>
<p>在开始说明 GC 机制之前，需要先了解一下相关的内容。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">openjdk version <span class="string">"1.8.0_40"</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_40-b25)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.40-b25, mixed mode)</span><br></pre></td></tr></table></figure></p>
<p>上面是使用 <code>java -version</code> 打印出来的信息，里面信息量很大，比如上面表明这个 JDK 是 openjdk1.8，当前 JVM 是 Server VM，使用的是混合执行模式。</p>
<p>JVM 分为 Client VM 和 Server VM，Client VM 适用内存小，适合一些交互性强的场景，比如桌面应用，Server 则适用于内存大的服务端环境。</p>
<p>可以使用下面的命令进行 JVM 的切换。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -client -version</span><br><span class="line">$ java -server -version</span><br></pre></td></tr></table></figure></p>
<p>但是需要注意，<strong>对于 64 位的 JDK，只有 Server VM</strong>， Java 已经放弃桌面应用，以后重点关注 Server VM 就可以。</p>
<p>Java 是一门复杂的语言，既能解释执行，也能编译执行，也可以两种方式共存，默认就是两种方式并存 (<code>mixed mode</code>)，由 JVM 来决定把哪些代码编译执行。</p>
<p>这三种执行方式也可以进行切换：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -Xint -version <span class="comment"># 完全解释执行</span></span><br><span class="line">$ java -Xcomp -version <span class="comment"># 完全编译执行</span></span><br><span class="line">$ java -Xmixed -version <span class="comment"># 混合执行</span></span><br></pre></td></tr></table></figure></p>
<p>Client VM 和 Server VM 的 GC 机制不一样，这篇文章中，我们只关注 Server VM 的 GC。</p>
<h2>JVM 内存模型</h2>
<p>下面这两张图很重要，只要提到 JVM，就会用到下面两张图（HotSpot 虚拟机）。</p>
<p>JVM 内存模型如下：</p>
<p><img src="1.png" alt=""></p>
<p>在 Java 8 以后，使用元空间来实现方法区，并且不占用堆内的空间，而是使用本地内存来实现。</p>
<p>堆内部的各个区域分布如下：</p>
<p><img src="2.png" alt=""></p>
<p>其中 Eden、from 和 to 区域称为新生代（Young）区域，这三个区域大小的比例默认为 8:1:1，整个新生代区域和老年代区域的比例为 1:2。</p>
<h2>GC 基本分类</h2>
<p>GC 总体上可以分成两类，对部分区域的 GC 和整堆的 GC（Full GC），一般情况下，只会发生部分区域的 GC，如果经常发生整堆的 GC，可能存在内存泄漏等情况。</p>
<p>对部分区域的 GC 有可能发生在新生代（Minor GC），也有可能发生老年代（Major GC）。</p>
<p>也有一种特殊的情况，如果使用的是 G1 收集器，那么会同时对新生代和老年代进行 GC。</p>
<p><img src="3.png" alt=""></p>
<p>当我们在说到 JVM 的 GC 时，一般都指对 JVM 堆的回收，大多数情况下，只有堆内的内存才会被回收。</p>
<h2>GC 参数</h2>
<p>默认情况下，Java 程序在运行时并不会打印 GC 日志，需要加上下面的 JVM 参数：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-verbose:gc <span class="comment"># 控制台打印 gc 日志</span></span><br><span class="line">-XX:+PrintGCDetails <span class="comment"># 打印 gc 过程的细节</span></span><br><span class="line">-XX:+PrintGCDateStamps <span class="comment"># 打印 gc 的发生的时间戳</span></span><br></pre></td></tr></table></figure></p>
<p>如果想保存为文件，则需要加上下面的参数，需要注意的是，如果保存为文件，则控制台就不再打印 gc 日志：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xloggc:gc.log <span class="comment"># 将 gc 日志保存成文件，默认在项目的根目录，可以根据项目的情况进行调整</span></span><br></pre></td></tr></table></figure></p>
<p>还有一些其他辅助性的参数:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCApplicationStoppedTime <span class="comment"># 打印 stop world 的时间</span></span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime <span class="comment"># 打印程序未中断运行的时间</span></span><br><span class="line">-XX:+PrintHeapAtGC <span class="comment"># 打印 GC 前后的堆栈信息</span></span><br><span class="line">-XX:+PrintTenuringDistribution <span class="comment"># 打印每次 minor GC 后新的存活周期的阈值</span></span><br></pre></td></tr></table></figure></p>
<h2>认识 GC 日志</h2>
<p>首先来了看一段基本的日志，设置的参数为：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xms8m</span><br><span class="line">-Xmx8m</span><br><span class="line">-verbose:gc</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">-XX:+PrintTenuringDistribution</span><br></pre></td></tr></table></figure></p>
<p>然后执行下面的代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoGC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"No gc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>产生的日志如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2048K, used 1400K [0x00000000ffd80000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 1536K, 91% used [0x00000000ffd80000,0x00000000ffede3d0,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line"> ParOldGen       total 5632K, used 0K [0x00000000ff800000, 0x00000000ffd80000, 0x00000000ffd80000)</span><br><span class="line">  object space 5632K, 0% used [0x00000000ff800000,0x00000000ff800000,0x00000000ffd80000)</span><br><span class="line"> Metaspace       used 3018K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 323K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure></p>
<p>运行上面的代码之后，就会产生上面的日志，上面的日志显示在运行这段代码的时候还没有进行 GC，只是把堆的内存状态打印出来了。</p>
<p>上面的 <code>Heap</code> 表示这是 JVM 的堆，主要分成三个部分，PSYoungGen（新生代），ParOldGen（老年代） 和 Metaspace（元数据空间，也就是方法区）。</p>
<p>需要注意的是，元空间不从堆里面分配内存，而是使用堆外内存，也就是直接从运行的机器上分配内存。但结构上与堆在一起，元空间还有一个名称是非堆。</p>
<p>PSYoungGen  表示的是新生代，并且使用 <strong>Parallel Scavenge</strong> 收集器来 GC，ParOldGen 表示老年代，并且使用 <strong>Parallel old</strong> 收集器来 GC，Server VM 使用的就是这对收集器的组合。</p>
<p>新生代分成 eden、from 和 to 三个区域，from 和 to 区域也称之为 Survivor 区域，在上面的日志中，我们可以看出每个区域所占的大小以及使用情况。</p>
<p>老年代没有再细分为其他的区域，那些在新生代没有被淘汰的的对象会进入老年代。</p>
<h3>发生部分 GC</h3>
<p>执行下面这段代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalGC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object o  = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ;i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">            b = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>产生的 GC 日志如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;Heap before GC invocations=1 (full 0):</span><br><span class="line"> PSYoungGen      total 2048K, used 1536K [0x00000000ffd80000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 1536K, 100% used [0x00000000ffd80000,0x00000000fff00000,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line"> ParOldGen       total 5632K, used 0K [0x00000000ff800000, 0x00000000ffd80000, 0x00000000ffd80000)</span><br><span class="line">  object space 5632K, 0% used [0x00000000ff800000,0x00000000ff800000,0x00000000ffd80000)</span><br><span class="line"> Metaspace       used 3136K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 333K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">[GC (Allocation Failure) </span><br><span class="line">Desired survivor size 524288 bytes, new threshold 7 (max 15)</span><br><span class="line">[PSYoungGen: 1536K-&gt;496K(2048K)] 1536K-&gt;560K(7680K), 0.0024873 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap after GC invocations=1 (full 0):</span><br><span class="line"> PSYoungGen      total 2048K, used 496K [0x00000000ffd80000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 1536K, 0% used [0x00000000ffd80000,0x00000000ffd80000,0x00000000fff00000)</span><br><span class="line">  from space 512K, 96% used [0x00000000fff00000,0x00000000fff7c010,0x00000000fff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 5632K, used 64K [0x00000000ff800000, 0x00000000ffd80000, 0x00000000ffd80000)</span><br><span class="line">  object space 5632K, 1% used [0x00000000ff800000,0x00000000ff810000,0x00000000ffd80000)</span><br><span class="line"> Metaspace       used 3136K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 333K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">&#125;</span><br><span class="line">Total time <span class="keyword">for</span> <span class="built_in">which</span> application threads were stopped: 0.0029243 seconds, Stopping threads took: 0.0000297 seconds</span><br><span class="line">Application time: 1.0001808 seconds</span><br></pre></td></tr></table></figure></p>
<p>先整体来看一下这个日志的结构。</p>
<p>最前面一部分是进行 GC 之前堆内存的分配情况，invocations 表示垃圾回收的次数，括号里面是发生 Full GC 的次数。</p>
<p>然后就是 GC 回收的细节，下面详细说，再然后是 GC 之后堆的内存分配情况，与 GC 的之前堆的情况可以有个对比。</p>
<p>倒数第二行是 <code>PrintGCApplicationStoppedTime</code> 参数打印出来的信息，表示因为 GC 而产生的停顿时间。最后一行是 <code>PrintGCApplicationConcurrentTime</code> 参数所打印出来的信息，表示程序运行的时间。</p>
<p>下面来看 GC 的回收细节，通过上面的日志可以看到新生代的 eden 区已经满了，然后就出现了下面这条日志:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) </span><br><span class="line">Desired survivor size 524288 bytes, new threshold 7 (max 15)</span><br><span class="line">[PSYoungGen: 1536K-&gt;496K(2048K)] 1536K-&gt;560K(7680K), 0.0024873 secs] </span><br><span class="line">[Times: user=0.01 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure></p>
<p>这条日志就是在新生代进行了 minor GC。</p>
<p>第一行表示发起这次 GC 的原因是分配新的内存失败（Allocation Failure），第二行是因为我们加上了 <code>-XX:+PrintTenuringDistribution</code> 这个参数，它会打印出新生代对象的年龄，以及对象进入老年代的年龄阈值，这里默认是 7，最大是 15 ，可以通过参数进行调整。</p>
<p>第三行就是具体的回收信息，PSYoungGen 表示这是发生在新生代的回收，分开来看各部分：</p>
<ul>
<li>1536K-&gt;496K(2048K) 表示：<strong>回收前该区域已使用的空间→回收后该区域使用的空间(该区域总空间)</strong>，这里是指新生代区域</li>
<li>1536K-&gt;560K(7680K) 表示：<strong>回收前堆中已使用的空间→回收后堆中已使用的空间(堆的总空间)</strong></li>
<li>0.0024873 secs：表示 GC 进行的时间，单位为秒</li>
<li>Times: user=0.01 sys=0.00, real=0.01 secs： 这部分也是对 GC 时间进行统计，但是是从操作系统的角度来统计，分被表示用户态时间，内核态时间和时钟时间</li>
</ul>
<h3>发生 Full GC</h3>
<p>执行下面的代码就会发生 Full GC：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullGC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line"></span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Full GC 其他的部分与上面部分 GC 基本一致，下面重点来看发生 Full GC 时，各个区域的回收情况：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Full GC (System.gc()) </span><br><span class="line">[PSYoungGen: 480K-&gt;0K(2048K)] </span><br><span class="line">[ParOldGen: 1104K-&gt;473K(5632K)] </span><br><span class="line">1584K-&gt;473K(7680K),</span><br><span class="line">[Metaspace: 3107K-&gt;3107K(1056768K)], </span><br><span class="line">0.0055681 secs] </span><br><span class="line">[Times: user=0.02 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure></p>
<p>第一行是表示这次发生的是 Full GC，发起的原因是调用了 System.gc()。</p>
<p>第二行和第三行分别表示对新生代和老年代的回收，回收先后各个区域占用的内存情况都会打印出来。</p>
<p>第四行同样表示整个堆内存的回收情况。</p>
<p>第五行表示对元空间也进行了垃圾回收，虽然什么也没有回收成功。</p>
<h3>如果内存泄露或溢出</h3>
<p>OutOfMemoryError 是一种常见的错误，一般在抛出这个异常之前，都会出现一次 Full GC。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leak2GC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Vector strings = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  ;i++) &#123;</span><br><span class="line">            String str = <span class="keyword">new</span> String(<span class="string">"Hello gc"</span> + i);</span><br><span class="line">            strings.add(str);</span><br><span class="line">            str = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行上面的代码之后，就会出现下来的日志：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Full GC (Allocation Failure) </span><br><span class="line">[PSYoungGen: 943K-&gt;943K(2048K)] </span><br><span class="line">[ParOldGen: 5556K-&gt;5539K(5632K)] </span><br><span class="line">6499K-&gt;6483K(7680K), </span><br><span class="line">[Metaspace: 3135K-&gt;3135K(1056768K)],</span><br><span class="line">0.0260635 secs]</span><br><span class="line">[Times: user=0.14 sys=0.00, real=0.03 secs]</span><br></pre></td></tr></table></figure></p>
<p>即使进行了 Full GC，也无法对各个区域进行有效的回收，在无法回收空间之后，就会报出下面的错误：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">	at java.util.Vector.grow(Vector.java:266)</span><br><span class="line">	at java.util.Vector.ensureCapacityHelper(Vector.java:246)</span><br><span class="line">	at java.util.Vector.add(Vector.java:782)</span><br><span class="line">	at cn.rayjun.java.java8.gc.Leak2GC.main(Leak2GC.java:12)</span><br></pre></td></tr></table></figure></p>
<h2>GC 信息统计分析</h2>
<p>通过上面的内容，应该就可以看懂 GC 的日志信息了，在很多情况下，我们通过部分的日志无法判断问题。</p>
<p>所以就有必要对整体的 GC 情况进行统计，一般会借助其他的统计工具来进行。</p>
<p>最直接的方式就是使用 JDK 的内置工具，jstat ，具体使用如下，参数为 pid。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jstat -gc 24991</span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">512.0  512.0   0.0    0.0    1536.0   1024.0    5632.0     4755.0   4864.0 3477.4 512.0  378.3      54    0.082   1      0.018    0.099</span><br></pre></td></tr></table></figure></p>
<p>各个数据项的含义如下：</p>
<ul>
<li>S0C：from 区的大小</li>
<li>S1C：to 区的大小</li>
<li>S1U：from 区使用的大小</li>
<li>S1U：to 去使用的大小</li>
<li>EC：eden 区的大小</li>
<li>EU：eden 去使用的大小</li>
<li>OC：老年代的大小</li>
<li>OU：老年代使用的大小</li>
<li>MC：方法区的大小</li>
<li>MU：方法区使用的大小</li>
<li>CCSC：压缩类空间大小</li>
<li>CCUS：压缩类空间使用的大小</li>
<li>YGC：年轻代垃圾回收的次数</li>
<li>YGCT：年轻代垃圾回收消耗时间</li>
<li>FGC：老年代垃圾回收的次数</li>
<li>FGCT：老年代垃圾回收消耗时间</li>
<li>GCT：垃圾回收的总时间</li>
</ul>
<p>也可以使用可视化的分析工具来对 CG 日志进行分析，比如 <a href="https://gceasy.io/" target="_blank" rel="noopener">https://gceasy.io/</a>。</p>
<h2>如果使用其他的收集器</h2>
<p>在上面的日志中，GC 使用的是默认收集器组合，我们也可以使用其他的收集器来，比如使用 <code>UseConcMarkSweepGC</code> 参数来启用 CMS收集器。</p>
<p>使用了这个收集器之后，日志如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew: 1384K-&gt;256K(2432K), 0.0022504 secs] 1384K-&gt;491K(7936K), 0.0022693 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</span><br><span class="line">[Full GC (System.gc()) [CMS: 235K-&gt;472K(5504K), 0.0016647 secs] 1582K-&gt;472K(7936K), [Metaspace: 3009K-&gt;3009K(1056768K)], 0.0016851 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure></p>
<p>稍微有了一点变化，新生代的收集器使用了  ParNew 收集器，老年代使用了 CMS收集器，日志其他部分的含义没有变化。</p>
<p>也可以根据自己的需求去使用其他的收集器。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中的反射是什么</title>
    <url>/2020/10/16/Java-%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>反射是一个程序语言用来自检和修改自身结构和行为的过程。</p>
<p>这么说可能有些晦涩，反射可以理解为在程序运行过程中，获取程序的<strong>结构信息</strong>，从而根据不同的情况来调整程序的行为。</p>
<p>在使用汇编语言编程的时代，汇编语言可以直接获取任何信息，可以认为汇编语言天然就支持反射。但是到后来的一些高级语言，比如 Fortran 和 C 语言等等，由于不支持反射，也就无法获取信息。</p>
<p>再到后续的 Java，C# 等语言中都自带了反射框架，这些语言就可以通过反射来实现通用的框架，比如在 Java 的 Spring 中就大量使用了反射。</p>
<p>这篇文章重点介绍 Java 中的反射。</p>
<p>本文基于 OpenJDK11</p>
<h2>1. 反射能干什么</h2>
<p>在 Java 中，反射可以获取类的定义、属性和方法，并且可以调用这些方法，或者构造对象，甚至可以在运行时修改类的定义。</p>
<p>先来看一个简单的例子，通过这个例子可以知道反射能做什么，例子中的代码下面会详细讲解：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用反射来执行方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">methodInvoke</span><span class="params">(Object o, Method method, Object[] params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(o, params);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用反射来生成 <code>ArrayList</code> 对象并调用方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 ArrayList 的 Class 对象和构造函数，并生成对象</span></span><br><span class="line">Class clazz = ArrayList.class;</span><br><span class="line">Constructor&lt;ArrayList&gt; constructor = clazz.getConstructor();</span><br><span class="line">ArrayList instance = constructor.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 add 方法，并调用 add 方法添加元素</span></span><br><span class="line">Method add = clazz.getDeclaredMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">Object[] params = &#123;<span class="string">"reflection"</span>&#125;;</span><br><span class="line">methodInvoke(instance, add, params);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 get 方法，并调用 get 方法获取刚刚添加的元素</span></span><br><span class="line">Method get = clazz.getDeclaredMethod(<span class="string">"get"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">Object[] params1 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">System.out.println(methodInvoke(instance, get, params1));</span><br></pre></td></tr></table></figure></p>
<p>如果不使用反射，这个代码很简单：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"reflection"</span>);</span><br><span class="line">System.out.println(list.get(<span class="number">0</span>));</span><br></pre></td></tr></table></figure></p>
<p>反射这么麻烦，为什么还要使用它？</p>
<p>观察一下上面利用反射来执行方法的代码可以发现，<strong>执行任何类的方法，那段代码都不需要修改，而且更重要的是，具体执行的方法还可以在程序运行的过程中改变</strong>。</p>
<p>反射用起来虽然麻烦，但是反射的动态性提高了 Java 的灵活性，很多框架都依赖反射。</p>
<h2>2. 相关概念</h2>
<p>在 Java 中，有很多的类，每个类都有自己的属性，方法，构造函数等等信息，这些信息都需要通过一种方式表示，在 Java 中就是通过 Class 对象来表示。</p>
<p>这里不要把 Class 与 Object 混在一起，Object 是所有类的父类，而 Class 类则不一样，在每个类中，都有一个 Class <strong>对象</strong>来保存类的信息。即使对于 Java 中的原生数据类型，也有自己的 class 对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = <span class="keyword">int</span>.class;</span><br></pre></td></tr></table></figure></p>
<p>每个 Class 对象中都有主要有三个主要部分：Field、Method 和 Constructor。这些和反射相关的类都在 <strong>java.lang.reflect</strong> 包下。</p>
<p>Method 和 Constructor 在上面的代码中都看到了，分别表示类的方法和构造函数。Field 则表示类的属性。</p>
<p>除了上面这些信息外，还有其他的信息，比如判断属性或者方法是否能访问，获取类、方法、属性的注解等等：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method add = clazz.getDeclaredMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">add.isAccessible(); <span class="comment">// 判断是否能访问</span></span><br></pre></td></tr></table></figure></p>
<p>即使对于私有方法或者属性，也可以通过下面的方式来访问：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method add = clazz.getDeclaredMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">add.setAccessible(<span class="keyword">true</span>); <span class="comment">// 通过这个设置，即使私有方法也能访问</span></span><br></pre></td></tr></table></figure></p>
<p>在 Java 中，注解用的很多，实际上，注解本身并没有包含额外的内容，只是起到标记的作用，所有的注解都可以通过反射来获取，然后再进行相应的逻辑处理。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method add = clazz.getDeclaredMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">add.getDeclaredAnnotations(); <span class="comment">// 获取该方法所有的注解</span></span><br></pre></td></tr></table></figure></p>
<p>还可以获取方法的参数，返回值的类型等等信息。</p>
<p>所以总的来说，<strong>反射是一个框架，可以帮助获取程序内部的信息</strong>，至于获取这些信息来做什么，就看开发人员的发挥。</p>
<p>反射虽然很强大，但是性能上相比于普通方式性能上难免会有一些损失，需要注意，在程序执行的过程中，需要尽量少用反射。而且反射连私有方法都可以访问，如果滥用就可能造成程序的不安全。</p>
<h2>3. 反射的基本用法</h2>
<p>使用行业的第一步，就是获取目标类型的 Class 对象，如果获取不到，那就说明目标类型无法完成类加载，也就不能进行后续的反射操作。</p>
<h3>获取 Class 对象的方法</h3>
<p>有 4 种方法可以获取 Class 对象。</p>
<p>通过类的 class 属性:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz1 = String.class;</span><br></pre></td></tr></table></figure></p>
<p>通过 Class.forName() 方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz2 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过对象的 getClass() 方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz3 = <span class="string">"string"</span>.getClass();</span><br></pre></td></tr></table></figure></p>
<p>对于基本类型的包装类，还有一种方法可以获取 Class 对象：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz4 = Integer.TYPE;</span><br></pre></td></tr></table></figure></p>
<h3>创建对象</h3>
<p>在获取到 Class 对象之后就可以创建对象了，创建对象有两种方式。</p>
<p>通过 Class 对象直接生成：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = String.class;</span><br><span class="line">String str = (String) clazz.newInstance();</span><br></pre></td></tr></table></figure></p>
<p>通过构造函数生成：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;String&gt; constructor = clazz.getConstructor();</span><br><span class="line">String str1 = constructor.newInstance();</span><br></pre></td></tr></table></figure></p>
<p>如果构造函数有参数：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;String&gt; constructor2 = clazz.getConstructor(String.class);</span><br><span class="line">String str2 = constructor2.newInstance(<span class="string">"String"</span>);</span><br></pre></td></tr></table></figure></p>
<h3>调用方法</h3>
<p>在生成了对象之后，自然就可以调用方法，调用的方式和上面的代码一样。</p>
<p>首先获取 Method，如果方法没有参数，直接获取执行就可以：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method lengthMethod = clazz.getMethod(<span class="string">"length"</span>);</span><br><span class="line">lengthMethod.invoke(str2);</span><br></pre></td></tr></table></figure></p>
<p>如果有参数，在获取方法的时候就需要声明方法的类型和个数，而且参数的顺序不能乱：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method substringMethod = clazz.getMethod(<span class="string">"substring"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">substringMethod.invoke(str2, <span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<h3>其他工具方法</h3>
<p>上面是反射的一些基本用法，当然反射也提供了其他的一些工具方法。</p>
<p>获取所有已经声明的属性、方法和构造函数，包括 <code>private</code> 的也会被获取出来：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">Constructor[] constructors = clazz.getDeclaredConstructors();</span><br></pre></td></tr></table></figure></p>
<p>判断是否是内部类：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clazz.isMemberClass();</span><br></pre></td></tr></table></figure></p>
<p>还有其他判断是否接口、注解，获取类的泛型信息等等方法。</p>
<p>文 / Rayjun</p>
<h2>REF</h2>
<p>[1] <a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reflection_(computer_programming)</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列-JVM参数手册</title>
    <url>/2020/08/01/JVM%E7%B3%BB%E5%88%97-JVM%E5%8F%82%E6%95%B0%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>有时候找到了一个JVM参数，以为找到了一份武林秘籍，就偷偷在服务器把参数加上，结果第二天就收获一个事故通报。</p>
<p>本文对常用 JVM 常用参数做了一个整理，但是参数的使用很复杂，本文仅仅提供常用参数的查阅，具体的使用还是需要根据具体的情况。</p>
<p>JVM 是一个开放的标准，谁可以来实现 JVM，这导致不同JVM 实现的参数有所不同，本文基于 Hotspot 虚拟机。</p>
<p>JVM 参数很多，总体上可以分成三类：</p>
<ul>
<li><code>-</code>：标准参数，比如 <code>-verbose:gc</code> 这类表示标准实现，所有的虚拟机都需要实现这些参数的功能，且向后兼容</li>
<li><code>-X</code>：非标准参数，默认 JVM 会实现这些参数的功能，但是不保证所有的 JVM 实现都满足，且不保证向后兼容</li>
<li><code>-XX</code>：非 Stable 参数，这些参数在不同的 JVM 上会有不同的实现，这些参数不推荐在生成环境中使用，以后很有可能会被取消
<ul>
<li>对于布尔型参数：<code>-XX:+</code> 表示打开，<code>-XX:-</code> 表示关闭，比如: -XX:+PrintGCDetails</li>
<li>对于其他的数字或者字符参数：<code>-XX:</code> 表示设定一个值</li>
</ul>
</li>
</ul>
<h2>通用参数</h2>
<table>
<thead>
<tr>
<th>JDK8</th>
<th>JDk9 Or Later</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>-verbose:class</td>
<td>-verbose:class</td>
<td>输出 jvm 载入类的相关信息， 可用于排查找不到类或者类冲突问题</td>
</tr>
<tr>
<td>-verbose:gc</td>
<td>-verbose:gc</td>
<td>输出 GC 信息，当日志被保存为文件时，这个参数无效</td>
</tr>
<tr>
<td>-verbose:jni</td>
<td>-verbose:jni</td>
<td>输出 native 方法的调用情况，用于排查 JNI 调用问题</td>
</tr>
<tr>
<td>-Xms</td>
<td>-Xms</td>
<td>初始堆大小，默认物理内存的 1/64</td>
</tr>
<tr>
<td>-Xmx</td>
<td>-Xmx</td>
<td>最大堆大小，默认为物理内存的 1/4</td>
</tr>
<tr>
<td>-Xmn</td>
<td>-Xmn</td>
<td>新生代大小</td>
</tr>
<tr>
<td>-Xss</td>
<td>-Xss</td>
<td>堆栈大小，JDK5 以后，每个线程的对接默认为 1 M</td>
</tr>
<tr>
<td>-Xnoclassgc</td>
<td>-Xnoclassgc</td>
<td>关闭对类的回收</td>
</tr>
<tr>
<td>-XX:MaxMetaspaceSize</td>
<td>-XX:MaxMetaspaceSize</td>
<td>元空间的最大值</td>
</tr>
<tr>
<td>-XX:MetaspaceSize</td>
<td>-XX:MetaspaceSize</td>
<td>指定元空间触发 Full GC 的阈值，也就是默认元空间的大小</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>-XX:SurvivorRatio</td>
<td>新生代中 Eden 与 Survivor 的比值，默认为 8，Survivor 有两块空间， from 和 to，实际上，Eden 与 Survivor 的比值大小为 8 : 2</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>-XX:NewRatio</td>
<td>新生代和老年代空间的比值</td>
</tr>
<tr>
<td>-XX:LargePageSizeInBytes</td>
<td>-XX:LargePageSizeInBytes</td>
<td>设置用于Java堆的大页面尺寸</td>
</tr>
<tr>
<td>-XX:+UseLargePages</td>
<td>-XX:+UseLargePages</td>
<td>使用大页面内存</td>
</tr>
<tr>
<td>-XX:MaxHeapFreeRatio</td>
<td>-XX:MaxHeapFreeRatio</td>
<td>GC后java堆中空闲量空间的最大占比</td>
</tr>
<tr>
<td>-XX:MinHeapFreeRatio</td>
<td>-XX:MinHeapFreeRatio</td>
<td>GC后java堆中空闲量空间的最小占比</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>-XX:NewSize</td>
<td>新生代对象生成时占用内存的默认值</td>
</tr>
<tr>
<td>-XX:MaxNewSize</td>
<td>-XX:MaxNewSize</td>
<td>新生成对象能占用内存的最大值</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>-XX:MaxPermSize</td>
<td>老生代对象能占用内存的最大值</td>
</tr>
<tr>
<td>-XX:ThreadStackSize</td>
<td>-XX:ThreadStackSize</td>
<td>设置线程栈大小，若为0则使用系统默认值</td>
</tr>
</tbody>
</table>
<h2>GC 参数</h2>
<p>在 JDK9 以后，日志相关的参数的都统一到了 <code>-Xlog</code> 中，注意，不仅仅 gc 的日志，是所有的日志，对于 -Xlog，配置方法如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xlog[:[selector][:output[:[decorators][:output-options]]]]</span><br></pre></td></tr></table></figure></p>
<p>其中 selector 是 tag 和日志 level 的组合体，tag 就是日志类别，gc 只是其中的一种 tag，如果要输出 GC 日志，使用方式如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xlog:gc</span><br></pre></td></tr></table></figure></p>
<p>level 的取值有：off，trace，debug，info，warning，error。</p>
<p>output 就是日志的输出形式，可以使用的方式有:</p>
<ul>
<li>stdout</li>
<li>stderr</li>
<li>file=</li>
</ul>
<p>decorators 称之为装饰器，可以在 GC 日志中增加其他的信息，方便对问题进行定位，装饰器可以同时使用多个，下面是对装饰器的汇总：</p>
<table>
<thead>
<tr>
<th>全名</th>
<th>缩写</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>hostname</td>
<td>hn</td>
<td>机器名称</td>
</tr>
<tr>
<td>level</td>
<td>l</td>
<td>日志等级</td>
</tr>
<tr>
<td>pid</td>
<td>p</td>
<td>进程标识符</td>
</tr>
<tr>
<td>tid</td>
<td>ti</td>
<td>线程标识符</td>
</tr>
<tr>
<td>tags</td>
<td>tg</td>
<td>与消息相关联的所有标签</td>
</tr>
<tr>
<td>time</td>
<td>t</td>
<td>当前时间和日期为ISO-8601格式（例如：2020-07-31T18：42：58.418 + 0000）</td>
</tr>
<tr>
<td>timemillis</td>
<td>tm</td>
<td>当前时间以毫秒为单位，与System.currentTimeMillis()生成的值相同</td>
</tr>
<tr>
<td>timenanos</td>
<td>tn</td>
<td>当前时间以纳秒为单位，与System.nanoTime()生成的值相同</td>
</tr>
<tr>
<td>uptime</td>
<td>u</td>
<td>自JVM启动以来运行的时间，以秒为单位</td>
</tr>
<tr>
<td>uptimemillis</td>
<td>um</td>
<td>自JVM启动以来运行的毫秒数</td>
</tr>
<tr>
<td>uptimenanos</td>
<td>un</td>
<td>自JVM启动以来运行的纳秒数</td>
</tr>
<tr>
<td>utctime</td>
<td>utc</td>
<td>当前时间和日期，UTC 格式，例如：2020-07-31T12：42：58.418-0600）</td>
</tr>
</tbody>
</table>
<p>在默认情况下，会使用 uptime，level 以及 tags 等装饰器，也可以使用 none 来关闭所有的装饰器。</p>
<p>假如说现在要获取日志等级为info，需要打印机器名称、日志等级，JVM 的运行时间，所属 tag，并且要把这些日志保存为 gc.log 文件，配置如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xlog:gc*=info:file=gc.log:hostname,level,uptime,tags</span><br></pre></td></tr></table></figure></p>
<p>常用的 GC 日志参数如下：</p>
<h3>GC日志参数</h3>
<table>
<thead>
<tr>
<th>JDK8</th>
<th>JDk9 Or Later</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+PrintGC</td>
<td>-Xlog:gc</td>
<td>打印 GC 信息</td>
</tr>
<tr>
<td>-XX:+PrintGCDeatils</td>
<td>-Xlog:gc*</td>
<td>打印 GC 详细信息</td>
</tr>
<tr>
<td>-XX:+PrintGCTimeStamps</td>
<td>uptime</td>
<td>装饰器	打印 GC 过程中具体的时间戳</td>
</tr>
<tr>
<td>-XX:+PrintHeapAtGC</td>
<td>-Xlog:gc+heap=trace</td>
<td>打印 GC 前后堆的详细信息</td>
</tr>
<tr>
<td>-XX:+PrintGCApplicationStoppedTime</td>
<td>-Xlog:safepoint</td>
<td>打印 GC 期间程序暂停的时间</td>
</tr>
<tr>
<td>-XX:+PrintGCApplicationConcurrentTime</td>
<td>-Xlog:safepoint</td>
<td>打印 GC 前，程序未中断的执行时间</td>
</tr>
<tr>
<td>-Xloggc:filename</td>
<td>-Xlog:gc:file=gc.log</td>
<td>GC 日志的保存为文件，默认为项目根目录</td>
</tr>
<tr>
<td>-XX:+PrintTenuringDistribution</td>
<td>-Xlog:gc+age*=trace</td>
<td>查看对象存在于新生代所经历 Minor GC 次数的阈值</td>
</tr>
<tr>
<td>-XX:PrintReferenceGC</td>
<td>-Xlog:gc+ref*=debug</td>
<td>打印软引用、弱引用、虚引用和Finallize队列</td>
</tr>
<tr>
<td>-XX:+PrintTLAB</td>
<td>-XX:+PrintTLAB</td>
<td>打印 TLAB 信息</td>
</tr>
</tbody>
</table>
<h3>其他GC参数</h3>
<table>
<thead>
<tr>
<th>JDK8</th>
<th>JDk9 Or Later</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>-XX:MaxTenuringThreshold</td>
<td>对象存在于新生代所能经历 Minor GC 的最大次数</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>-XX:PretenureSizeThreshold</td>
<td>超出该大小的对象直接在老年代分配，单位字节</td>
</tr>
<tr>
<td>-XX:+UseSerialGC</td>
<td>-XX:+UseSerialGC</td>
<td>使用 serial 和 serial old 收集器（client VM 的默认值）</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>-XX:+UseParallelGC</td>
<td>使用 parallel 和 parallel old 收集器（serverVM 的默认值）</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>-XX:+UseConcMarkSweepGC</td>
<td>使用 ParNew 和 CMS 收集器</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>-XX:+UseParNewGC</td>
<td>使用 ParNew 和 serial old 收集器（已不推荐）</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>-XX:ParallelGCThreads</td>
<td>并行收集的线程数，最好与 CPU 数量相同</td>
</tr>
<tr>
<td>-XX:GCTimeRatio</td>
<td>-XX:GCTimeRatio</td>
<td>设置并行收集器的吞吐量，如 99 表示 1 /(1+99) = 1 %,表示 GC 只能占用 1 % 的时间，满足不了则会缩小 新生代空间</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>-XX:MaxGCPauseMillis</td>
<td>每次年轻代垃圾回收的最长时间</td>
</tr>
<tr>
<td>-XX:CMSFullGCsBeforeCompaction</td>
<td>-XX:CMSFullGCsBeforeCompaction</td>
<td>设置在 n 次 CMS 垃圾收集后，触发一次内存整理</td>
</tr>
<tr>
<td>-XX:UseCMSCompactAtFullCollection</td>
<td>-XX:UseCMSCompactAtFullCollection</td>
<td>每次 FullGC 后都会触发内存整理</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction</td>
<td>-XX:CMSInitiatingOccupancyFraction</td>
<td>触发CMS收集的内存比例</td>
</tr>
<tr>
<td>-XX:+DisableExplicitGC</td>
<td>-XX:+DisableExplicitGC</td>
<td>禁用 System.gc()</td>
</tr>
<tr>
<td>-XX:+CollectGen0First</td>
<td>-XX:+CollectGen0First</td>
<td>Full GC 前是否先进行 YGC</td>
</tr>
</tbody>
</table>
<h2>REF</h2>
<p>[1] <a href="https://openjdk.java.net/jeps/158" target="_blank" rel="noopener">https://openjdk.java.net/jeps/158</a></p>
<p>[2] <a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></p>
<p>[3] <a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p>
<p>[4] <a href="https://segmentfault.com/a/1190000013475524" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013475524</a></p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO 流简介</title>
    <url>/2018/07/24/Java-IO-%E6%B5%81%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>IO 在 Java 中占据了很重要的位置。在 Java 中，Java 可以分为以下几类:</p>
<ul>
<li>BIO</li>
<li>NIO</li>
<li>AIO</li>
</ul>
<p>上面的 IO 可以根据分类分成同步阻塞IO、同步非阻塞 IO 和异步非阻塞 IO。</p>
<p>BIO 就是 Blocking IO，也就是同步阻塞 IO。java.io 中的所有 API 和 java.net 中的部分 API 都算是同步阻塞型 API。</p>
<p>在 Java1.4 中添加了 NIO( Non-blocking IO)，也就是 同步非阻塞 IO，在 NIO 中添加了 Channel 等特性，通过这些可以构建多路复用的、同步非阻塞的 IO 程序。</p>
<p>在 Java1.7 中添加了 NIO2，也被称之为 AIO(Asynchronous IO)，这就是异步非阻塞的方式。异步 IO 操作是基于事件和回调机制实现的。</p>
<h3>BIO 基础</h3>
<p>java.io 中的 API 使用起来简单、直观，但是 IO 的效率和扩展性有着局限性。下图是对 java.io 中的主要的 API 做的一个分类：</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/Java/io/io-simple.png" alt=""></p>
<p>java.io 中的 API 大体上可以分成两类，一类是<strong>字符流</strong>，一类是<strong>字节流</strong>。字节流类的 API 更适合操作整个文件，比如图片文件。字符流类的接口是直接操作字符的，这类的接口更适合从文件中读取或者写入文本信息。</p>
<p>在 java.net 中，<strong>Socket</strong>通信等相关的 API 也都是 BIO 。</p>
<h3>NIO 基础</h3>
<p>对于一个传统基于 BIO的 CS（Client-Server） 应用程序，为了更高的并发量，那么就需要减少线程被创建的次数和数量。这个时候就需要使用线程池的机制来提高并发量，通过一个固定大小的线程池，来负责管理线程，避免线程被反复的创建和销毁。</p>
<p>但是这种方案还是不能够彻底解决问题，用户数量不多时，这种模式可以很好的工作，如果并发量很高，那这样的方案还是有很大的问题的，因为线程的上下文切换的过程所耗费的时间在高并发的会非常的明显。这种 BIO 的程序可以表示如下：</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/Java/io/bio.png" alt=""></p>
<p>所以在依赖 java.io 相关的 API 本身已经没有办法可以解决这些问题了，这也是 NIO 被设计出来的目的。</p>
<p>在 NIO 引入了多路复用的机制，一种与 BIO 完全不同的思路。在具体说明 NIO 的思路之前，NIO 中三个关键的概念需要先理解一下：</p>
<ul>
<li><strong>Buffer</strong>： NIO 中的数据容器，除了布尔类型，其他所有的原始数据都有相应的实现</li>
<li><strong>Channel</strong>: NIO 中用来支持批量 IO 操作的一种抽象，相比于 <strong>File</strong> 和 <strong>Socket</strong> 的实现，Channel 的实现则更加接近操作系统的底层，这也就使得 NIO 能够充分使用操作系统的底层。</li>
<li><strong>Selector</strong>: Selector 是 NIO 实现多路复用的基础，每一个 Channel 都需要注册在一个 Selector 上，Selector 可以实时监测 Channel 的状态，进而实现单线程对多个 Channel 的管理。</li>
</ul>
<p>在同样的一个 CS 应用程序来说，NIO 比 BIO 更有效率的地方就是利用单线程轮询的方式来确定需要处理的 Channel，整体上是同步非阻塞的，可以避免在大量客户端连接时频繁切换线程带来的问题。 使用 NIO 来实现这个应用程序可以设计如下：</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/Java/io/NIO.png" alt=""></p>
<h3>NIO2（AIO）</h3>
<p>在 Java1.7 中，又添加了一种新的 IO，利用事件和回调来处理消息的接收和发送。AIO 是一种异步非阻塞的 IO 机制。</p>
<p>AIO 的基本抽象与 NIO 非常相似。与 NIO 不同的地方在于不再是通过轮询的方式去确定是否继续后续的操作，而是通过事件机制来实现这一点。</p>
<p>（完）</p>
<p><strong>参考文献</strong>：</p>
<ol>
<li>极客时间专栏 <strong>Java 核心技术36讲</strong></li>
<li>Java 官方文档</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 为什么需要包装类</title>
    <url>/2020/05/10/Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<p>在 Java 的世界中，对象是一等公民，但 Java 也还是做出了妥协，出于对性能的考虑而保留了 8 种基础数据类型。
但是在某些场景下，无法直接使用基本数据类型，所以还是需要使用对象，Java 的包装类就是这样出现的。</p>
<p>## 自动装箱和拆箱</p>
<p>看下面的代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">list.add(i); <span class="comment">// 装箱;</span></span><br></pre></td></tr></table></figure></p>
<p>Java 编译器会自动把基本数据类型转成对象，这个称之为<strong>装箱</strong>。 到底是怎么做到的呢？看下面的字节码：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">12: invokestatic  #3                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">15: invokevirtual #10                 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
简单解释一下 <code>invokestatic</code> 和 <code>invokevirtual</code>，这两个都是 JVM 的指令，前者表示调用 Java 的
静态方法，后者表示调用对象方法。</p>
<p>invokestatic 调用了 Integer.valueOf() 方法，所以装箱实际上就是调用了 <code>Integer.valueOf()</code> 方法。</p>
<p><strong>拆箱</strong>也很简单，看下面的代码：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">1</span>; <span class="comment">// 拆箱;</span></span><br></pre></td></tr></table></figure>
拆箱的字节码如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  7: invokevirtual #2                  // Method java/lang/Integer.intValue:()I</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
同理，拆箱实际调用的是 Integer 对象方法 <code>i.intValue()</code>。</p>
<p>从上文可以看出，Java 中基本类型的装箱和拆箱实际上是编译器提供的语法糖，是在编译器层面进行处理的，编译器会将装箱和拆箱编译成调用方法的字节码。在虚拟机层，通过调用方法来实现包装类的装箱和拆箱。</p>
<p>Byte，Short，Long，Float，Double，Boolean，Character 与 Integer 类似。</p>
<p>但是需要注意，还有一个特殊的包装类 Void。 Void 是 void 的包装类，Void 不能被继承，也不能被实例化，仅仅就是一个占位符。</p>
<p>如果一个方法使用 void 修饰，说明方法没有返回值，如果使用 Void 修饰，则该方法只能返回 null。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Void <span class="title">nullFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回其他值会编译不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Void 常用于反射中，判断一个方法的返回值是不是 void。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : VoidDemo.class.getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
## 包装类的缓存
先看下面的代码：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">200</span>;</span><br><span class="line">Integer i2 = <span class="number">200</span>;</span><br><span class="line">System.out.println(i2 == i1); <span class="comment">// false</span></span><br><span class="line">Integer i3 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">System.out.println(i3 == i4); <span class="comment">// false</span></span><br><span class="line">Integer i5 = <span class="number">100</span>;</span><br><span class="line">Integer i6 = <span class="number">100</span>;</span><br><span class="line">System.out.println(i5 == i6); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
上面的代码应该算是一道经典的面试题了。通过上文可知，装箱操作使用的是 <code>Integer.valueOf()</code> 方法，源码如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键实现在 IntegerCache 中，在某个范围内的数值可以直接使用已经创建好的对象。IntegerCache 是一个静态内部类，而且不能实例化，仅仅用来缓存 Integer 对象：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>; <span class="comment">// 缓存对象的最小值，不能配置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>; <span class="comment">// 缓存对象的最大值可以配置，但是不能超过 Integer的最大值，不能小于 127</span></span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>缓存对象的默认大小范围是 -128 ~ 127，正数范围可以根据自己的需要进行调整，负数最小就是 -128，不可以调整。如果不在这个范围内，就会创建新的对象。</p>
<p>上面代码的结果就很清晰了，第一个结果为 false 是因为 200 超出了默认的缓存范围，因此会创建新的对象。第二个结果为 false 是因为直接使用 new 来创建对象，而没有使用缓存对象。第三个结果为 true 是因为刚好在缓存的范围内。</p>
<p>所以在使用 Integer 等包装类生成对象时，不要使用 new 去新建对象，而应该尽可能使用缓存的对象，而且比较两个 Integer 对象时不要使用 ==，而应该使用 equals。</p>
<p>其他的包装类的实现基本类似，只是在对象缓存上的实现有些不同：</p>
<p>- Byte 的范围刚好是 -128~127，所以都可以直接从缓存中获取对象。
- Short 缓存范围也是 -128 ~ 127，而且不可以调整。
- Long 的实现与 Short 一致。
- Character 因为没有负数，所以缓存范围是 0 ~ 127，也不可以调整范围。
- Boolean 的值只有 true 和 false，在类加载的时候直接创建好。
- Float，Double 则没有缓存机制，因为是浮点数，可以表示无穷无尽的数，缓存的意义不大。</p>
<p>## 小心空指针
此外还需要注意的一点就是，使用包装类生成的是对象，是对象就有可能出现空指针异常，在代码中需要进行处理。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> i = integer; <span class="comment">// NPE</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程基础</title>
    <url>/2019/04/08/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>并发编程这种技术在早期是没有的，因为所有的程序都能够独享 CPU、内存和 IO 设备，程序一个个接着执行，谁也不干扰谁，只要程序的逻辑没有出错，得到的结果就是准确的。但是慢慢有人发现：CPU、内存、和 IO 之间速度的差异太大。大致可以描述为：<strong>CPU 一天，内存一年、IO 设备几百年</strong>，所以特别贵的 CPU 和内存在程序执行的过程大多数时候都是空闲的，这就造成了资源的极大浪费。</p>
<p>后来 Unix 系统提出了 CPU 分时的解决方法，这样就能多个程序在一个 CPU上并发的执行，提高 CPU 的使用效率。所以 Java 中出现的多线程编程是为了更好的利用 CPU 的资源。进程之间的数据都是独享，而线程之间的状态和数据都共享同一个进程的，所以线程之间的切换要比进程之间的切换代价更小。线程是现代操作系统进行任务调度的最小单位。</p>
<h3>并发编程的三大模块</h3>
<p>并发的核心功能都是来自于操作系统的延展。所以在 Java 以及其他的编程语言的并发模块中，背后都有着共同的理论模型。</p>
<p>在并发编程中，大致可以抽象成三个模块：分别是<strong>分工</strong>、<strong>同步</strong>和<strong>互斥</strong>。</p>
<p><strong>分工</strong>可以提升任务的执行效率，在 Java 中就是使用多个线程分别去执行不同的任务。在执行任务的过程中，线程之间不是独立存在的，线程之间需要依赖关系的，那么<strong>同步</strong>就是用来调度线程之间的协作，具体的方式就是在一个线程完成工作后通知其他的线程开始工作。多线程的编程方式破坏了编程原本的顺序执行。所以也就引入了<strong>线程安全</strong>问题，也就是正确性问题，线程的安全问题最核心的解决方案就是<strong>互斥</strong>，实现互斥的关键就是<strong>锁</strong>。</p>
<h3>并发问题的源头</h3>
<p>但是凡事有利有弊，并发计算带来了很大的好处，提升了系统资源的使用率，让系统可以把一件事又快又好的干完，但是同时也引入了新的问题。</p>
<p>在电脑只有一颗 CPU 的时候，所有线程都直接对一个缓存就行读写，所以缓存中数据的一致性问题就很好解决了。一个线程对共享变量的修改对其他线程可见，就称之为<strong>可见性</strong>。</p>
<p>但是在多颗 CPU 的环境下，每个 CPU 有自己的缓存，而且对其他的 CPU 是不可见的，看起的情况就如下所示:</p>
<p>由于现代操作系统都是通过分时来使用 CPU 的，一个正在运行的线程随时有可能被抢夺 CPU 资源，对编写 Java 程序来说，我们通常感觉 <strong>i++</strong> 已经是一个原子操作了，但是对于 CPU 来说，完成这个操作任然需要 3 步。所以这条语句在执行的过程中就有可能被其他线程抢断，其他线程也有可能访问 <strong>i</strong>，两个线程同时对 <strong>i</strong> 进行了操作，然后导致结果不正确，这个问题就是 <strong>原子性</strong>被破坏了。</p>
<p>有时候编译器会调整语句的执行顺序。因为顺序的改变也会出现bug。有一个经典的例子就是使用双重检查来创建单例对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
首先检查单例对象是不是存在，如果不存在，就用 <strong>synchronized</strong> 锁住 Class 对象，获得锁之后，再判断一次这个单例对象存不存在，如果不存在，那就创建一个新的单例对象。</p>
<p>一切看起来都很完美。但是编译器这个时候要出来搞事情，本来实例化一个对象的步骤如下:</p>
<ol>
<li>分配一块内存 M</li>
<li>在内存 M 上初始化 Singleton 对象</li>
<li>再把 M 的地址的值给 instance 变量</li>
</ol>
<p>但是编译器这货为了提高 CPU 缓存的使用效率，把上面的的步骤变成了这样:</p>
<ol>
<li>分配一块内存 M</li>
<li>把 M 的地址值给 instance 变量</li>
<li>最后再在内存 M 上初始化 Singleton 对象</li>
</ol>
<p>这样会带来什么问题呢？当线程 A 走到了优化后步骤的第二步，也就是还没有初始化 Singleton 对象的时候就把 M 的地址值给了 instance。但是还没有初始化 Singleton 对象，但是这个时候被线程 B 抢占了 CPU，发现 instance 的值不是 null，就把 instance 直接返回了，但是实际上 Singleton 并没有被初始化，使用的时候就会报错了，这就是一个<strong>顺序性</strong>问题。</p>
<p>所以总结起来，造成并发问题有三个主要的原因：</p>
<ul>
<li>可见性</li>
<li>原子性</li>
<li>顺序性</li>
</ul>
<h3>Java 多线程编程</h3>
<h4>Java 线程简介</h4>
<p>Java 线程的生命周期如下：</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/Java/thread/javathread.png" alt=""></p>
<ul>
<li><strong>新建（New）</strong>：创建之后未启动</li>
<li><strong>可运行（Runnable）</strong>：线程可能正在运行，也可能正在等待 CPU 时间片，发生异常后进入 Terminated 状态</li>
<li><strong>阻塞（Blocked）</strong>：等待获取一个排它锁，获得了锁后结束次状态，发生异常后进入 Terminated 状态</li>
<li><strong>无限期等待（Waiting）</strong>：等待其他线程唤醒，发生异常后进入 Terminated 状态</li>
<li><strong>限期等待（Timed Waiting）</strong>：不需要其他线程唤醒，在一定时间后会被系统自动唤醒，发生异常后进入 Terminated 状态</li>
<li><strong>死亡（Terminated）</strong>：线程执行完成或者发生异常后进入该状态</li>
</ul>
<p>在 Java 中，使用线程的方式有三种：</p>
<ul>
<li>实现 Runnable 接口</li>
<li>实现 Callable 接口</li>
<li>继承 Thread 类</li>
</ul>
<blockquote>
<p>通常使用实现 Runnable 接口或者 Callable 接口的方式多一点。</p>
</blockquote>
<p>线程在具体的使用过程中，一般不会直接去创建新的线程，而是通过 Executor 来创建线程池，线程池主要有以下三种：</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程</li>
<li>FixedThreadPool: 固定的线程池大小</li>
<li>SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool</li>
</ul>
<p>在线程执行的过程中，可以调用线程的 interrupt() 方法或者 Executor 的 shutdown() 方法来中断线程。</p>
<h4>Java 进行并发编程</h4>
<p>在上面我们聊到，并发编程中涉及到的领域有三类：分工、同步、和互斥。针对这三类问题，Java 中提供完备的工具来完成这些任务：</p>
<p>在分工和协作方面，<code>java.util.concurrent</code> 中提供了 <code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semahpore</code>、<code>FutureTask</code>、<code>BlockingQueue</code>、<code>ForkJoin</code> 等工具类来帮助进行并发编程。</p>
<p>在多线程中，如果多个线程对一个共享的数据同时访问会带来<strong>线程安全</strong>问题，线程安全问题是并发编程下必然会出现的问题。</p>
<p>在 Java 中也提供了诸多工具来帮助解决线程安全问题。首先就是 <strong>Java 内存模型</strong>，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的的方法，屏蔽了各种硬件和操作系统之间的内存访问差异。</p>
<p>Java 内存模型具体的实施就是通过 <strong>volatile</strong>、<strong>cynchronized</strong>、<strong>final</strong> 关键字和 <strong>Happens-Before</strong>规则。Java 内存模型解决了并发问题中的可见性和顺序性问题。</p>
<p>然后就是通过<strong>锁</strong>来解决原子性问题，第一种锁就是 JVM 提供的 synchronized，另一个就是 JDK 实现的 ReentrantLock。</p>
<p>使用锁主要的问题就是线程阻塞带来的性能问题，在 Java 中也提供了不需要用锁的方法，CAS、原子类、ABA 等属于非阻塞同步的方法，这类的方法都是基于<strong>冲突检测的乐观并发策略</strong>来实现的。</p>
<p>还有一种保证线程安全的方法就是不要使用共享数据，不涉及到共享数据，自然也就没有了线程安全的问题。具体的方法有<strong>栈封闭</strong>和<strong>线程本地存储</strong>的方法。</p>
<p>这篇文章简单的将 Java 并发编程中涉及到的内容都总结归纳了一下，可以算作学习 Java 并发编程的指南。</p>
<p>(完)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之Java到底是值传递还是引用传递</title>
    <url>/2020/02/28/Java%E5%9F%BA%E7%A1%80%E4%B9%8BJava%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>Java 中有一个很经典但是一直争论不休的问题。就是 Java 在传参时到底是传递值还是传递引用。</p>
<p>在讨论到底是值传递还是引用传递之前，先来准确定义一下<strong>值</strong>和<strong>引用</strong>。</p>
<p><strong>值</strong>是指变量存储的就是值本身，比如 Java 的基本类型。
<strong>引用</strong>是指变量存储的是指向实际值的引用，也称之为句柄，比如 Java 中的数组和对象，来看下图：</p>
<p><img src="valueref2.png" alt=""></p>
<p>要想完整的理解这个点，需要稍微提一下 JVM 的知识。我们都知道 Java 是运行在 Java 虚拟机（JVM）上的。JVM 中有两块著名的内存区域：<strong>Java虚拟机栈</strong>和<strong>堆</strong>。值类型的变量所占据的内存是在栈上分配，引用类型的变量所占据的内存是在堆上分配。</p>
<blockquote>
<p>这块展开说就会涉及到 JVM 的内存模型，后续通过其他的文章再进行说明。</p>
</blockquote>
<h2>赋值操作</h2>
<p>先看一下这段代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">56</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line">b = <span class="number">65</span>;</span><br><span class="line">System.out.println(<span class="string">"原变量的值："</span>+a);</span><br><span class="line">System.out.println(<span class="string">"新变量的值："</span>+b);</span><br></pre></td></tr></table></figure></p>
<p>对于上面代码的执行结果，应该很简单：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">原变量的值：<span class="number">56</span></span><br><span class="line">新变量的值：<span class="number">65</span></span><br></pre></td></tr></table></figure></p>
<p>赋值操作其实就是新建了一个变量，把原变量中的值拷贝了一份到新变量中。如下图：</p>
<p><img src="valueref1.png" alt=""></p>
<p>也就是说修改 b 其实就是修改 b 变量中的值，与 a 变量完全没有关系。因为在把 a 的值赋值给 b 时，实际上是把 a 变量的<strong>值</strong>拷贝了一份给 b。拷贝完之后 a 和 b 就没有关系了。</p>
<blockquote>
<p>其实这里的说法不完全正确，与 JVM 的机制有关，但是大体上可以这样理解。</p>
</blockquote>
<p>再来看一个例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParamObject paramA = <span class="keyword">new</span> ParamObject(<span class="string">"小明"</span>);</span><br><span class="line">ParamObject paramB = paramA;</span><br><span class="line">paramB.setName(<span class="string">"小红"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"原对象的值："</span>+paramA.getName());</span><br><span class="line">System.out.println(<span class="string">"新对象的值："</span>+paramB.getName());</span><br></pre></td></tr></table></figure></p>
<p>与上面的例子不同，这个例子的输出是：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">原对象的值：小红</span><br><span class="line">新对象的值：小红</span><br></pre></td></tr></table></figure>
上面的例子执行的情况如下图：</p>
<p><img src="valueref4.png" alt=""></p>
<p>在将 paramA 的值赋给 paramB 时，和上面的基本类型其实是一样，把 paramA 中的引用<strong>创建了一个副本</strong>，所以 paramB 中存储的也是指向同一个对象的引用。所以通过 paramB 也就可以修改对象。</p>
<p>再看下面这个例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParamObject paramA = <span class="keyword">new</span> ParamObject(<span class="string">"小明"</span>);</span><br><span class="line">ParamObject paramB = paramA;</span><br><span class="line">paramB = <span class="keyword">new</span> ParamObject(<span class="string">"小红"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"原对象的值："</span>+paramA.getName());</span><br><span class="line">System.out.println(<span class="string">"新对象的值："</span>+paramB.getName());</span><br></pre></td></tr></table></figure></p>
<p>这个例子输出的结果又不同：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">原对象的值：小明</span><br><span class="line">新对象的值：小红</span><br></pre></td></tr></table></figure></p>
<p>这个例子的执行情况是这样的：</p>
<p><img src="valueref3.png" alt=""></p>
<p>paramB 再进行 new 操作之后，paramB 中存储的<strong>引用</strong>就变成了新对象的地址了。所以修改新的对象并不会影响原来的对象。</p>
<p>所以可以把 Java 中的赋值操作总结为：<strong>对原变量中存储的内容进行拷贝，把拷贝的内容放到新的变量中，不论变量中存储的是基本类型还是引用类型</strong></p>
<h2>Java 中的参数传递</h2>
<p>定义一个方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法参数中的 a 称之为<strong>形参</strong>，在调用时传入的参数称之为<strong>实参</strong>。</p>
<p>先说一下结论，Java 中参数的传递其实和<strong>赋值</strong>操作是一样的，相当于把实参赋值给形参。</p>
<p>所以传参也是将实参的副本给形参，修改形参的内容并不会影响实参（<strong>注意：这里说的是修改形参，并不是修改形参引用的对象</strong>）。</p>
<p>通过下面例子来证实一下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">func(b);</span><br><span class="line">System.out.println(<span class="string">"执行方法后的值："</span>+b);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    System.out.println(<span class="string">"在方法中修改形参的值"</span>+a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子的输出为：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在方法中修改形参的值: <span class="number">5</span></span><br><span class="line">执行方法后的值：<span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>这个结果与上面基本类型的变量进行赋值的结果一直。再来看看引用类型参数的传递：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParamObject b = <span class="keyword">new</span> ParamObject(<span class="string">"小红"</span>);</span><br><span class="line">func1(b);</span><br><span class="line">System.out.println(<span class="string">"执行方法后的值："</span>+b.getName());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">(ParamObject a)</span> </span>&#123;</span><br><span class="line">    a.setName(<span class="string">"小明"</span>);</span><br><span class="line">    System.out.println(<span class="string">"在方法通过引用修改对象的值："</span>+a.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子的输出为：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在方法通过引用修改对象的值：小明</span><br><span class="line">执行方法后的值：小明</span><br></pre></td></tr></table></figure></p>
<p>这个例子与上面第二个例子的效果一致。再来看最后一个例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParamObject b = <span class="keyword">new</span> ParamObject(<span class="string">"小红"</span>);</span><br><span class="line">func2(b);</span><br><span class="line">System.out.println(<span class="string">"执行方法后的值："</span>+b.getName());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(ParamObject a)</span> </span>&#123;</span><br><span class="line">    a = <span class="keyword">new</span> ParamObject(<span class="string">"小明"</span>);</span><br><span class="line">    System.out.println(<span class="string">"在方法新建对象后的值："</span>+a.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后这个例子的输出为：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在方法新建对象后的值：小明</span><br><span class="line">执行方法后的值：小红</span><br></pre></td></tr></table></figure></p>
<p>也与上面第三个例子的结果表现一致。所以在 Java 中参数传递的方式与赋值完全一样。都是拷贝原变量中的内容，这种方式就是<strong>值传递</strong>。如果在传递的过程中不是通过副本，而是直接传递变量本身，这种方式称之为<strong>引用传递</strong>。</p>
<p>所以说 Java 中的参数传递是<strong>值传递</strong>。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之如何取舍Joda与 Java8 日期库</title>
    <url>/2020/02/22/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A6%82%E4%BD%95%E5%8F%96%E8%88%8DJoda%E4%B8%8E-Java8-%E6%97%A5%E6%9C%9F%E5%BA%93/</url>
    <content><![CDATA[<p>在 Java8 以前，时间和日期的类库很难用，而且有线程安全等诸多问题。</p>
<p>Joda time 弥补了 Java 在这方面的不足，但是在 Java8 时，增加了 <code>java.time</code> 包，对 Java 在日期 API 方面的进行了增强，这些代码实现了 JSR-310 的标准。Joda 的官方推荐迁移到 Java8 的时间类库上来。</p>
<p>下面来详细对比对比一下两个类库，看看 Java8 的日期 API 是否能真正替代 Joda time。</p>
<h2>基础概念对比</h2>
<p>Joda Date 的核心概念，这些概念在 java time 中基本也能找到对应：</p>
<h3>instant</h3>
<p>表示一个时刻，使用从 1970-01-01 00:00:00 至今的毫秒数表示</p>
<p><strong>Joda time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTime dt = <span class="keyword">new</span> DateTime();</span><br><span class="line">Instant instant = dt.toInstant();</span><br></pre></td></tr></table></figure>
<strong>Java time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line">Instant instant = clock.instant();</span><br></pre></td></tr></table></figure></p>
<h3>interval</h3>
<p>表示两个 instant 之间的间隔，左闭右开。</p>
<p><strong>Joda time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTime dt = <span class="keyword">new</span> DateTime();</span><br><span class="line">DateTime dt1 = <span class="keyword">new</span> DateTime();</span><br><span class="line">Interval interval = <span class="keyword">new</span> Interval(dt.toInstant(), dt1.toInstant());</span><br></pre></td></tr></table></figure>
java time 中没有提供类似的 API，因为 JSR-310 标准中没有这个概念。</p>
<h3>duration</h3>
<p>用毫秒表示的时间段，通常从 interval 获得
<strong>Joda time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTime dt = <span class="keyword">new</span> DateTime();</span><br><span class="line">DateTime dt1 = <span class="keyword">new</span> DateTime();</span><br><span class="line">Interval interval = <span class="keyword">new</span> Interval(dt.toInstant(), dt1.toInstant());</span><br><span class="line">Duration duration = interval.toInstant();</span><br></pre></td></tr></table></figure></p>
<p><strong>Java time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime l1 = LocalDateTime.now();</span><br><span class="line">LocalDateTime l2 = LocalDateTime.now();</span><br><span class="line">Period period = Period.between(l1.toLocalDate(), l2.toLocalDate());</span><br></pre></td></tr></table></figure></p>
<h3>period</h3>
<p>同样表示时间段，比如 3年，5个月，而 duration 使用毫秒表示</p>
<p><strong>Joda time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTime dt1 = <span class="keyword">new</span> DateTime();</span><br><span class="line">DateTime dt2 = <span class="keyword">new</span> DateTime();</span><br><span class="line">Period period = Period.fieldDifference(dt1.toLocalDateTime(), dt2.toLocalDateTime());</span><br></pre></td></tr></table></figure></p>
<p><strong>Java time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime l1 = LocalDateTime.now();</span><br><span class="line">LocalDateTime l2 = LocalDateTime.now();</span><br><span class="line">Period period = Period.between(l1.toLocalDate(), l2.toLocalDate());</span><br></pre></td></tr></table></figure></p>
<h3>chronology</h3>
<p>年表，这是 joda-time 设计的基础</p>
<p><strong>Joda time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTime dt = <span class="keyword">new</span> DateTime();</span><br><span class="line">Chronology chronology = dt.getChronology();</span><br></pre></td></tr></table></figure>
<strong>Java time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">Chronology ch = localDateTime.getChronology();</span><br></pre></td></tr></table></figure></p>
<h3>timezones</h3>
<p>表示时区。</p>
<p><strong>Joda time</strong>:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTime dt = <span class="keyword">new</span> DateTime();</span><br><span class="line">DateTimeZone dateTimeZone = dt.getZone();</span><br><span class="line">Set&lt;String&gt; zones = DateTimeZone.getAvailableIDs();</span><br></pre></td></tr></table></figure></p>
<p><strong>Java time</strong>:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line">ZoneId zoneId = clock.getZone();</span><br><span class="line">Set&lt;String&gt; zones = ZoneId.getAvailableZoneIds();</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看到，除了 JSR-310 中没有的 Interval 的定义之外，这两个库在基础概念方面的实现相差不大。</p>
<blockquote>
<p>因为 Unix 系统从 1970-01-01 00:00:00 开始计时，这个时间也称之为 Epoch Time，后续使用 Unix 的这种计时方式。</p>
</blockquote>
<h2>具体使用</h2>
<p>Joda time 依赖 JDK5 及后续版本，没有额外的依赖。</p>
<p>为了起到对比的效果，挑几个比较常用的场景进行对比：</p>
<ul>
<li>获取 1970 至今的毫秒数</li>
<li>获取当前时间</li>
<li>获取年、月、日、星期几</li>
<li>日期的增减</li>
<li>日期的格式化</li>
</ul>
<h3>获取时间戳</h3>
<p>在代码中，经常会使用这个功能来表示唯一性：</p>
<p><strong>Joda time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTime dt = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="keyword">long</span> mills = dt.getMillis();</span><br></pre></td></tr></table></figure>
<strong>Java time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line"><span class="keyword">long</span> mills = clock.millis();</span><br></pre></td></tr></table></figure></p>
<h3>获取当前时间</h3>
<p>这块两个库没有太大的差异：</p>
<p><strong>Joda time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTime dt = <span class="keyword">new</span> DateTime();</span><br><span class="line">LocalDateTime localDateTime = dt.toLocalDateTime();</span><br></pre></td></tr></table></figure>
<strong>Java time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br></pre></td></tr></table></figure></p>
<h3>获取年、月、日、星期几</h3>
<p><strong>Joda time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTime dt = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="keyword">int</span> dayOfYear = dt.getDayOfYear();</span><br><span class="line"><span class="keyword">int</span> dayOfMonth = dt.getDayOfMonth();</span><br><span class="line"><span class="keyword">int</span> dayOfWeek = dt.getDayOfWeek();</span><br><span class="line"><span class="keyword">int</span> hourOfDay = dt.getHourOfDay();</span><br></pre></td></tr></table></figure>
<strong>Java time:</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now(clock);</span><br><span class="line"><span class="keyword">int</span> dayOfYear = localDateTime.getDayOfYear();</span><br><span class="line"><span class="keyword">int</span> dayOfMonth = localDateTime.getDayOfMonth();</span><br><span class="line"><span class="keyword">int</span> dayOfWeek = localDateTime.getDayOfWeek().getValue();</span><br><span class="line"><span class="keyword">int</span> hourOfDay = localDateTime.getHour();</span><br></pre></td></tr></table></figure>
获取这些值两个库也没有太大的差异，但是对于一些场景，比如我想获得 &quot;星期四&quot; 这个字符串。
在 Joda 库中，可以 <code>dt.dayOfWeek().getAsShortText(); // 星期四</code> 这样获得。在 Java 中，<code>localDateTime.getDayOfWeek().name(); //THURSDAY</code> 只能获取到英文。</p>
<p>Joda time 在本地化方面比 Java time做的更好。</p>
<h3>日期增减</h3>
<p><strong>Joda time</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTime dt = <span class="keyword">new</span> DateTime();</span><br><span class="line">dt = dt.plusDays(<span class="number">2</span>); <span class="comment">//当前日期添加两天</span></span><br><span class="line">dt = dt.plusHours(<span class="number">5</span>); <span class="comment">// 当前时间加上两个小时</span></span><br><span class="line">dt = dt.minusDays(<span class="number">1</span>); <span class="comment">// 当前日期减一天</span></span><br><span class="line">dt = dt.minusHours(<span class="number">2</span>); <span class="comment">// 当前日期减两个小时</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Java time</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">localDateTime = localDateTime.plusDays(<span class="number">2</span>); <span class="comment">// 增加两天</span></span><br><span class="line">localDateTime = localDateTime.plusHours(<span class="number">2</span>); <span class="comment">// 增加两个小时</span></span><br><span class="line">localDateTime = localDateTime.minusDays(<span class="number">1</span>); <span class="comment">//减少一天</span></span><br><span class="line">localDateTime = localDateTime.minusHours(<span class="number">1</span>); <span class="comment">// 减少一个小时</span></span><br></pre></td></tr></table></figure></p>
<h3>日期的格式化</h3>
<p>日期格式化是日常使用最频繁的功能，下面来对比一下这两者的区别。</p>
<p><strong>Joda time</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormat.forPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">DateTime dt = <span class="keyword">new</span> DateTime();</span><br><span class="line">System.out.println(dt.toString(formatter));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">String dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">System.out.println(dt.toString(dateFormat));</span><br></pre></td></tr></table></figure></p>
<p><strong>Java time</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();   System.out.println(formatter.format(localDateTime));</span><br></pre></td></tr></table></figure></p>
<p>通过上面的对比，可以发现这两个类库都可以完成相同的功能。虽然在细节上是有一些细微的差别。</p>
<p>java.util.Date 是 Java 中最早的日期类，后来就不推荐使用这个类了，java.util.Calendar 用来替代 Date。Calendar 有 Date 的所有功能，并且提供了更加丰富的获取年月日的 API。</p>
<p>Calendar 是一个虚拟类，GregorianCalendar 则是 Calendar 的实现类。</p>
<p>Java time 与 java.util 下的时间类相互转化，可以将 Date 或者 Calendar 转化成 Java time 中的 LocalDateTime.</p>
<p>java.util.Date 转 java.time.LocalDateTime:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());</span><br></pre></td></tr></table></figure></p>
<p>java.util.Carlendar 转 java.time.LocalDateTime:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.ofInstant(calendar.toInstant(), ZoneId.systemDefault());</span><br></pre></td></tr></table></figure></p>
<p>Joda time 也可以与 java.util.Date 可以进行相互的转化：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from Joda to JDK</span></span><br><span class="line">DateTime dt = <span class="keyword">new</span> DateTime(); </span><br><span class="line">Date jdkDate = dt.toDate();</span><br><span class="line"><span class="comment">// from JDK to Joda</span></span><br><span class="line">dt = <span class="keyword">new</span> DateTime(jdkDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// from Joda to JDK</span></span><br><span class="line">DateTime dt = <span class="keyword">new</span> DateTime();</span><br><span class="line">Calendar jdkCal = dt.toCalendar(Locale.CHINESE);</span><br><span class="line"><span class="comment">// from JDK to Joda</span></span><br><span class="line">dt = <span class="keyword">new</span> DateTime(jdkCal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// from Joda to JDK</span></span><br><span class="line">DateTime dt = <span class="keyword">new</span> DateTime();</span><br><span class="line">GregorianCalendar jdkGCal = dt.toGregorianCalendar();</span><br><span class="line"><span class="comment">// from JDK to Joda</span></span><br><span class="line">dt = <span class="keyword">new</span> DateTime(jdkGCal);</span><br></pre></td></tr></table></figure></p>
<h2>设计思想</h2>
<p>Joda time 与 Java time 在功能上已经相差不大，常用的功能这两个类库都可以完成，而且两个库都是线程安全的。</p>
<p>但我认为 Joda time 的 API 更加简洁一些，Joda time 的使用可以直接从 DateTime 这个类开始。而 Java time 的使用则更加繁琐。</p>
<p>从设计上来说 Java time 都不再使用 new 来创建实例，而是使用工厂方法来创建实例。这点上比 Joda time 的设计要更好，而且更加安全。</p>
<p>既然 Joda time 都推荐迁移回 Java time 了，那么最终肯定是要迁移的。但是目前来说，我觉得 Joda time 用起来更加顺手一些，暂时还会继续使用这个。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO 简明教程</title>
    <url>/2018/07/28/Java-NIO-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>Java NIO 是在 Java1.4 之后推出的一套全新的 IO 接口，是用来解决传统 Java IO 和 Java 网络包中 API 的扩展性差、效率低等问题。 NIO 有着一套完全不同的设计理念。</p>
<blockquote>
<p>NIO 指的是 Non-blocking，而不是 New-IO</p>
</blockquote>
<p>IO 通常可以分为两种类型:</p>
<ul>
<li>网络 IO</li>
<li>文件 IO (对外部设备的操作都可以看作是对文件的操作)</li>
</ul>
<p>对于一个 IO 操作来，可以分成两步:</p>
<ul>
<li>发起 IO 请求</li>
<li>实际 IO 操作</li>
</ul>
<p>如果在<strong>发起 IO 请求</strong>阶段被阻塞，那就是<strong>阻塞 IO</strong>，如果不阻塞，那就是<strong>非阻塞 IO</strong>。</p>
<p>如果在<strong>实际 IO 操作</strong>阶段阻塞进程，那么就是<strong>同步 IO</strong>，如果不阻塞进程，而是由操作系统完成 IO 操作，然后把结果返回给进程，那么就是<strong>异步 IO</strong>。</p>
<p>Java NIO 在发起 IO 请求时是非阻塞的，但是在实际的 IO 操作过程中是阻塞的，所以 Java NIO 是属于<strong>同步非阻塞IO</strong>。在 Java1.7 以后提供了 <strong>AIO</strong>，这是真正的<strong>异步非阻塞 IO</strong>。在这篇文章中我们只讨论 Java1.4 中的 NIO。</p>
<p>还要一个概念需要说明一下，<strong>并发</strong>和<strong>并行</strong>, 简单来说:</p>
<ul>
<li>并发：可以处理多个任务，多个任务不一定要同时处理</li>
<li>并行：同时处理多个任务的能力。</li>
</ul>
<h3>NIO 核心组件</h3>
<p>在 NIO 中，有三个核心的组件:</p>
<ul>
<li>Buffers</li>
<li>Channels</li>
<li>Selectors</li>
</ul>
<p>核心三个组件的类图如下：</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/Java/nio/nio.png" alt=""></p>
<p>Buffer 是数据容器，除了 boolean 以外，每一个基本类型都有 Buffer 的实现。</p>
<p>Channel 和 java.io 中的 Stream 非常相似，但是有几点重要的区别:</p>
<ul>
<li>Channel 可以读也可以写，但是 Stream 同时只能读或者只能写</li>
<li>Channel 的读写都是基于 Buffer 来进行的。</li>
</ul>
<p>Selector 是在单线程里面利用事件机制去监听多个 Channel，然后让准备就绪的 Channel 进入到 IO 操作阶段。 但是在实际进行 IO 的阶段，依然是阻塞的，所以这也就是为什么 Java NIO 是 <strong>同步非阻塞的</strong>。</p>
<h3>Channel 详解</h3>
<p>在上图中，已经将 Channel 的 4 个重要的实现都列出来了，分别是:</p>
<ul>
<li>FileChannel (文件数据的读写)</li>
<li>DatagramChannel (UDP 数据的读写)</li>
<li>SocketChannel（TCP 数据的读写）</li>
<li>ServerCocketChannel (监听 TCP 链接请求，每个请求都会创建一个 SocketChannel)</li>
</ul>
<p>Channel 用于连接外部的 IO 服务和 NIO 中的Buffer。Channel 与操作系统的关系非常紧密。在不同的操作系统中都有着不同的实现。</p>
<p>Channel 可以一般可以设置为阻塞和非阻塞的模式。</p>
<blockquote>
<p>FileChannel 只有阻塞模式，所以不能注册到 Selector。</p>
</blockquote>
<p>通常来说，一个 Channel 会向一个 Buffer 中读或者写数据，但是 Channel 也支持 Scatter 和 Gather，Scatter 是指把 Channel 中读取到的数据写入到多个 Buffer 中。Gather 是指把多个 Buffer 中的数据写入到一个 Channel 中。</p>
<blockquote>
<p>在把一个 Channel 的数据读入到多个 Buffer 中时，会在写满一个 Buffer 后再接着写另一个 Buffer。</p>
</blockquote>
<p>在 FileChannel 中，有两个很有用的方法，一个是 <strong>transferFrom()</strong>，一个是 <strong>transferTo()</strong>，
可以用来拷贝文件，两个方法的用法大致相同。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"from.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"to.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count    = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(fromChannel, position, count);</span><br></pre></td></tr></table></figure></p>
<h3>Buffer 详解</h3>
<p>Buffer 用于和 Channel 进行交互，Channel 从 BUffer 中读取数据和写入数据，Buffer 的本质是一块内存区域，Buffer 提供了一系列的接口来操作这块内存的数据。</p>
<p>Buffer 有两种不同的模式，一种是<strong>读</strong>模式，这种模式下只能从 Buffer 中读取数据，一种是<strong>写</strong>模式，这个时候只能往 Buffer 中写数据。</p>
<p>Buffer 中有几个非常关键的属性:</p>
<ul>
<li>capacity：这个属性表示 Buffer 的容量，这个值是不可变的。</li>
<li>position： 在<strong>写</strong>模式下，需要有一个确定的位置可以来写入数据，默认 position 为 0，position 最大为 capacity - 1；在变成<strong>读</strong>模式下，position 归零，position 变成读的初始位置，每次读取后，position 后移。</li>
<li>limit：在<strong>写</strong>模式下，limit 的含义就是我们能写入的最大数据量，等于 capacity；在<strong>读</strong>模式下，limit 表示我们所能读取的最大数据量，等同于<strong>写</strong>模式下 position 的值。</li>
</ul>
<p>下面的代码简单展示了如何操作 Buffer，以及如何向 Channel 中读取和写 Buff：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buff = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">socketChannel.read(buff);</span><br><span class="line"></span><br><span class="line">IntBuffer intBuff = buff.asIntBuffer();</span><br><span class="line"></span><br><span class="line">buff.clear();</span><br><span class="line">intBuff.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">intBuff.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">socketChannel.write(buff);</span><br></pre></td></tr></table></figure></p>
<p>当 Channel 开始写入数据到 Buffer 中时，Buffer 会记录已经写入的数据的大小。当需要读取数据时，Buffer 会通过 flip() 方法将 Buffer 从写的模式调整为读的模式，然后就可以读取 Buffer 中所有已经写入的数据。</p>
<p>在将数据读取完成后，需要清除已经读取过的数据，有两种方式，一个方法是 clear() 方法，一个是 compact() 方法。clear 方法会清空 Buffer 中所有的数据， 而 compact 只会清空已经读取的数据，然后会把未读取的数据移到 Buffer 开始的位置，新写入的数据的开始位置则在未读取的数据之后。</p>
<h3>Selector 详解</h3>
<p>Selector 管理着一个被注册的了 Channel 的集合和它们的就绪状态。</p>
<p>只有继承了 SelectableChannel 的 Channel 才能被注册到 Selector，一个 Channel 可以被注册到多个 Selector 上，而每个 Selector 只能被注册一次。Channel 在被注册到 Selector 之前，首先要先设置成为<strong>非阻塞模式</strong>。</p>
<p>SelectionKey 封装了 Channel 与 Selector 的注册关系。</p>
<p>在 SelectionKey 中定义了四种状态：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>在将一个 Channel 注册到一个 Selector 时，我们可以设置我们对哪个状态感兴趣：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Selector operation</span></span><br><span class="line">SocketChannel channel = SocketChannel.open();</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">channel.register(selector, SelectionKey.OP_CONNECT);</span><br></pre></td></tr></table></figure>
register 方法中的第二个参数就是我们希望处理的状态，Selector 会把这些状态收集起来作为一个我们关注的<strong>兴趣集</strong>。</p>
<p>如果底层操作系统通知 Selector 一个 Channel已经处于就绪状态，那么 Selector 就会把这个 Channel 的key 放入到它<strong>就绪集</strong>中。</p>
<p>Selector 可以在单线程中处理多个 Channel，就是是说可以用少量的线程就可以处理更多的连接，可以减少线程之前的切换，从而提升系统的并发能力。</p>
<p>在 Selector 中会维护 SelectionKey 的集合来完成对 Channel 的调度。</p>
<h4>Selector 如何维护 selectionKeys</h4>
<p>在 Selector 中维护着三个 selectionKeys 的集合:</p>
<ul>
<li><strong>key set</strong>: 这里面包含着所有的 selectionKeys，所有注册的 channel 都在里面，可以通过 selector.keys() 来获得这个集合。</li>
<li><strong>selected-key set</strong>： 这个集合一定是 key set 的子集，包含着我们在注册 Channel 时传入的一种状态相匹配的 key。可以通过 <strong>selector.selectionKeys()</strong> 获取到集合。</li>
<li><strong>cancelled-key set</strong>：这里面的 key 也一定是 key set 的子集，其中的每一个 selectionKey 都已经被取消了，但注册的 Channel 还没有被注销。</li>
</ul>
<p>在一个新创建的 selector 中，着三个集合都是空着的。每注册一个 Channel，key set 中都会增加一条记录。在 Selector 轮序期间，一些准备就绪的 SelectionKey 会被添加到 selected-key set 中。这些key 可以通过 <strong>remove</strong> 方法来移除。在调用了 <strong>channel.close</strong> 或者 <strong>selectionKey.cancel()</strong> 方法后，这些 SelectionKey 会被添加到 <strong>cancelled-key set</strong> 中。</p>
<h4>Selector 如何选择就绪的 Channel</h4>
<p>在 Selector 执行了 <strong>selector()</strong> <strong>selecotr(long)</strong> 和 <strong>selectNow()</strong> 方法之后，SelectionKeys 都可以在 selected-key set 中填金额或者被删除，同时也可以从 key set 和 cancelled-key set 中删除。在执行 select() 方法后，会涉及到以下的三个步骤:</p>
<ol>
<li>
<p>首先 cancelled-key set 中的 key 会从 key set 中被删除，并且对于的 Channel 会被注销。然后 cancelled-key set 变成空。</p>
</li>
<li>
<p>然后查询底层操作系统来获得 <strong>Selector</strong> 中剩余的 Channel 的就绪状态从 调用 <strong>select()</strong> 方法到此刻的更新情况，只要有 Channel 的就绪状态与传入的状态值匹配上，就会做以下两件事:
1. 如果这个 Channel 的 key 还没有在 selected-key set 中，并将这个 Channel 的就绪状态集修改成只包含 Channel 当前的状态，任何之前的就绪状态都会被丢弃。
2. 如果这个 Channel 的 key 在 selected-key set 中存在，那么就保留就绪状态集中先前的就绪状态，并且将 Channel 当前的状态写进去，底层系统会通过<strong>与</strong>操作来更新当前的就绪集。</p>
<p>如果兴趣集为空，那么 selected-key set 和 就绪状态集都不会被更新。</p>
</li>
<li>
<p>如果在第 2 步中将任何 key 添加到 cancelled-key set 中，就按步骤 1 处理它们。</p>
</li>
</ol>
<p>（完）</p>
<p><strong>参考文献</strong>:</p>
<ol>
<li>http://tutorials.jenkov.com/java-nio/index.html</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8简明教程</title>
    <url>/2019/01/19/Java8%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>虽然 Java8 已经发布了很长的时间，而且 Java8 中有很多特性可以提升代码的效率和安全，但是大多数 Java 程序员还是没有跨过 Java8 这个坎，<a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="noopener">
Benjamin</a> 在 2014 年写下的这篇 Java8 的入门教程我觉得非常不错，或许可以帮助你跨过 Java8 这个坎。</p>
<hr>
<p>这份教程会指导你一步一步学习 Java8 的新特性。按照先后顺序，这篇文章中包括以下的内容：接口的 <code>default</code> 方法，<code>lambda</code> 表达式，方法引用，可复用注解，还有一些 API 的更新，<code>streams</code>，函数式接口，<code>map</code> 的扩展和新的 <code>Date</code> Api。</p>
<blockquote>
<p>本文没有大段的文字，只有带注释的代码片段，希望你能喜欢！</p>
</blockquote>
<h4>接口的 default 方法</h4>
<p>Java8 允许在接口中实现具体的方法，只需要在方法前加上 <code>default</code> 关键字就行。这一特性也称之为<strong>虚拟扩展方法</strong>。这里是第一个例子:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formual</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的例子中，<code>Formual</code> 接口定义了一个 <code>default</code> 方法 <code>sqrt</code>，接口的实现类只要需要实现 <code>calculate</code> 方法，<code>sqrt</code> 方法开箱即用。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure>
上面的代码匿名实现了 Formual 接口。代码相当的冗长，用了 6 行代码才实现了 sqrt(a * 100) 的功能。在下一节中可以通过 <code>Java8</code> 的特性优雅的完成这个功能。</p>
<h4>Lambda 表达式</h4>
<p>先看一下之前版本的 Java 中如何实现对一个字符串 List 进行排序的功能：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
静态方法 Collection.sort 接收一个字符串 List 和一个字符串的 <strong>Comparator</strong> 用于比较传入的字符串 List。通常的做法就是实现一个匿名的 Comparator 然后传入到 sort 方法中。</p>
<p>相比于使用匿名方法的冗长实现，Java8 可以通过 <strong>lambda</strong> 表达式用很短的代码来实现:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
这个代码已经比之前的匿名方法短很多了，但是这个代码还可以更短一点：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：使用 <code>Collections.sort(names, (a,b)-&gt;b.compareTo(a));</code> 也可以</p>
</blockquote>
<p>用一行代码就实现了方法，省略掉了 <code>{}</code> 和 <code>return</code> 关键字。但是其实还可以更短一点：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>
Java 编译器可以根据上下文判断出参数的类型，所以你也可以省略参数的类型。下面来探究一下 lambda 表达式更进阶的用法。</p>
<h4>函数式接口</h4>
<p>lambda 表达式和如何与 Java 的类型系统相匹配？每个 lambda 表达式都会被接口给定类型，所以每个<strong>函数式接口</strong>都至少声明一个 <strong>abstract</strong> 方法。每一个 lambda 表达式的参数类型都必须匹配这个抽象方法的参数。由于 <strong>default</strong> 关键字标识的方法不是抽象方法，可以在接口中添加任意多个 default 方法。</p>
<blockquote>
<p>注：每一个 lambda 都是函数式的接口，所以使用了 @FunctionInterface 的 interface 都只能有一个抽象方法</p>
</blockquote>
<p>可以将任意只包含一个抽象方法的接口当作 lambda 表达式。为了确保接口满足要求，需要在接口上添加 <code>@FunctionalInterface</code>  注解，如果加上注解接口中不止一个虚拟方法，编译器就会报错。如下的例子:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p>
<p>但是省略 <code>@FunctionalInterface</code> 这个注解后，代码也可以正常工作。</p>
<h4>方法引用</h4>
<p>以上的示例代码可以通过静态方法引用进一步简化：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);   <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p>
<p>Java8 允许你使用 <strong>::</strong> 来调用静态方法和构造函数的引用。上面的代码展示了如何引用一个静态方法。也可以通过同样的方法来引用对象方法:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Something something = <span class="keyword">new</span> Something();</span><br><span class="line">Converter&lt;String, String&gt; converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">"Java"</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// "J"</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：System.out::println 引用的 <code>println</code> 不是静态方法，因为 System.out 是一个对象</p>
</blockquote>
<p>下面让来看看 <strong>::</strong> 是如何在构造函数上起作用的。首先定义一个有着不同构造方法的类 <strong>Person</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
接下来定义一个 Person 工厂接口来创建新的 Person 对象:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
不需要手动实现一个工厂，而是通过构造函数的引用来完成新建 <strong>Person</strong> 对象：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</span><br></pre></td></tr></table></figure>
通过 <code>Person::new</code>  来获取到了 <code>Person</code> 类的构造方法引用。然后 Java 编译器会根据 <code>PersonFactory::create</code>  的参数来自动选择合适的构造函数。</p>
<blockquote>
<p>注：lambda 、方法引用、构造函数引用都是由 @FunctionalInterface 的实例生成的，只有一个抽象方法的接口默认是一个 @FunctionalInterface，加了 @FunctionalInterface 注解的接口只能有一个抽象方法。</p>
</blockquote>
<h4>Lambda 的访问范围</h4>
<p>相比于匿名实现的对象，lambda 表达式访问外部变量非常简单。lambda 表达式可以访问本地外部的 final 变量、成员变量和静态变量。</p>
<h5>访问本地变量</h5>
<p>lambda 表达式可以访问外部本地的 final 变量：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
与匿名方式不同的是，num 变量可以不定义成 final，下面的这些代码也是可以工作的:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
然而 num 变量在编译的过程中会被隐式的编译成 final，下面的代码会出现编译错误:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
在 lambda 表达式中也不能改变 num 的值。</p>
<h5>访问成员变量和静态变量</h5>
<p>与访问本地变量相反，在 lambda 表达式中对成员变量和静态变量可以进行读和写。这种访问变量的方式在匿名变量中也实现了：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</span><br><span class="line">    <span class="keyword">int</span> outerNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            outerNum = <span class="number">23</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            outerStaticNum = <span class="number">72</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：外部的变量无法在 lambda 内部完成赋值操作，如果需要从 lambda 中获取到值，可以通过在外部定义一个 final 的<strong>数组</strong>，将需要带出的值放在数组里面带出来。</p>
</blockquote>
<h5>访问默认接口方法</h5>
<p>还记得前面的 Formula 例子吗？Formula 接口定义了一个默认方法 sqrt 可以在每一个 Formula 的实例（包括匿名实现的对象）中访问。但是默这种方式在 lambda 表达式中不起作用。</p>
<p>默认方法不能通过 lambda 表达式访问，下面的代码无法编译通过:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt( a * <span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<h4>内置的函数式接口</h4>
<p>Java8 包含很多的内置函数式接口。有一些被广泛应用的接口如 Comparator 、Runnable。这些已经存在的接口都通过 @FunctionalInterface 进行了扩展，从而支持 lambda 表达式。</p>
<p>但是 Java8 中也有一些全新的函数式接口可以让你代码写的更轻松。其中一些来自于 <a href="https://github.com/google/guava" target="_blank" rel="noopener">Google Guava</a> 库。即使你对这个库已经很熟悉了，但是还是应该密切注意这些接口是如何被一些有用的方法扩展的。</p>
<h5>Predicates</h5>
<p>Predicate 是一个参数的布尔函数。这个接口提供了很多的默认函数来组合成复杂的逻辑运算（与、非）。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">"foo"</span>);              <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">"foo"</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure></p>
<h5>Functions</h5>
<p>Function 接收一个参数产生一个结果。默认方法可以用于多个方法组成的方法链。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line"></span><br><span class="line">backToString.apply(<span class="string">"123"</span>);     <span class="comment">// "123"</span></span><br></pre></td></tr></table></figure></p>
<h5>Suppliers</h5>
<p>Supplier 根据给定的类属性产生一个对象，Supplier 不支持传入参数。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure></p>
<h5>Consumers</h5>
<p>Consumer 对输入的参数进行一系列预定义的流程进行处理。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</span><br></pre></td></tr></table></figure></p>
<h5>Comparators</h5>
<p>Comparator 是在老版本的 Java 中就经常被使用的接口， Java8 在这个接口中加入了很多的默认方法。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure></p>
<h5>Optionals</h5>
<p>Optional 不是一个函数式接口，而是一个消灭 NullPointerException 的好方法。这是下一节会对其原理进行重点讲解，下面来看看 Optional 是如何工作的。</p>
<p>Optional 是包含了一个值的容器，这个值可以为 null，也可以不为 null。考虑到方法可能会返回非 null 的值，也可能什么都不会返回。在 Java8 中，你可以让它不返回 null，或是返回一个 Optional 对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</span><br><span class="line"></span><br><span class="line">optional.isPresent();           <span class="comment">// true</span></span><br><span class="line">optional.get();                 <span class="comment">// "bam"</span></span><br><span class="line">optional.orElse(<span class="string">"fallback"</span>);    <span class="comment">// "bam"</span></span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：这些内置的函数式接口都加上了 @FuncationalInterface 注解，算是一个语法糖，为不同类型的函数式方法提供了便捷方式，不用重头定义，在后面的 Stream 编程的各个阶段所需要的函数式接口都不同，这些内置的接口也为 Stream 编程做好了准备。</p>
</blockquote>
<h4>Streams</h4>
<p>一个 java.util.Stream 代表着一系列可以执行一个或者多个操作的元素。<strong>Stream</strong> 操作可以是中间操作，也可以是终端操作。终端操作返回的是类型确定的结果。中间操作返回的是 Stream 对象本身，可以继续在同一行代码里面继续调用其他的方法链。</p>
<p>Stream 对象可以由 java.util.Collection 的对象创建而来，比各类 list 和 set (map 暂时不支持)，Stream 可以支持串联和并行操作。</p>
<p>首先来看一下串联操作，通过 List 对象创建一个 Stream 对象：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.add(<span class="string">"ddd2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb1"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa1"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb3"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ccc"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ddd1"</span>);</span><br></pre></td></tr></table></figure></p>
<p>Java8 中的 Collections 已经被扩展了，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建 Stream 对象，下面的内容将介绍最常用的 Stream 操作。</p>
<h5>Filter</h5>
<p><strong>Filter</strong> 接受一个 Predicate 来过滤 Stream 中的所有元素。这个操作是一个中间操作，对过滤的结果可以调用另一个 Stream 操作（比如: forEach）。ForEach 接收一个 Consumer 参数，执行到过滤后的每一个 Stream 元素上。ForEach 是一个终端操作，所以不能在这个操作后调用其他的 Stream 操作。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// "aaa2", "aaa1"</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：每一个 stream 在执行 <code>forEach</code> 等终端操作之后就不能再继续接 <code>filter</code> 等中间操作。</p>
</blockquote>
<h5>Sorted</h5>
<p><strong>Sorted</strong> 是一个中间操作，会返回排好序的 Stream。如果不传入自定义的 Comparator，那么这些元素将会按照自然顺序进行排序。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// "aaa1", "aaa2"</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是 Sorted 只会对流里面的元素进行排序，而不会去改变原来集合里元素的顺序，在执行 Sorted 操作后，stringCollection 中元素的顺序并没有改变:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(stringCollection);</span><br><span class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure></p>
<h5>Map</h5>
<p><strong>Map</strong> 是一个中间操作，会根据给定的函数把 Stream 中的每一个元素变成另一个对象。下面的例子展示了将每一个字符串转成大写的字符串。你同样也可以使用 Map 将每一个元素转成其他的类型。这个 Stream 的类型取决与你传入到 Map 的中的方法返回的类型。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></span><br></pre></td></tr></table></figure></p>
<h5>Match</h5>
<p>各种各样的 <strong>Match</strong> 操作可以用于判断一个给定的 Predicate 是否与 Stream 中的元素相匹配。Match 操作是一个终端操作，会返回一个布尔值。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> anyStartsWithA =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h5>Count</h5>
<p><strong>Count</strong> 是一个终端操作，会返回一个 long 值来表示 Stream 中元素的个数。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> startsWithB =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</span><br><span class="line">        .count();</span><br><span class="line"></span><br><span class="line">System.out.println(startsWithB);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<h5>Reduce</h5>
<p><strong>Reduce</strong> 是一个终端操作，会根据给定的方法来操作 Stream 中所有的元素，并且返回一个Optional 类型的值。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);<span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：ifPresent 方法接受一个 Consumer 类型的对象，System.out::println 是一个方法引用，而且 println 是一个接收一个参数且不返回值得函数，刚好符合 Consumer 的定义。</p>
</blockquote>
<h4>并行 Streams</h4>
<p>在上文中提到过 <strong>Stream</strong> 可以是串联的也可以是并行的。 Stream 的串行操作是在单线程上进行的，并行操作是在多线程上并发进行的。</p>
<p>下面的例子展示了使用并行 Stream 来提高程序性能性能。</p>
<p>首先初始化一个有很多元素的 list，其中每个元素都是唯一的:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>;</span><br><span class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
接下来分别测试一下串联和并行 Stream 操作这个 list 所花的时间。</p>
<p><strong>串联排序</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</span><br><span class="line"></span><br><span class="line"><span class="comment">// sequential sort took: 899 ms</span></span><br></pre></td></tr></table></figure></p>
<p><strong>并行排序</strong>:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel sort took: 472 ms</span></span><br></pre></td></tr></table></figure></p>
<p>如结果所示，运行这些几乎一样的代码，并行排序大约快了 50%，你仅仅需要将 stream() 改成 parallelStream()。</p>
<h4>Map</h4>
<p>前面已经提到 <strong>Map</strong> 不支持 Stream ，但是 Map 已经支持很多新的、有用的方法来完成通常的任务。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    map.putIfAbsent(i, <span class="string">"val"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">map.forEach((id, val) -&gt; System.out.println(val));</span><br></pre></td></tr></table></figure>
从上面的代码可以看出，putIfAbsent 可以不用做 null 的检查，forEach 接受一个 Consumer 来遍历 map 中的每一个元素。</p>
<p>下面的代码展示了如何使 map 的内置方法进行计算:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</span><br><span class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</span><br><span class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br></pre></td></tr></table></figure></p>
<p>下面来学习如何删除一个键所对应的值，只有在输入的值与 <strong>Map</strong> 中的值相等时，才能删除:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
<p>下面这个方法也很有用:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>);  <span class="comment">// not found</span></span><br></pre></td></tr></table></figure>
合并 Map 中的值也相当的简单:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></span><br><span class="line"></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure></p>
<p>如果当前的键对应的值不存在，那么就会将输入的值直接放入 Map 中，否则就会调用 Merge 函数来改变现有的值。</p>
<h4>Date API</h4>
<p>Java8 在 <strong>java.time</strong> 包下有全新的日期和时间的 API。这些新的日期 API完全比得上 <a href="https://github.com/JodaOrg/joda-time" target="_blank" rel="noopener">Joda-Time</a>，但是却不完全一样。下面的包括了这些新 API 最重要的部分。</p>
<h5>Clock</h5>
<p><strong>Clock</strong> 类可以用来访问当前的日期和时间。Clock 可以获取当前的时区，可以替代 System.currentTimeMillis() 来获取当前的毫秒数。当前时间线上的时刻可以使用 Instant 类来表示，Instant 也可以创建原先的 java.util.Date 对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();<span class="keyword">long</span> millis = clock.millis();</span><br><span class="line"></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);   <span class="comment">// legacy java.util.Date</span></span><br></pre></td></tr></table></figure></p>
<h5>Timezones</h5>
<p>时区是通过 <strong>zoneId</strong> 来表示的，zoneId 可以通过静态工厂方法访问到。时区类还定义了一个偏移量，用来在当前时刻或某时间与目标时区时间之间进行转换。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds());<span class="comment">// prints all available timezone ids</span></span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure></p>
<h5>LocalTime</h5>
<p><strong>LocalTime</strong> 表示一个没有时区的时间，比如 10pm 或者 17:30:15。下面的例子为之前定义的时区创建了两个本地时间。然后比较两个时间并且计算两个时间之间在小时和分钟上的差异。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line"></span><br><span class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></span><br></pre></td></tr></table></figure></p>
<p>本地时间可以通过很多工厂方法来创建实例，包括转换字符串来得到实例:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></span><br><span class="line"></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure></p>
<h5>LocalDate</h5>
<p><strong>LocalDate</strong> 表示一个明确的日期，比如 2017-03-11。它是不可变的，与 LocalTime 完全一致。下面的例子展示了如何在一个日期上增加或者减少天数，月份或者年。需要注意的是每次计算后返回的都是一个新的实例。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);    <span class="comment">// FRIDAY</span></span><br></pre></td></tr></table></figure>
从字符串转变 LocalDate 就像 LocalTime 一样简单。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</span><br><span class="line">System.out.println(xmas);   <span class="comment">// 2014-12-24</span></span><br></pre></td></tr></table></figure></p>
<h5>LocalDateTime</h5>
<p><strong>LocalDateTime</strong> 代表一个具体的日期时间，它结合了上面例子中的日期和时间。LocalDateTime 是不可变的，用法和 LocalDate 和 LocalTime 一样。可以使用方法获取 LocalDateTime 实例中某些属性。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);          <span class="comment">// DECEMBER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></span><br></pre></td></tr></table></figure></p>
<p>想获取一个时区中其他的信息可以从 Instant 对象中转化来。Instant 实例可以很方便的转成 java.util.Date 对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line"></span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure></p>
<p>格式化 LocalDateTime 对象与格式化 LocalDate 和 LocalTime 对象是一样的，可以使用自定义的格式而不用提前定义好格式.</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></span><br></pre></td></tr></table></figure>
与 java.text.NumberFormat 不同，新的 DateTimeFormatter 是不可变而且是线程安全的。</p>
<p>更多的格式化的语法看 <a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener">这里</a>。</p>
<h4>注解</h4>
<p>Java8 中的注解是可复用的，下面有几个例子来演示这个特性。</p>
<p>首先，定义一个注释的包装器，包装了一个数组的的注解:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value=&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@interface</span> Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable</span>(Hints.class)</span><br><span class="line"><span class="meta">@interface</span> Hint &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java8 允许通过 @Repeatable 在相同的类型上使用多个注解。</p>
<p><strong>旧用法</strong>： 使用容器进行注解</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Hints</span>(&#123;<span class="meta">@Hint</span>(<span class="string">"hint1"</span>), <span class="meta">@Hint</span>(<span class="string">"hint2"</span>)&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>新用法</strong>： 使用可复用的注解</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint1"</span>)<span class="meta">@Hint</span>(<span class="string">"hint2"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用新用法时 Java 编译器隐式的使用了 @Hints 注解。这对于通过反射来读取注解非常重要。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Hint hint = Person.class.getAnnotation(Hint.class);</span><br><span class="line">System.out.println(hint);                   <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length);          <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>尽管没有在 Person 类上声明 @Hints 注解，但是它却可以通过 getAnnotation(Hints.class) 获取到。然而，更方便的方法则是通过 getAnnotationByType 直接获取所有使用了 @Hint 的注解。</p>
<p>另外，在 Java8 中使用注解可以扩展到两个新的 Target</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>（完）</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础系列-Java11特性解读</title>
    <url>/2019/11/09/Java%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97-Java11%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>Java11 是 Java8 之后的一个 LTS 版本。Java8 的 LTS 将在今年到期，在 Java8 之后，Java11 就是最好的选择了。Java9 到 Java11 的新特性虽然没有 Java8 的跨度大，但在虚拟机层面有了很大的升级。通过 <a href="https://winterbe.com/posts/2018/09/24/java-11-tutorial/" target="_blank" rel="noopener">Benjamin</a> 的这篇博客，我们来看看 Java11 有什么不同。</p>
<hr>
<p>Java11 一直都陷入困境中并且依然有很多的人在生产环境中使用 Java8。这篇文章会使用例子来讲解 Java9 到 Java11 中最重要的新特性。这篇文章使用代码来讲解新特性，不会有大段的文字。</p>
<h4>本地变量类型推断</h4>
<p>Java 10 中新增了一个关键字 <code>var</code>，在声明本地变量的时候用 <code>var</code>  就不需要写明具体的数据类型（本地变量是指在<strong>方法</strong>中声明的变量）。</p>
<p>在 Java 10 之前的版本中，你需要这样声明变量:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = <span class="string">"Hello Java 9"</span>;</span><br></pre></td></tr></table></figure>
在 Java 10，可以使用 <code>var</code> 替代 <code>String</code>。编译器会根据变量的赋值去推断变量的类型。在下面这个例子中 <code>text</code>  的类型是 <code>String</code>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"Hello Java 10"</span>;</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>var</code> 声明的变量依然是静态类型。不能对已经变量赋值另外一种类型。下面的这段代码会编译不通过：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"Hello Java 11"</span>;</span><br><span class="line">text = <span class="number">23</span>;</span><br></pre></td></tr></table></figure>
可以通过 <code>final</code> 来防止声明的 <code>var</code> 变量被重复赋值：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">var</span> text = <span class="string">"Banana"</span>;</span><br><span class="line">text = <span class="string">"Joe"</span>; <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure>
<code>var</code> 变量必须赋值一个明确类型的值，对于没有赋值或者编译器无法推断类型的变量，都会编译错误。下面的代码都无法通过编译：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> nothing = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">var</span> lambda = () -&gt; System.out.println(<span class="string">"Pity!"</span>);</span><br><span class="line"><span class="keyword">var</span> method = <span class="keyword">this</span>::someMethod;</span><br></pre></td></tr></table></figure>
本地类型推断在处理泛型代码时很好用。在下面的例子中，<code>current</code>  的类型是 <code>Map&lt;String, List&lt;Integer&gt;&gt;</code>，如果使用 <code>var</code> 来替代 <code>Map&lt;String, List&lt;Integer&gt;&gt;</code>，就可以少些很多样本代码：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myList = <span class="keyword">new</span> ArrayList&lt;Map&lt;String, List&lt;Integer&gt;&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> current : myList) &#123;</span><br><span class="line">    System.out.println(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Java 11 中 <code>var</code> 也可以用于 lambda 的参数，但是需要加上 <code>@Nullable</code> 注解：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (<span class="meta">@Nullable</span> <span class="keyword">var</span> a ) -&gt; <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Tip: 在 Intellij IDEA 中，可以通过选中一个变量，同时按下 <code>CMD/CTRL</code> 来显示变量的真实类型（对于键盘党可以使用 <code>CTRL + J</code>）。</p>
</blockquote>
<h4>HTTP Client</h4>
<p><code>Java 9</code> 中隐藏一个处理 Http 请求的新 API，<code>HttpClient</code>。到 <code>Java11</code> 这个 API 已经很完善了，就在 JDK 的 <code>java.net</code> 包下。来看看这个 API 可以做点什么。</p>
<p>这个新的 <code>HttpClient</code> 可以<strong>同步</strong>或者<strong>异步</strong>使用。同步的请求将会阻塞当前线程直到响应返回。<code>BodyHandlers</code> 定义了期望的返回数据类型。(e.g. 字符串、字节数组或者文件)：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">                   .uri(URI.create(<span class="string">"https://winterbe.com"</span>))</span><br><span class="line">                   .GET()</span><br><span class="line">                   .build();</span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.body());</span><br></pre></td></tr></table></figure>
同样的请求也可以进行异步处理。调用 <code>sendAsync</code> 不会阻塞当前线程并且会返回一个 <code>CompleteFuture</code> 来构建一个异步操作的管道。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">                   .uri(URI.create(<span class="string">"https://winterbe.com"</span>))</span><br><span class="line">                   .build();</span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">.thenApply(HttpResponse::body)</span><br><span class="line">.thenAccept(System.out::println);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可以省略 <code>.GET()</code>，默认的请求方法就是这个。</p>
</blockquote>
<p>下面的例子通过 <code>POST</code> 方法给一个 <code>URL</code> 发送数据。<code>BodyHandlers</code> 也可以用来定义请求中需要发送的数据的类型，比如<strong>字符串</strong>、<strong>字节数组</strong>、<strong>文件</strong>或者<strong>输入流</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">                   .uri(URI.create(<span class="string">"https://postman-echo.com/post"</span>))</span><br><span class="line">                   .header(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line">                   .POST(HttpRequest.BodyPublishers.ofString(<span class="string">"Hi there!"</span>))</span><br><span class="line">                   .build();</span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line"><span class="keyword">var</span> response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.statusCode());      <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
最后的这个例子演示了如何通过 <code>BASIC-AUTH</code> 来进行认证：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">    .uri(URI.create(<span class="string">"https://postman-echo.com/basic-auth"</span>))</span><br><span class="line">    .build();</span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newBuilder()</span><br><span class="line">    .authenticator(<span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(<span class="string">"postman"</span>, <span class="string">"password"</span>.toCharArray());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .build();</span><br><span class="line"><span class="keyword">var</span> response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.statusCode());      <span class="comment">// 200</span></span><br></pre></td></tr></table></figure></p>
<h4>Collections</h4>
<p>Java 中的容器比如 <code>List</code> 、<code>Set</code>、<code>Map</code> 已经扩展了很多新的方法。<code>List.of</code> 会根据参数创建一个新的不可变的 <code>list</code>，<code>List.copy</code> 会创建这个 <code>list</code>  的不可变副本。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line"><span class="keyword">var</span> copy = List.copyOf(List);</span><br><span class="line">System.out.println(list == copy); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
因为 <code>list</code> 已经是不可变的，在复制时没必要创建另一个实例，因此 <code>lisi</code> 和 <code>copy</code> 指向的是同一个实例。然而如果想复制一个可变的对象，就会创建一个新的实例来保证对原对象的修改不会影响到复制的对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">var</span> copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy);</span><br></pre></td></tr></table></figure></p>
<p>当创建不可变的 map 时候，不需要手动创建 map 对象，只需要使用 <code>Map.of</code> 方法交替传入 key 和 value 就可以。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = Map.of(<span class="string">"A"</span>, <span class="number">1</span>, <span class="string">"B"</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在 Java 11 中不可变容器的 API 没有变化。然而如果尝试对不可变的容器添加或者减少元素，就会抛出 <code>java.lang.UnsupportedOperationException</code> 异常。幸运的是 <code>Intellij IDEA</code> 会在你尝试修改不可变容器的时候发出一个警告。</p>
</blockquote>
<h4>Streams</h4>
<p><code>Streams</code> 是在 Java8 中加入的新特性，在后面的又加入了 3 个新的方法。
<code>Stream.ofNullable</code> 方法通过单个元素来构造流：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.ofNullable(<span class="keyword">null</span>)</span><br><span class="line">         .count();  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<code>dropWhile</code> 和 <code>takeWhile</code> 方法都可以接受一个 <code>predicate</code> 参数来决定是否将符合条件的元素从流中清理出去。</p>
<blockquote>
<p>predicate 是一个函数式编程的接口</p>
</blockquote>
<h4>Optionals</h4>
<p><code>Optionals</code> 也接收了一些相当有用的方法。比如现在可以将 optinals 很简单转成 stream 或者为一个空的 optional 返回另一个备用的 optional。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.of(<span class="string">"foo"</span>).orElseThrow();     <span class="comment">// foo</span></span><br><span class="line">Optional.of(<span class="string">"foo"</span>).stream().count();  <span class="comment">// 1</span></span><br><span class="line">Optional.ofNullable(<span class="keyword">null</span>)</span><br><span class="line">    .or(() -&gt; Optional.of(<span class="string">"fallback"</span>))</span><br><span class="line">    .get();                           <span class="comment">// fallback</span></span><br></pre></td></tr></table></figure></p>
<h4>Strings</h4>
<p><code>String</code> 这个基础的类也新增了一些方法来校验空格以及计算字符串的行数。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">" "</span>.isBlank();                <span class="comment">// true</span></span><br><span class="line"><span class="string">" Foo Bar "</span>.strip();          <span class="comment">// "Foo Bar"</span></span><br><span class="line"><span class="string">" Foo Bar "</span>.stripTrailing();  <span class="comment">// " Foo Bar"</span></span><br><span class="line"><span class="string">" Foo Bar "</span>.stripLeading();   <span class="comment">// "Foo Bar "</span></span><br><span class="line"><span class="string">"Java"</span>.repeat(<span class="number">3</span>);             <span class="comment">// "JavaJavaJava"</span></span><br><span class="line"><span class="string">"A\nB\nC"</span>.lines().count();    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<h4>InputStreams</h4>
<p>最后简单说一下 <code>InputStream</code> 提供了一个非常有用的方法来传输数据到 <code>OutputStream</code>，下面这个例子在传输原始数据的时候能经常看到。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"><span class="keyword">var</span> inputStream = classLoader.getResourceAsStream(<span class="string">"myFile.txt"</span>);</span><br><span class="line"><span class="keyword">var</span> tempFile = File.createTempFile(<span class="string">"myFileCopy"</span>, <span class="string">"txt"</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> outputStream = <span class="keyword">new</span> FileOutputStream(tempFile)) &#123;</span><br><span class="line">    inputStream.transferTo(outputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>其他的 JVM 特性</h4>
<p>上面的这些事我认为 Java8 到 Java11 中最有趣的新特性。但是新特性远远不止这些。下面的这些特性在最新的 Java 版本中都有：</p>
<ul>
<li><a href="https://community.oracle.com/docs/DOC-1006738" target="_blank" rel="noopener">Flow API for reactive programming</a></li>
<li><a href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html" target="_blank" rel="noopener">Java Module System</a></li>
<li><a href="https://blog.codefx.org/java/application-class-data-sharing/" target="_blank" rel="noopener">Application Class Data Sharing</a></li>
<li><a href="http://openjdk.java.net/jeps/309" target="_blank" rel="noopener">Dynamic Class-File Constants</a></li>
<li><a href="https://docs.oracle.com/javase/10/jshell/introduction-jshell.htm#JSHEL-GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8" target="_blank" rel="noopener">Java REPL (JShell)</a></li>
<li><a href="http://openjdk.java.net/jeps/328" target="_blank" rel="noopener">Flight Recorder</a></li>
<li><a href="http://openjdk.java.net/jeps/327" target="_blank" rel="noopener">Unicode 10</a></li>
<li><a href="https://blog.idrsolutions.com/2018/04/java-10-improvements-to-garbage-collection-explained-in-5-minutes/" target="_blank" rel="noopener">G1: Full Parallel Garbage Collector</a></li>
<li><a href="http://openjdk.java.net/jeps/333" target="_blank" rel="noopener">ZGC: Scalable Low-Latency Garbage Collector</a></li>
<li><a href="http://openjdk.java.net/jeps/318" target="_blank" rel="noopener">Epsilon: No-Op Garbage Collector</a></li>
<li><a href="http://openjdk.java.net/jeps/335" target="_blank" rel="noopener">Deprecate the Nashorn JavaScript Engine</a></li>
<li>...</li>
</ul>
<h4>下一步</h4>
<p>许多人（包括我）依然在生产环境中使用 Java8。然而到 2020 年，Java8 的 TLS 就结束了。所以现在是一个迁移到 Java11 的好机会。我写了一篇<a href="https://winterbe.com/posts/2018/08/29/migrate-maven-projects-to-java-11-jigsaw/" target="_blank" rel="noopener">迁移指南</a>来帮助你从 Java8 迁移到 Java11。同时你也应该读一下我的 <a href="https://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="noopener">Java8</a> 和 <a href="https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/" target="_blank" rel="noopener">Stream API</a> 的教程来学习如何使用更时髦的开发方式。这些源码都已经发布到 GitHub 上了，随便玩（如果喜欢的话，点一下 star）。</p>
<p>(完)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器系列-ArrayList源码分析</title>
    <url>/2019/12/01/Java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%97-ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>ArrayList 是使用的最为广泛的一个容器。ArrayList 的类的继承层次图如下:</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/Java/collection/ArrayList-Class.001.jpeg" alt=""></p>
<p>ArrayList 实现了 <code>Collection</code> 和 <code>List</code> 接口，同时也实现了 <code>Cloneable</code>、<code>RandomAccess</code>，所以 ArrayList 可以被拷贝以及具有随机访问的特性。</p>
<blockquote>
<p>本文基于 JDK1.8</p>
</blockquote>
<h3>成员变量</h3>
<p>在 ArrayList 类的头部，定义了以下几个成员变量。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></p>
<p>这几个变量构成了 ArrayList 的基础。</p>
<p><code>DEFAULT_CAPACITY</code> 表示 ArrayList 的初始容量。<code>elementData</code> 是存储具体数据的数组，也就是是说，ArrayList 底层数据结构就是一个数组，<code>size</code> 表示 ArrayList 中元素的个数。<code>EMPTY_ELEMENTDATA</code> 表示一个空的 ArrayList 对象，但 ArrayList 中没有数据时，elementData 指向的就是这个数组对象。<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 也表示空的 ArrayList，它只会在实例化一个不带参数的 ArrayList 的时候被使用一次：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 此时 elementData 指向的就是 DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br></pre></td></tr></table></figure></p>
<p>这些变量中需要注意的是 elementData 是不带访问修饰符的，这是为了让 ArrayList 的内部类可以方便的访问它，ArrayList 的内部类后面会讲到。elementData 变量是使用 transient 来修饰的，这表示在序列化的时候 elementData 是不会被序列化的，具体的序列化方式后面再讲。</p>
<h3>初始化过程</h3>
<p>在上面说到 <code>DEFAULT_CAPACITY</code> 是 ArrayList 的默认容量，值是10，但是需要注意的是，默认容量不一定用的上，在实例化 ArrayList 的时候分<strong>三种</strong>情况，第一种不给构造函数传参，但是此时会新建一个长度为 10 的对象数组。而是在<strong>添加第一个元素</strong>的时才会创建一个长度为 10 的数组，并把第一个元素添加进去。第二种情况会给构造参数传值 n，如果 n 大于0，那么就会直接创建一个长度为 n 的对象数组，如果 n 等于 0，那么就会把 EMPTY_ELEMENTDATA 赋值给 elementData。</p>
<p>第三种实例化特殊一点，是直接传入另一个容器对象 c 来初始化 ArrayList 对象，此时会先检查 c 的长度，如果 c 容器里面没有元素，直接把 EMPTY_ELEMENTDATA 赋值给 elementData，如果 c 不为空，就会 c 中的元素拷贝到 elementData 中。</p>
<h3>扩容过程</h3>
<p>扩容的过程可以用以下的流程图来表示：</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/Java/collection/ArrayList%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B.001.jpeg" alt=""></p>
<p>扩容对 ArrayList 来说是一个很重要的过程，这也是为什么它比数组好用的原因。</p>
<p>ArrayList 的扩容有两种方式，一个是自动扩容，一种是手动扩容。自动扩容每次会把当前容器的大小扩大 1.5 倍，手动扩容需要指定大小。既然已经有了自动扩容，那为什么还需要手动扩容呢？设想一个场景，实例化一个 ArrayList 之后，你大概知道会填充一万个元素，如果这个时候自动扩容的话要经过多次扩容才能装下这么多元素，但是手动指定容器大小的话只需要一次就可以了。</p>
<p>具体把 ArrayList 扩容到多大是由下面这段代码决定的:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>newCapacity</code> 是根据当前的元素的个数计算出来的，右移一位代表除以2，所以 newCapacity 为当前容量的 1.5 倍。然后这个值会与传入的值 <code>minCapacity</code> 进行对比，两个值哪个大就用哪个。</p>
<p>为什么每次自动扩容都能为当前大小的 1.5 倍呢？那是因为自动扩容的时候传入的 minCapacity 都只比当前的容量大 1，所以肯定小于 newCapacity。而 newCapacity 就是 当前容量大小的 1.5 倍。</p>
<p>当然有一个情况例外，那就是如果在实例化 ArrayList 没有指定大小的话，ArrayList 会至少扩容到 10。这一机制是靠以下代码实现的:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">   <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br></pre></td></tr></table></figure></p>
<p>扩容的时候，都是使用 <code>Arrays.copyOf</code> 将元素拷贝到新的容器中。所以基本都是 $O(N)$ 的时间复杂度，代价很大。所以尽可能减少扩容的次数。</p>
<blockquote>
<p>注意：ArrayList 没有缩容的过程。</p>
</blockquote>
<h3>具体实现</h3>
<p>ArrayList 中有了很多的方法，这些方法核心都是围绕 elementData 操作的。</p>
<p><code>siez()</code> 和 <code>isEmpty()</code> 方法想着简单，一个用来返回容器中的元素的数量，一个用来判断容器是否为空。</p>
<p><code>clone()</code> 、 <code>toArray()</code> 和 <code>toArray(T[] a)</code> 这三个方法本质上都是对容器当前的元素做一个备份，都用到了 <code>Arrays.copyOf()</code> 方法。但是需要注意的是 <code>toArray(T[] a)</code> 的实现:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a's runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个方法中除了使用 <code>Arrays.copyOf()</code> 还用到了 <code>System.arraycopy()</code>，其实 Arrays.copyOf() 底层就是使用 System.arraycopy() 方法实现的。但是区别在于前者会返回一个一个新的数组，后者则是直接在原数组上进行操作。</p>
<p>ArrayList 中的 <code>add()</code>、<code>get()</code> 、<code>set()</code>、<code>remove()</code> 等方法用于元素的增删改查，实现并不复杂，只是在操作元素之前需要对容器的 size 进行检查，如果不满足操作要求，就会报出异常。</p>
<p><code>euqal()</code> 类的方法主要都是对比每个元素的类型、顺序和值是否一致。</p>
<p>在 JDK1.8 以后，出现了 <code>removeIf()</code> 方法，这个方法使得从容器中删除元素变得很简单。</p>
<h4>迭代器</h4>
<p>ArrayList 中有两个内部类 <code>Itr</code> 和 <code>ListItr</code>，主要方法如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ListItr 继承了 Itr，这两个内部类都实现了迭代器模式，用于遍历 ArrayList 的元素。从上面的方法可知，Itr 和 ListItr 最大的区别在于 ListItr 可以从两个方向对容器的元素进行遍历。而 Itr 只能使用顺着一个方向进行遍历。</p>
<p>在 JDK1.8 以后，ArrayList 中有一个 <code>ArrayListSpliterator</code> 内部类，这个类用于分割容器。用于提升多线程环境中的处理效率：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">Spliterator&lt;Integer&gt; s0 = list.spliterator();</span><br><span class="line">System.out.println(s0.estimateSize()); <span class="comment">// 5</span></span><br><span class="line">Spliterator&lt;Integer&gt; s1 = s0.trySplit();</span><br><span class="line">System.out.println(s1.estimateSize()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<code>s0</code> 中有 10 个元素，在调用 <code>s0.trySplit()</code> 方法之后，s0 和 s1 中各有 5 个元素。然后可以对分割开的元素进行处理:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s0.forEachRemaining(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure></p>
<h4>SubList</h4>
<p>ArrayList 中还有一个内部类 <code>SubList</code>。SubList 用于返回 ArrayList 的一部分元素，内部的操作方法与 ArrayList 基本一致，但是需要注意的是，对 SubList 的操作会直接影响到原 ArrarList。</p>
<h4>fail-fast 机制</h4>
<p>在 ArrayList 中，<code>checkForComodification()</code> 和 <code>ConcurrentModificationException()</code> 使用的频率很高。这个和 fail-fast 机制有关。</p>
<p>ArrayList 不是线程安全的，所以在对容器操作的过程中，容器的元素倍其他的操作或者线程修改之后，就会出现 ConcurrentModificationException 异常。checkForComodification() 方法就是用来检查元素是否被修改。这个机制就称之为 <code>fail-fast</code>。</p>
<p>后续会有其他的文章来介绍 <code>fail-fast</code>。</p>
<p>(完)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础系列-Stream简明教程</title>
    <url>/2019/11/15/Java%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97-Stream%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><code>Stream</code> 是 Java8 中一个重大的更新。Stream 为Java 真正带来了函数式编程的特性。对函数式编程不了解的人往往不知道如何动手，通过<a href="https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/" target="_blank" rel="noopener">Benjamin</a> 的教程来完整的学习一下 Java 的这个特性，学会这些技能会让你的代码看起来更酷。</p>
<hr>
<p>这是一个通过代码示例来深度讲解 <code>Java8 Stream</code> 的教程。当我第一次看到 <code>Stream</code> 的 API 时，我感到很迷惑，因为这个名称听起来和 Java I/O 包中的 <code>InputStream</code> 和 <code>OutputStream</code> 有关系。但是实际上它们是完全不同的东西。 Stream 是 <a href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29" target="_blank" rel="noopener">Monad(函数式编程)</a>，它为 Java 带来了函数式编程的特性，下面是维基百科对 Monad 的解释:</p>
<blockquote>
<p>In functional programming, a monad is a structure that represents computations defined as sequences of steps. A type with a monad structure defines what it means to chain operations, or nest functions of that type together.</p>
</blockquote>
<p>这份教程会讲解 Java8 Stream 的原理以及不同<strong>操作</strong>之间的区别。你将会学习到 <code>Stream</code> 操作的处理顺序以及不同的顺序对性能的影响。还会对常用的操作如 <code>Reduce</code> 、<code>collect</code> 、<code>flatMap</code> 进行详细讲解。在教程的最后会说明并行 <code>Stream</code> 的优点。</p>
<blockquote>
<p>注：Stream 中的 API 称之为操作</p>
</blockquote>
<p>如果你还不熟悉 Java8 的 lambda 表达式、函数式接口以及方法引用，可以先去读一下这份<a href="https://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="noopener">Java8 教程</a>。</p>
<h3>Stream 原理</h3>
<p>一个 Stream 代表着一组元素以及支持对这些元素进行计算的不同<strong>操作</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; myList =</span><br><span class="line">    Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"c2"</span>, <span class="string">"c1"</span>);</span><br><span class="line"></span><br><span class="line">myList</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">"c"</span>))</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C1</span></span><br><span class="line"><span class="comment">// C2</span></span><br></pre></td></tr></table></figure>
Stream 操作分为<strong>中间操作</strong>和<strong>终端操作</strong>。中间操作会返回一个 Stream 对象，所以可以对中间操作进行<strong>链式操作</strong>。终端操作会返回一个 <code>void</code> 或者非 Stream 的对象。在上面的例子中，<code>filter</code>、<code>map</code> 和 <code>sorted</code> 都是中间操作，而 <code>forEach</code> 则是一个终端操作。Stream 完整的操作 API 可以查看<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener">文档</a>。Stream 链式操作可以查看上面的例子，链式操作也称之为<strong>管道操作</strong>。</p>
<p>许多 Stream 操作接受 Lambda 或者函数式接口来限定操作范围。这些操作中绝大多数都必须是<strong>non-interfering</strong>和<strong>无状态</strong>的，这是什么意思呢？</p>
<blockquote>
<p>注：在函数式编程中，函数本身是可以作为参数的</p>
</blockquote>
<p><strong>non-interfering</strong> 表示方法在执行的过程中不会改动流中原数据，比如在前面的例子中没有 lambda 表达式修改了 <code>myList</code> 中的元素。</p>
<p><strong>无状态</strong>表示方法多次执行的结果是确定的，比如前面的例子中没有 lambda 表达式会依赖在执行过程中会被修改的外部作用域中的变量。</p>
<h3>不同种类的 Stream</h3>
<p>Stream 可以通过多种方式创建，尤其是各种容器对象。List 和 Set 都支持 <code>stream()</code> 和 <code>parallelStream()</code> 方法来创建串行或者并行的 Stream。并行 Stream 可以同时运行在多个线程上，在下文会详细讲解，当前先通过串行 Stream 来演示：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>)</span><br><span class="line">        .stream()</span><br><span class="line">        .findFirst()</span><br><span class="line">        .ifPresent(System.out::println); <span class="comment">//a1</span></span><br></pre></td></tr></table></figure></p>
<p>调用 List 的 <code>stream()</code> 方法会返回一个 Stream 对象。但是得到 Stream 对象不一定要创建 Collection 对象，看下面的代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>)</span><br><span class="line">         .findFirst()</span><br><span class="line">         .ifPresent(System.out.println);</span><br></pre></td></tr></table></figure>
只需要通过 <code>Stream.of()</code> 就可以把一堆对象创建为 Stream。</p>
<p>另外在 Java8 还可以通过 <code>IntStream</code>，<code>LongStream</code> 和 <code>DoubleStream</code> 等来操作原生数据类型 <code>int</code>，<code>long</code> 和 <code>double</code>。</p>
<p>IntStream 通过 <code>range()</code> 方法可以替代 for 循环：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line"> <span class="comment">// 1</span></span><br><span class="line"> <span class="comment">// 2</span></span><br><span class="line"> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>所有的原生类型都可以和其他对象一样使用 Stream，但是所有的原生类型 Stream 都使用专门的 lambda 表达式，比如 int 使用 <code>IntFunction</code> 而不是 <code>Function</code>，使用 <code>IntPredicate</code> 而不是 <code>Predicate</code>。</p>
<p>并且原生类型 Stream 还另外支持终端聚合操作 <code>sum()</code> 以及 <code>average()</code>:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">    .map(n -&gt; <span class="number">2</span> * n + <span class="number">1</span>)</span><br><span class="line">    .average()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// 5.0</span></span><br></pre></td></tr></table></figure>
这些操作在将对象转化为原生类型的时候非常有用，反之亦然。出于这个目的，普通 Stream 支持特别的 map 操作，比如 <code>mapToInt()</code>，<code>mapToLong()</code> 和 <code>mapToDouble()</code>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>)</span><br><span class="line">    .map(s -&gt; s.substring(<span class="number">1</span>))</span><br><span class="line">    .mapToInt(Integer::parseInt)</span><br><span class="line">    .max()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>原生数据类型可以通过 <code>mapToObj()</code> 转化为对象：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .mapToObj(i -&gt; <span class="string">"a"</span> + i)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a1</span></span><br><span class="line"><span class="comment">// a2</span></span><br><span class="line"><span class="comment">// a3</span></span><br></pre></td></tr></table></figure></p>
<p>下面这个例子是一个组合操作：double Stream 的元素首先被转成 int 最后被转化成 String：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">    .mapToInt(Double::intValue)</span><br><span class="line">    .mapToObj(i -&gt; <span class="string">"a"</span> + i)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a1</span></span><br><span class="line"><span class="comment">// a2</span></span><br><span class="line"><span class="comment">// a3</span></span><br></pre></td></tr></table></figure></p>
<h3>处理次序</h3>
<p>上文中已经详细描述了如何创建和使用不同类型的 Stream，下面会深入研究 Stream 的操作是如何进行的。</p>
<p>中间操作的一个重要特征是<strong>延迟</strong>，看下面这个没有终端操作的例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>当上面的代码片段执行完成的时候，控制台并没有输出任何东西。这是因为中间操作在有终端操作的时候才会执行。</p>
<p>给上面的例子加上终端操作 <code>forEach</code>:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span> + s));</span><br></pre></td></tr></table></figure></p>
<p>执行这段代码会有如下的输出：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter:  d2</span><br><span class="line">forEach: d2</span><br><span class="line">filter:  a2</span><br><span class="line">forEach: a2</span><br><span class="line">filter:  b1</span><br><span class="line">forEach: b1</span><br><span class="line">filter:  b3</span><br><span class="line">forEach: b3</span><br><span class="line">filter:  c</span><br><span class="line">forEach: c</span><br></pre></td></tr></table></figure></p>
<p>输出结果的顺序可能会让人惊讶。之前你可能会认为 Stream 中的元素会在一个操作中全部处理完之后才会进入到下一个操作。但实际的情况是一个元素在所有的操作执行完成之后才会轮到下一个元素。<code>&quot;d2&quot;</code> 首先被 <code>filter</code> 和 <code>forEach</code> 的处理，然后 <code>&quot;a2&quot;</code> 才会被处理。</p>
<p>这样可以减少每个操作实际处理元素的个数，看下面这个例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"map: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .anyMatch(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"anyMatch: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">"A"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map:      d2</span></span><br><span class="line"><span class="comment">// anyMatch: D2</span></span><br><span class="line"><span class="comment">// map:      a2</span></span><br><span class="line"><span class="comment">// anyMatch: A2</span></span><br></pre></td></tr></table></figure></p>
<p>这个 <code>anyMatch</code> 操作只在输入元素满足条件的情况下才会返回 true。在上面的例子中，运行到第二个元素 &quot;a2&quot; 时就会返回 true，然后就会停止处理其他元素，所以 <code>map</code> 操作也只是执行了两次，这正是得益于 Stream 的链式处理次序。</p>
<h4>为什么次序很关键</h4>
<p>下面的这个例子由两个中间操作 <code>map</code> 和 <code>filter</code> 以及一个终端操作 <code>forEach</code> 组成。再看一下这些操作是如何执行的：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"map: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">"A"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span> + s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// map:     d2</span></span><br><span class="line"><span class="comment">// filter:  D2</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// filter:  A2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br><span class="line"><span class="comment">// map:     b1</span></span><br><span class="line"><span class="comment">// filter:  B1</span></span><br><span class="line"><span class="comment">// map:     b3</span></span><br><span class="line"><span class="comment">// filter:  B3</span></span><br><span class="line"><span class="comment">// map:     c</span></span><br><span class="line"><span class="comment">// filter:  C</span></span><br></pre></td></tr></table></figure></p>
<p>正如上面的例子所分析，map 和 filter 对每个字符串各执行了 5 次，而 forEach 仅仅执行了一次。</p>
<p>可以简单的调整操作的顺序来减少操作执行的总次数，下面的例子中把 filter 操作放到了 map 前面：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">"a"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"map: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span> + s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter:  d2</span></span><br><span class="line"><span class="comment">// filter:  a2</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br><span class="line"><span class="comment">// filter:  b1</span></span><br><span class="line"><span class="comment">// filter:  b3</span></span><br><span class="line"><span class="comment">// filter:  c</span></span><br></pre></td></tr></table></figure></p>
<p>调整后，map 只执行了一次，整个操作管道在输入大量元素时的执行速度会快很多。如果 Stream 有很多的操作，时序考虑一下能不能通过调整持续来优化。</p>
<p>在上面的例子中另外加上 <code>sorted</code> 操作：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.printf(<span class="string">"sort: %s; %s\n"</span>, s1, s2);</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">"a"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"map: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span> + s));</span><br></pre></td></tr></table></figure></p>
<p>sotred 是一个另类的中间操作，它是有状态的。因为在排序的过程中必须要维护数据的状态。</p>
<p>执行上面的例子会产生如下输出：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sort:    a2; d2</span><br><span class="line">sort:    b1; a2</span><br><span class="line">sort:    b1; d2</span><br><span class="line">sort:    b1; a2</span><br><span class="line">sort:    b3; b1</span><br><span class="line">sort:    b3; d2</span><br><span class="line">sort:    c; b3</span><br><span class="line">sort:    c; d2</span><br><span class="line">filter:  a2</span><br><span class="line">map:     a2</span><br><span class="line">forEach: A2</span><br><span class="line">filter:  b1</span><br><span class="line">filter:  b3</span><br><span class="line">filter:  c</span><br><span class="line">filter:  d2</span><br></pre></td></tr></table></figure></p>
<p>首先，sorted 会把输入的所有元素排好序之后才会进入下一个操作，和其他操作不同，sorted 是水平执行的。所以在上面的例子中 sorted 才会被执行 8 次。</p>
<p>通过调整操作的次序可以再一次提升执行的性能：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">"a"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.printf(<span class="string">"sort: %s; %s\n"</span>, s1, s2);</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"map: "</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span> + s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter:  d2</span></span><br><span class="line"><span class="comment">// filter:  a2</span></span><br><span class="line"><span class="comment">// filter:  b1</span></span><br><span class="line"><span class="comment">// filter:  b3</span></span><br><span class="line"><span class="comment">// filter:  c</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中 sorted 永远也不会被执行，在 filter 执行完了之后就剩下一个元素，也就没有排序的必要。在输入大量元素的情况下，性能也会得到极大的提升。</p>
<h3>重用 Stream</h3>
<p>Java8 中的 Stream 是不能被重用的。一旦执行了终端操作，那么 Stream 就会被关闭：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream =</span><br><span class="line">    Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">        .filter(s -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">stream.anyMatch(s -&gt; <span class="keyword">true</span>);    <span class="comment">// ok</span></span><br><span class="line">stream.noneMatch(s -&gt; <span class="keyword">true</span>);   <span class="comment">// exception</span></span><br></pre></td></tr></table></figure></p>
<p>在 anyMatch 之后调用 noneMatch 会产生如下的异常：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br><span class="line">    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)</span><br><span class="line">    at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459)</span><br><span class="line">    at com.winterbe.java8.Streams5.test7(Streams5.java:38)</span><br><span class="line">    at com.winterbe.java8.Streams5.main(Streams5.java:28)</span><br></pre></td></tr></table></figure></p>
<p>如果需要解决这一点，可以为每一个终端操作创建一个新的 Stream，比如可以使用 <code>Supplier</code> 来创建所有中间操作已经执行完成的 Stream：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier =</span><br><span class="line">    () -&gt; Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">            .filter(s -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">streamSupplier.get().anyMatch(s -&gt; <span class="keyword">true</span>);   <span class="comment">// ok</span></span><br><span class="line">streamSupplier.get().noneMatch(s -&gt; <span class="keyword">true</span>);  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></p>
<p>每调用一次 <code>get()</code> 方法都会创建一个新的 Stream，然后就可以执行需要执行的终端操作了。</p>
<h3>进阶操作</h3>
<p>Stream 支持大量不同的操作，在上面的例子中已经介绍了最重要的操作如 <code>filter</code> 和 <code>map</code>。完整的操作可以在<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener">官方文档</a>中查看。下面会重点介绍更加复杂的操作 <code>collect</code>、<code>flatMap</code> 和 <code>reduce</code>。</p>
<p>这节绝大部分的代码例子都会使用下面 <code>Person</code> list 作为演示数据：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; persons =</span><br><span class="line">    Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Max"</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Peter"</span>, <span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Pamela"</span>, <span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"David"</span>, <span class="number">12</span>));</span><br></pre></td></tr></table></figure></p>
<h4>Collect</h4>
<p>如果需要将 Stream 中运行的结果转成一个不同的类型，比如 List、Set 或者 Map，<code>collect</code> 就非常有用。<code>collect</code> 操作接受由 <code>suppiler</code>，<code>accumulator</code>，<code>combiner</code>，<code>finisher</code> 等四个部分组成的 <code>Collector</code> 对象。听起来很复杂，但 java8 中 <code>Collectors</code> 类中的大量方法开箱即用，对很多通用的操作并不需要自己去实现：</p>
<blockquote>
<p>注：suppiler, accumulator, combiner, finisher 都是函数式接口</p>
</blockquote>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; filtered =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .filter(p -&gt; p.name.startsWith(<span class="string">"P"</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(filtered);    <span class="comment">// [Peter, Pamela]</span></span><br></pre></td></tr></table></figure></p>
<p>很简单就可以从 Stream 中获取一个 List，如果需要一个 Set，调用 <code>Collectors.toSet()</code> 就行了。</p>
<p>下面的这个例子是通过年龄来给 person 分组:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">personsByAge</span><br><span class="line">    .forEach((age, p) -&gt; System.out.format(<span class="string">"age %s: %s\n"</span>, age, p));</span><br><span class="line"></span><br><span class="line"><span class="comment">// age 18: [Max]</span></span><br><span class="line"><span class="comment">// age 23: [Peter, Pamela]</span></span><br><span class="line"><span class="comment">// age 12: [David]</span></span><br></pre></td></tr></table></figure></p>
<p><code>Collectors</code> 功能很多，还可以用来对 Stream 中的元素做聚合操作，比如计算所有 person 的平均年龄：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double averageAge = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.averagingInt(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">System.out.println(averageAge);     <span class="comment">// 19.0</span></span><br></pre></td></tr></table></figure></p>
<p>还可以用来做统计，<code>summarizing</code> 会返回一个内建的统计对象，通过这个对象可以很方便的得到最大年龄、最小年龄、平均年龄等统计结果：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntSummaryStatistics ageSummary =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(Collectors.summarizingInt(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">System.out.println(ageSummary);</span><br><span class="line"><span class="comment">// IntSummaryStatistics&#123;count=4, sum=76, min=12, average=19.000000, max=23&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>下面的例子中把所有 person 的名字拼成了一个字符串：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String phrase = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.age &gt;= <span class="number">18</span>)</span><br><span class="line">    .map(p -&gt; p.name)</span><br><span class="line">    .collect(Collectors.joining(<span class="string">" and "</span>, <span class="string">"In Germany "</span>, <span class="string">" are of legal age."</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(phrase);</span><br><span class="line"><span class="comment">// In Germany Max and Peter and Pamela are of legal age.</span></span><br></pre></td></tr></table></figure>
joining 接收一个间隔符和<strong>可选的</strong>前缀、后缀字符串。</p>
<p>为了输出 <code>map</code> 结果。必须指定 map 的 key 和 value。需要注意 key 必须是唯一的，否则会报 <code>IllegalStateException</code> 异常。可以通过传入另外一个合并方法作为参数来避免这个异常：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.toMap(</span><br><span class="line">        p -&gt; p.age,</span><br><span class="line">        p -&gt; p.name,</span><br><span class="line">        (name1, name2) -&gt; name1 + <span class="string">";"</span> + name2));</span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">// &#123;18=Max, 23=Peter;Pamela, 12=David&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面介绍了一些很强大 Collectors 的内建方法。下面来实现一个自定义的 <code>collector</code>。将所有 Person 的名称转成大写并输入到一个字符串中，每个名字使用 <code>|</code> 来隔开。自定义的 collecotr 使用 <code>Collecotr.of()</code> 来实现，需要实现其中的四个部分：<code>supplier</code>、<code>accumulator</code>、<code>combiner</code> 和 <code>finisher</code>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;Person, StringJoiner, String&gt; personNameCollector =</span><br><span class="line">    Collector.of(</span><br><span class="line">        () -&gt; <span class="keyword">new</span> StringJoiner(<span class="string">" | "</span>),          <span class="comment">// supplier</span></span><br><span class="line">        (j, p) -&gt; j.add(p.name.toUpperCase()),  <span class="comment">// accumulator</span></span><br><span class="line">        (j1, j2) -&gt; j1.merge(j2),               <span class="comment">// combiner</span></span><br><span class="line">        StringJoiner::toString);                <span class="comment">// finisher</span></span><br><span class="line"></span><br><span class="line">String names = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(personNameCollector);</span><br><span class="line"></span><br><span class="line">System.out.println(names);  <span class="comment">// MAX | PETER | PAMELA | DAVID</span></span><br></pre></td></tr></table></figure></p>
<p>在 Java 中，String 对象是不可变的。所以需要一个 <code>StringJoiner</code> 来组合字符串，<code>suppiler</code> 实例化一个带 <code>|</code> 分隔符的 StringJoiner 对象。<code>accumulator</code> 把字符串转成大写并且放进 StringJoiner 对象，<code>combiner</code> 将两个 StringJoiner 对象合成一个，最后 <code>finisher</code> 把 StringJoiner 对象输出为 String 对象。</p>
<h4>flatMap</h4>
<p>在上面已经介绍了如何使用 map 将 Stream 中的对象转成另外一种类型的对象。<code>map</code> 只能把一种类型转成另外一种特定的类型，在把一种类型转成任意种类型的情况下，<code>map</code> 就有点受限制了。而 <code>flatMap</code> 正是来解决这个问题的。</p>
<p>flatMap 会把 Stream 中的每个元素转成另一个 Stream 中的其他对象。所以每个元素依赖 STream 会被转成 0 个，1 个或者多个其他对象。这些生成的新的 stream 会在 flatMap 操作结束的时候返回。</p>
<p>在使用 flatMap 之前，需要定义以下的数据结构：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    List&lt;Bar&gt; bars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Foo(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Bar(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，利用 Stream 初始化一些对象：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Foo&gt; foos = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// create foos</span></span><br><span class="line">IntStream</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .forEach(i -&gt; foos.add(<span class="keyword">new</span> Foo(<span class="string">"Foo"</span> + i))); </span><br><span class="line"></span><br><span class="line"><span class="comment">// create bars</span></span><br><span class="line">foos.forEach(f -&gt;</span><br><span class="line">    IntStream</span><br><span class="line">        .range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        .forEach(i -&gt; f.bars.add(<span class="keyword">new</span> Bar(<span class="string">"Bar"</span> + i + <span class="string">" &lt;- "</span> + f.name))));</span><br></pre></td></tr></table></figure></p>
<p>现在，生成了包含三个 foo 对象的 list，每个 foo 对象中又包含三个 bar 对象。</p>
<p>flatMap 接收一个返回 Stream 对象的方法作为参数，为了分解 foo 中的每个 bar 对象，传入一个合适的方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">foos.stream()</span><br><span class="line">    .flatMap(f -&gt; f.bars.stream())</span><br><span class="line">    .forEach(b -&gt; System.out.println(b.name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bar1 &lt;- Foo1</span></span><br><span class="line"><span class="comment">// Bar2 &lt;- Foo1</span></span><br><span class="line"><span class="comment">// Bar3 &lt;- Foo1</span></span><br><span class="line"><span class="comment">// Bar1 &lt;- Foo2</span></span><br><span class="line"><span class="comment">// Bar2 &lt;- Foo2</span></span><br><span class="line"><span class="comment">// Bar3 &lt;- Foo2</span></span><br><span class="line"><span class="comment">// Bar1 &lt;- Foo3</span></span><br><span class="line"><span class="comment">// Bar2 &lt;- Foo3</span></span><br><span class="line"><span class="comment">// Bar3 &lt;- Foo3</span></span><br></pre></td></tr></table></figure></p>
<p>上面那个例子成功的把一个包含三个 foo 对象的 Stream 转成了包含 9 个 bar 对象的 Stream。</p>
<p>而且，上面的那些代码可以被简化成一个 Stream 管道操作：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .mapToObj(i -&gt; <span class="keyword">new</span> Foo(<span class="string">"Foo"</span> + i))</span><br><span class="line">    .peek(f -&gt; IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        .mapToObj(i -&gt; <span class="keyword">new</span> Bar(<span class="string">"Bar"</span> + i + <span class="string">" &lt;- "</span> f.name))</span><br><span class="line">        .forEach(f.bars::add))</span><br><span class="line">    .flatMap(f -&gt; f.bars.stream())</span><br><span class="line">    .forEach(b -&gt; System.out.println(b.name));</span><br></pre></td></tr></table></figure></p>
<p>flatMap 操作对 java8 中的 <code>Optional</code> 对象也有用，Optional 对象的操作会返回另一个类型的 Optional 对象。所以这个特性可以用来消除空指针检查。</p>
<p>定义类的抽象层次如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    Nested nested;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">    Inner inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    String foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了从 Outer 对象中调用 Inner 对象中的 foo 字符串，需要做很多的空指针检查来避免潜在的空指针异常：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line"><span class="keyword">if</span> (outer != <span class="keyword">null</span> &amp;&amp; outer.nested != <span class="keyword">null</span> &amp;&amp; outer.nested.inner != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(outer.nested.inner.foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些操作可以通过 flatMap 来进行优化：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.of(<span class="keyword">new</span> Outer())</span><br><span class="line">    .flatMap(o -&gt; Optional.ofNullable(o.nested))</span><br><span class="line">    .flatMap(n -&gt; Optional.ofNullable(n.inner))</span><br><span class="line">    .flatMap(i -&gt; Optional.ofNullable(i.foo))</span><br><span class="line">    .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure></p>
<p>每调用一次都会返回一个 Optional 对象，对象中包裹着目标对象或者 null。</p>
<h4>Reduce</h4>
<p><code>Reduce</code> 组合 Stream 中所有的元素，然后产生一个单独的结果。Java8 支持三种 <code>reduce</code> 方法。第一种 reduce 对于每个 Stream 只会返回一个元素。下面这个例子计算除了年龄最大的人的名字：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2)</span><br><span class="line">    .ifPresent(System.out::println);    <span class="comment">// Pamela</span></span><br></pre></td></tr></table></figure></p>
<p>reduce 方法接受一个 <code>BinaryOperator</code> 函数。在 Person 这个例子中，实际上是一个 <code>BiFunction</code>，两个操作数的类型都是一致的。BiFunction 与 Function 很像，但是前者接收两个参数。这个例子中比较所有 person 的年龄属性来找出最大年龄的 person。</p>
<p>第二种 reduce 方法接受一个目标对象和一个 <code>BinaryOperator</code>。下面这个方法可以聚合所有的 person 属性来创建一个新的 person：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person result =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .reduce(<span class="keyword">new</span> Person(<span class="string">""</span>, <span class="number">0</span>), (p1, p2) -&gt; &#123;</span><br><span class="line">            p1.age += p2.age;</span><br><span class="line">            p1.name += p2.name;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">System.out.format(<span class="string">"name=%s; age=%s"</span>, result.name, result.age);</span><br><span class="line"><span class="comment">// name=MaxPeterPamelaDavid; age=76</span></span><br></pre></td></tr></table></figure></p>
<p>第三种 reduce 接受三个参数：一个目标对象、一个 BiFunction、一个 <code>BinaryOperator</code> 类型的 combiner。因为这个传入的值不一定是 Person 类型，所以我们可以利用这个特性来计算所有 Person 年龄的总和：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer ageSum = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2);</span><br><span class="line"></span><br><span class="line">System.out.println(ageSum);  <span class="comment">// 76</span></span><br></pre></td></tr></table></figure></p>
<p>最后的结果是 76，那么中间的计算过程是什么样的的呢？下面 debug 了计算的过程:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer ageSum = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"accumulator: sum=%s; person=%s\n"</span>, sum, p);</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"combiner: sum1=%s; sum2=%s\n"</span>, sum1, sum2);</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Max</span></span><br><span class="line"><span class="comment">// accumulator: sum=18; person=Peter</span></span><br><span class="line"><span class="comment">// accumulator: sum=41; person=Pamela</span></span><br><span class="line"><span class="comment">// accumulator: sum=64; person=David</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到 <code>accumulator</code> 函数完成了所有的计算，调用的第一次得到的是初始值 0 和 Max person。然后后续的三步完成了所有年龄的的累加。在最后一步得到了所有年龄的累加结果 76。</p>
<p>但是上面的例子看起来稍微有点问题，因为 combiner 函数根本没有执行，但是真的是这样的吗？看下面的代码我们就能发现秘密所在：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer ageSum = persons</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"accumulator: sum=%s; person=%s\n"</span>, sum, p);</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"combiner: sum1=%s; sum2=%s\n"</span>, sum1, sum2);</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Pamela</span></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=David</span></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Max</span></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Peter</span></span><br><span class="line"><span class="comment">// combiner: sum1=18; sum2=23</span></span><br><span class="line"><span class="comment">// combiner: sum1=23; sum2=12</span></span><br><span class="line"><span class="comment">// combiner: sum1=41; sum2=35</span></span><br></pre></td></tr></table></figure></p>
<p>在并行执行的情况下有着完全不同的执行行为。在这里 combiner 执行了，accumulator 在并行情况下被执行的时候，combiner 用来累加 accumulator 的执行结果。</p>
<p>在下一节会详细分析并行 Stream。</p>
<h3>并行 Stream</h3>
<p>在输入元素数量很多的情况下，通过并行执行 Stream 可以提升执行性能。并行 Stream 使用了 <code>ForkJoinPool</code>，这个对象可以通过 <code>ForkJoinPool.commonPool()</code> 来得到。底层的线程池最多可以有五个线程，取决于物理机器可以用的 CPU 有几个。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ForkJoinPool commonPool = ForkJoinPool.commonPool();</span><br><span class="line">System.out.println(commonPool.getParallelism());    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>在我的机器上这个线程的数量被设定为 3。这个值可以通过 JVM 的参数来进行调整：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Djava.util.concurrent.ForkJoinPool.common.parallelism=<span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>Collection 对象可以通过 <code>parallelStream()</code> 来创建一个并行的 Stream。或者也可以对一个串行的 Stream 对象调用 <code>parallel()</code> 来转成并行 Stream。</p>
<p>为了理解 Stream 是如何并行执行的，下面这个例子把线程的情况都打印出来了：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"c2"</span>, <span class="string">"c1"</span>)</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">"filter: %s [%s]\n"</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">"map: %s [%s]\n"</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.format(<span class="string">"forEach: %s [%s]\n"</span>,</span><br><span class="line">        s, Thread.currentThread().getName()));</span><br></pre></td></tr></table></figure></p>
<p>通过研究 debug 输出，可以看到 Stream 执行过程中哪些线程确实用到了：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter:  b1 [main]</span><br><span class="line">filter:  a2 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">map:     a2 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">filter:  c2 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">map:     c2 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">filter:  c1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">map:     c1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">forEach: C2 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">forEach: A2 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">map:     b1 [main]</span><br><span class="line">forEach: B1 [main]</span><br><span class="line">filter:  a1 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">map:     a1 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">forEach: A1 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">forEach: C1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<p>并行 Stream 执行操作的过程中用到了线程池中所有的线程。上面输出的结果顺序可能每次都是不一样的，这是因为线程执行的顺序本身就是不一样的。</p>
<p>给上面的例子加上 <code>sort</code> 操作：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"c2"</span>, <span class="string">"c1"</span>)</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">"filter: %s [%s]\n"</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">"map: %s [%s]\n"</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">"sort: %s &lt;&gt; %s [%s]\n"</span>,</span><br><span class="line">            s1, s2, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.format(<span class="string">"forEach: %s [%s]\n"</span>,</span><br><span class="line">        s, Thread.currentThread().getName()));</span><br></pre></td></tr></table></figure></p>
<p>执行的结果看起来有点奇怪：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter:  c2 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">filter:  c1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">map:     c1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">filter:  a2 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">map:     a2 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">filter:  b1 [main]</span><br><span class="line">map:     b1 [main]</span><br><span class="line">filter:  a1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">map:     a1 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">map:     c2 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">sort:    A2 &lt;&gt; A1 [main]</span><br><span class="line">sort:    B1 &lt;&gt; A2 [main]</span><br><span class="line">sort:    C2 &lt;&gt; B1 [main]</span><br><span class="line">sort:    C1 &lt;&gt; C2 [main]</span><br><span class="line">sort:    C1 &lt;&gt; B1 [main]</span><br><span class="line">sort:    C1 &lt;&gt; C2 [main]</span><br><span class="line">forEach: A1 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">forEach: C2 [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">forEach: B1 [main]</span><br><span class="line">forEach: A2 [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">forEach: C1 [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>可以看到了 sort 操作只会在主线程中执行。并行 Stream 中的 sort 操作实际用到了 Java8 中的新接口 <code>Arrays.parallelSort()</code>。在 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#parallelSort-T:A-" target="_blank" rel="noopener">Javadoc</a> 中说明了数组的长度决定了这个排序操作是串行还是并行执行：</p>
<blockquote>
<p>If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate Arrays.sort method.</p>
</blockquote>
<p>回到上面的例子，可以发现 combiner 函数只会在并行情况下执行。下面来看一下哪些线程确实执行了：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">"Max"</span>, <span class="number">18</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">"Peter"</span>, <span class="number">23</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">"Pamela"</span>, <span class="number">23</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="string">"David"</span>, <span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">persons</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"accumulator: sum=%s; person=%s [%s]\n"</span>,</span><br><span class="line">                sum, p, Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"combiner: sum1=%s; sum2=%s [%s]\n"</span>,</span><br><span class="line">                sum1, sum2, Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面例子的输出说明了 accumulator 和 combiner 在并行 Stream 中会在所有的可用线程上执行：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">accumulator: sum=<span class="number">0</span>; person=Pamela; [main]</span><br><span class="line">accumulator: sum=<span class="number">0</span>; person=Max;    [ForkJoinPool.commonPool-worker-<span class="number">3</span>]</span><br><span class="line">accumulator: sum=<span class="number">0</span>; person=David;  [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">accumulator: sum=<span class="number">0</span>; person=Peter;  [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">combiner:    sum1=<span class="number">18</span>; sum2=<span class="number">23</span>;     [ForkJoinPool.commonPool-worker-<span class="number">1</span>]</span><br><span class="line">combiner:    sum1=<span class="number">23</span>; sum2=<span class="number">12</span>;     [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br><span class="line">combiner:    sum1=<span class="number">41</span>; sum2=<span class="number">35</span>;     [ForkJoinPool.commonPool-worker-<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<p>所有在输入元素的量很大的情况下，并行 Stream 会带来很大的性能提升。但是需要注意一些操作比如 <code>reduce</code> 和 <code>collect</code> 需要额外的 combine 操作，但是在串行 Stream 中并不需要。</p>
<p>此外，所有的并行 Stream 都依赖 <code>ForkJoinPool</code> 线程池。所以应当尽量避免实现一些阻塞 Stream 的操作，因为这样会降低那些依赖并行 Stream 的程序的性能。</p>
<p>(完)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java如何处理异常</title>
    <url>/2020/05/17/Java%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>程序总会出错，出错了就需要处理。Java 中提供了很完备的异常处理机制，可以根据自己需要进行定制。</p>
<p>Java 按照问题的严重程度进行分类，分成 Error和 Exception。Exception 又可以分成 CheckedException 和 RuntimeException。</p>
<p>Error 和 Exception 都继承了 Throwable。</p>
<p><img src="exception.png" alt=""></p>
<h2>Error 和 Exception 的区别</h2>
<p>一般来说， Error 是无法恢复的错误，通常会导致程序终止， Error 通常是虚拟机层面的错误。Exception 只要妥善处理，程序就可以继续正常运行。</p>
<p>一旦出现 Error，程序也就没有恢复的必要了，比如 OutOfMemoryError，说明是机器上的内存不够用了，这个时候任何处理都来不不及，只能停止服务。</p>
<p>对于 Exception 就需要看情况。上面说到 Exception 可以分为 CheckedException 和 RuntimeException。</p>
<p>在 Java 中，抛出一个异常很简单，通过 <code>throw</code> 关键字就可以，同时也需要方法后面通过关键字 <code>throws</code> 来表明这个方法会抛出那些异常。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在调用这个方法时，就要对这个方法有可能抛出的异常进行处理，有两种处理方法，即可以将异常 通过 <code>try-catch</code> 进行处理，也可以通过 <code>throws</code> 将异常抛向更上层。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1：使用 try-catch 来处理异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        throwException();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法2：使用 throws 将异常抛向上层</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callFunction</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    throwException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面提到的异常就是<strong>CheckedException</strong>，需要通过 try-catch 或者 throws 进行处理，否则就无法通过编译。</p>
<p>下面的代码用于获取一个文件的输入流，在文件不存在的情况下，会抛出 <code>FileNotFoundException</code>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fis = <span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这也是 CheckedException 的通用处理方式。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">10</span> / i;</span><br></pre></td></tr></table></figure></p>
<p>很明显，上面的代码肯定会出现异常。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure></p>
<p>这类异常就是通常所说的　RuntimeException，这类的异常由 JVM 抛出，不需要通过 try-catch 等机制来处理。如果出现这类异常，说明程序的逻辑有问题，可以通过修改代码来防止这类异常发生。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">10</span> / i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似的 RuntimeException 还有 NullPointerException 以及 ArrayIndexOutOfBoundsException。</p>
<h2>异常处理</h2>
<p>通常，Error 和 RuntimeException 不需要进行处理。</p>
<p>需要进行处理的是 CheckedException，最常用的方式就是使用 try-catch。</p>
<p>下面的代码表示读取一个文件的内容，如果在读取的过程中发生异常，就会跳转到 catch 模块进行异常处理，而不执行 return 语句。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    fis = <span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((length = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        data.append(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data.toString(); <span class="comment">// 如果发生异常，那么这里的 return 语句不会执行</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>这是如何实现的呢？这个方法完整的字节码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">readData</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aconst_null</span><br><span class="line">       <span class="number">1</span>: astore_1</span><br><span class="line">       2: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">5</span>: dup</span><br><span class="line">       6: invokespecial #6                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">9</span>: astore_2</span><br><span class="line">      10: new           #7                  // class java/io/FileInputStream</span><br><span class="line">      <span class="number">13</span>: dup</span><br><span class="line">      14: ldc           #8                  // String data.txt</span><br><span class="line">      16: invokespecial #9                  // Method java/io/FileInputStream."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">19</span>: astore_1</span><br><span class="line">      <span class="number">20</span>: sipush        <span class="number">1024</span></span><br><span class="line">      <span class="number">23</span>: newarray       <span class="keyword">byte</span></span><br><span class="line">      <span class="number">25</span>: astore_3</span><br><span class="line">      <span class="number">26</span>: iconst_0</span><br><span class="line">      <span class="number">27</span>: istore        <span class="number">4</span></span><br><span class="line">      <span class="number">29</span>: aload_1</span><br><span class="line">      <span class="number">30</span>: aload_3</span><br><span class="line">      31: invokevirtual #10                 // Method java/io/FileInputStream.read:([B)I</span><br><span class="line">      <span class="number">34</span>: dup</span><br><span class="line">      <span class="number">35</span>: istore        <span class="number">4</span></span><br><span class="line">      <span class="number">37</span>: iconst_m1</span><br><span class="line">      <span class="number">38</span>: if_icmpeq     <span class="number">60</span></span><br><span class="line">      <span class="number">41</span>: aload_2</span><br><span class="line">      42: new           #11                 // class java/lang/String</span><br><span class="line">      <span class="number">45</span>: dup</span><br><span class="line">      <span class="number">46</span>: aload_3</span><br><span class="line">      <span class="number">47</span>: iconst_0</span><br><span class="line">      <span class="number">48</span>: iload         <span class="number">4</span></span><br><span class="line">      50: invokespecial #12                 // Method java/lang/String."&lt;init&gt;":([BII)V</span><br><span class="line">      53: invokevirtual #13                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      <span class="number">56</span>: pop</span><br><span class="line">      <span class="number">57</span>: goto          <span class="number">29</span></span><br><span class="line">      <span class="number">60</span>: aload_2</span><br><span class="line">      61: invokevirtual #14                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">64</span>: areturn</span><br><span class="line">      <span class="number">65</span>: astore_2</span><br><span class="line">      <span class="number">66</span>: aload_2</span><br><span class="line">      67: invokevirtual #16                 // Method java/io/IOException.printStackTrace:()V</span><br><span class="line">      <span class="number">70</span>: aconst_null</span><br><span class="line">      <span class="number">71</span>: areturn</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">2</span>    <span class="number">64</span>    <span class="number">65</span>   Class java/io/IOException</span><br></pre></td></tr></table></figure></p>
<p>看底部的 <code>Exception table</code>，这个也称之为异常表，其他的字节码可以先不用管。这个异常表就是 Java 处理异常的关键，其中 from 和 to 表示的 try-catch 包裹的代码范围，target 则表示异常处理的开始。</p>
<p>如果在 form 到 to 之间发生了异常，接会直接跳转到 target 的位置开始执行。</p>
<p>对于文件流，使用过后需要对其进行关闭，否则可能会出现内存泄漏等问题，所以上面的代码还不完善。try-catch-finally 则可以解决这个问题，finallly 中的代码无论是否出现异常都会执行，确保文件流会关闭。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    fis = <span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((length = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        data.append(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data.toString();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如何确保 finally 中的代码一定会执行呢？为了看的更清楚，我将 finally 中的异常改成了 Exception，并且删除了一些无关的字节码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">readData</span><span class="params">()</span></span>;</span><br><span class="line">Code:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    71: invokevirtual #15                 // Method java/io/FileInputStream.close:()V</span><br><span class="line">    <span class="number">74</span>: goto          <span class="number">84</span></span><br><span class="line">    <span class="number">77</span>: astore        <span class="number">6</span></span><br><span class="line">    <span class="number">79</span>: aload         <span class="number">6</span></span><br><span class="line">    81: invokevirtual #17                 // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    97: invokevirtual #15                 // Method java/io/FileInputStream.close:()V</span><br><span class="line">    <span class="number">100</span>: goto          <span class="number">134</span></span><br><span class="line">    <span class="number">103</span>: astore_2</span><br><span class="line">    <span class="number">104</span>: aload_2</span><br><span class="line">    105: invokevirtual #17                 // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    118: invokevirtual #15                 // Method java/io/FileInputStream.close:()V</span><br><span class="line">    <span class="number">121</span>: goto          <span class="number">131</span></span><br><span class="line">    <span class="number">124</span>: astore        <span class="number">8</span></span><br><span class="line">    <span class="number">126</span>: aload         <span class="number">8</span></span><br><span class="line">    128: invokevirtual #17                 // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">    <span class="number">131</span>: aload         <span class="number">7</span></span><br><span class="line">    <span class="number">133</span>: athrow</span><br><span class="line">    <span class="number">134</span>: aconst_null</span><br><span class="line">    <span class="number">135</span>: areturn</span><br><span class="line">Exception table:</span><br><span class="line">    from    to  target type</span><br><span class="line">        <span class="number">66</span>    <span class="number">74</span>    <span class="number">77</span>   Class java/lang/Exception</span><br><span class="line">        <span class="number">2</span>    <span class="number">66</span>    <span class="number">87</span>   Class java/io/IOException</span><br><span class="line">        <span class="number">92</span>   <span class="number">100</span>   <span class="number">103</span>   Class java/lang/Exception</span><br><span class="line">        <span class="number">2</span>    <span class="number">66</span>   <span class="number">111</span>   any</span><br><span class="line">        <span class="number">87</span>    <span class="number">92</span>   <span class="number">111</span>   any</span><br><span class="line">        <span class="number">113</span>   <span class="number">121</span>   <span class="number">124</span>   Class java/lang/Exception</span><br><span class="line">        <span class="number">111</span>   <span class="number">113</span>   <span class="number">111</span>   any</span><br></pre></td></tr></table></figure></p>
<p>加了 finally 之后，发现异常表中增加了很多内容（any 先忽略），在 finally 中抛出的 Exception 出现了 3 次，再看上面的字节码，发现调用文件流的 close 方法也出现 3 次。</p>
<p>所以 finally的实现就不难理解，编译器会将 finally 中的代码拷贝到所有可能的路径上，包括正常执行的流程以及 catch 中的流程。</p>
<p>finally 中也有可能会抛出异常，如果 finally 中抛出异常会怎么样呢？</p>
<p>在 Java7 以前，finally 中的异常会覆盖前面所抛出的异常，这种情况当然不是我们所想看到的。在 Java7 以后，引入了 Suppressed 异常来解决这个问题，这个特性允许将一个异常附在另一个异常上面，因此抛出的异常中可以附带多个异常信息。</p>
<p>try-catch 除了可以用来处理异常之外，也可以专门用来处理资源关闭之类的问题。在一些情况下，catch 块也可以省略，直接使用 try-finally:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    fis = <span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码上面的每次都需要手动的去写 finally 中的代码，这样的样本代码其实毫无意义，无端增加了代码的复杂度。在 Java 7 以后，增加了 try-with-resources 语法糖，上面的代码可以这么写：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>);) &#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((length = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        data.append(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以少写很多的样本代码，需要注意的是，使用 try-with-resource 必须确保这个类实现了 AutoCloseable 接口。</p>
<p>Java 7 中还提供了一些其他的语法糖，比如使用 catch 来处理多种异常：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception1 | Exception2 e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>断言</h2>
<p>Java 中还有一个特性叫<strong>断言</strong>，也可以用来进项异常情况的处理，使用很简单，如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">assert</span> i &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>Java 默认是不打开断言的，也就是说即使你在代码中写上断言代码也是不起作用的，
如果要启用断言，要加上虚拟机参数 <code>-ea</code> 来启用断言。</p>
<p>使用断言有一个问题，如果断言的结果与预期不符合，那么整个程序就会终止运行。</p>
<p>断言适合在开发和测试阶段使用，用于快速发现以及定位问题，上线之后，可以将断言
禁用，这样就不用反复修改代码了。</p>
<h2>日志</h2>
<p>日志是 Java 中不可缺少的部分。在大型系统中，日志是最重要的排查工具。JDK 中自带了 <code>java.util.logging.Logger</code>，使用起来很方便：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(String.valueOf(LoggerTest.class));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Logger"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这个框架在扩展性和性能上都不是很理想，所以出现了很多第三方的日志框架，比如 Log4j，Logback 等。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器系列-CopyOnWriteArrayList源码解析</title>
    <url>/2020/01/04/Java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%97-CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>CopyOnWriteArrayList 是 ArrayList 的线程安全版本。用一句话概括它的特点就是：所有的修改操作都是基于副本来进行的。</p>
<p><img src="CopyOnWriteArrayList-class.png" alt=""></p>
<h2>设计思想</h2>
<p>在 <code>java.util.concurrent</code> 下，有很多线程安全的容器，大致可以分成三类 <code>Concurrent*</code>、<code>CopyOnWrite*</code>、<code>Blocking*</code>这三类的容器都可以在并发环境下使用，但是实现的方式却不一样。</p>
<p>Concurrent* 容器是基于无锁技术实现，性能很好，ConcurrentHashMap 就是典型代表；CopyOnWrie* 容器则是基于拷贝来实现的，所以对于内存有很大的开销，CopyOnWriteArrayList 就属于这一类；Blocking* 容器则使用 锁技术实现了阻塞技术，在某些场景下非常有用。</p>
<p>CopyOnWriteArrayList 的核心操作如下，就是通过不断的拷贝数组来更新容器：</p>
<p><img src="copyOnWriteArrayList-con.png" alt=""></p>
<h2>具体实现</h2>
<p>CopyOnWriteArrayList 的成员变量如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>
变量的数量很少，仅仅包含一个锁对象和一个用来放元素数组。因为
CopyOnWriteArrayList 保证线程安全的方式很简单，不断的通过备份元素来保证数据不会被修改。</p>
<h3>如何实现线程安全</h3>
<p>和其他线程安全的容器思路不一样，这个容器从空间的角度来解决线程安全的问题。所有对容器的修改是基于副本进行的，修改的过程中也通过锁对象锁来保证并发安全，从这个角度来说，CopyOnWriteArrayList 的并发度也不会太高。所以一句话概括就是使用 synchronized + Array.copyOf 来实现线程安全。</p>
<p>迭代器是基于副本进行的，即使原数组被改变，副本也不会被影响。也就不会抛出 ConcurrentModificationException 异常。但是这样也会让最新的修改无法及时体现出来。</p>
<h3>核心方法的实现</h3>
<p>get 方法直接读取数组就行，不需要上锁，多个线程同时读也就不会有并发的问题产生。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementAt(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">elementAt</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下来来看一下 add 方法，代码很短：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CopyOnWriteArrayList.add()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = es.length;</span><br><span class="line">        <span class="comment">// 复制原数组，并且长度加一</span></span><br><span class="line">        es = Arrays.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">        es[len] = e;</span><br><span class="line">        <span class="comment">// 指向新的数组</span></span><br><span class="line">        setArray(es);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
也就是是说，每次添加元素的时候，都会把原数组复制一次，并把复制后的数组长度加 1，然后把元素添加进数组，最后用新数组去替代旧数组，完成添加。这样 CopyOnWriteArrayList 根本就不需要扩容，因为每次添加元素都是一个扩容的过程。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CopyOnWriteArrayList.remove()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = es.length;</span><br><span class="line">        E oldValue = elementAt(es, index);</span><br><span class="line">        <span class="comment">// 计算需要移动的元素</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="comment">// 如果删除的是最后一个元素，则不需要移动</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            newElements = Arrays.copyOf(es, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 删除的是中间元素，则需要分两次复制</span></span><br><span class="line">            System.arraycopy(es, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(es, index + <span class="number">1</span>, newElements, index, numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指向新的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除元素的情况就要复杂一些。删除的时候如果是删除中间的元素，需要后面元素进行移动。然后新数组的长度也会减 1，这就相当于缩容过程。</p>
<p>CopyOnWriteArrayList 的迭代器的实现也很不复杂:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># COWIterator 构造函数</span><br><span class="line">COWIterator(Object[] es, <span class="keyword">int</span> initialCursor) &#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    <span class="comment">// 容器元素的副本</span></span><br><span class="line">    snapshot = es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，构造迭代器的时候，直接把整个元素的副本都传进来了，后续的操作都会在这个副本上进行，甚至都需要上锁。所以是 fail-safe 的。</p>
<p>在 CopyOnWriteArrayList 中，有两种数组拷贝方式 <code>Arrays.copyOf</code> 和 <code>System.arraycopy</code>。这两种方式有什么区别吗？实际上是没有的，来看一下 Arrays.copyOf 的源码:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                        Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没错，Arrays.copyOf 调用了 System.arraycopy 来实现数组拷贝。</p>
<p>通过上面的分析可知，CopyOnWriteArrayList 的读效率很高，但是写的效率很低，所以比较适合读多写少的场景。</p>
<p>另外需要说一句，CopyOnWriteArraySet 使用 CopyOnWriteArrayList 实现。Set 一如继往喜欢使用现成的类来实现。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase 常用 shell 命令手册</title>
    <url>/2020/06/07/HBase-%E5%B8%B8%E7%94%A8-shell-%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>HBase 是一个开源的分布式非关系型数据库，在大数据行业中应用很广泛。Google 的三篇论文奠定了大数据的理论基础，其中 HBase 就可以看做是 BigTable 的实现，用来存储大规模的数据。</p>
<p>HBase 的命令很多，这篇文章总结了 HBase 最常用的 shell 命令，作为日常开发的手册。</p>
<blockquote>
<p>本文基于 JDK1.8 HBase2.2.5
本文假设你已经了解 HBase 的基本概念</p>
</blockquote>
<h2>HBase 单机版安装</h2>
<p>本文基于单机版的 HBase 进行操作，单机版的 HBase 使用起来非常方便，不要配置 HDFS，直接就可以使用，在这里下载 <a href="https://hbase.apache.org/downloads.html" target="_blank" rel="noopener">HBase</a>。</p>
<p>下载完成之后，直接解压：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar xzvf hbase-2.2.5-bin.tar.gz</span><br><span class="line">cd hbase-2.2.5</span><br></pre></td></tr></table></figure></p>
<p>然后进入 conf 目录，编辑 hbase-env.sh，找到下面这行，配置上 JDK 的目录（HBase 2.2.5 需要 JDK1.8 以上）：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改成你的 jdk 目录</span></span><br><span class="line">export JAVA_HOME=your jdk dir</span><br></pre></td></tr></table></figure></p>
<p>然后启动 HBase：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/start-habse.sh</span><br></pre></td></tr></table></figure></p>
<p>然后通过命令行连接 HBase：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/hbase shell</span><br></pre></td></tr></table></figure></p>
<p>到这里，就完成了单机版 HBase 的安装和启动。</p>
<blockquote>
<p>HBase 虽然经常和 HDFS 一起出现，但并不是非得使用 HDFS 作为底层文件系统，也可以选择其他的文件系统，比如电脑的本地文件系统。</p>
</blockquote>
<h2>基本操作</h2>
<p>连上 HBase 之后，就可以对 HBase 进行操作了，HBase 有一些基本的命令来查看 HBase 当前的状态和属性。</p>
<p>连接上 HBase 之后，查看当前连接的用户是谁：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure></p>
<p>查看有哪些表：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">list</span><br></pre></td></tr></table></figure></p>
<p>查看 HBase 服务器状态：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">status</span><br></pre></td></tr></table></figure></p>
<p>查看 HBase 版本：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version</span><br></pre></td></tr></table></figure></p>
<p>查看其他命令使用，比如查看 list 命令的详细信息（注意要加引号）：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">help 'list'</span><br></pre></td></tr></table></figure></p>
<h2>表操作</h2>
<p>HBase 的建表和 MySQL 等关系型数据库不一样，需要提前创建表结构，对于 HBase 来说，建表很简单，下面全程使用 students 表为例，students 表有两个列族 <code>NO</code> 和 <code>Info</code>，分别表示学生的学号和详细信息。</p>
<p>创建 namespace：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create_namespace 's_school'</span><br></pre></td></tr></table></figure></p>
<p>修改 namespace：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alter_namespace 's_school', &#123;METHOD=&gt;'set', NAME =&gt; 'school'&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除 namespace，只有在 namespce 为空时才能删除：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drop_namespace 's_school'</span><br></pre></td></tr></table></figure></p>
<p>创建 students 表，如果创建表的时候不指定 namespace，name表都会放到默认的 default namespace：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cereate 's_school:students', 'No', 'Info'</span><br></pre></td></tr></table></figure></p>
<p>下面的演示都没有使用 namespace。</p>
<p>查看表的详细信息：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">describe 'students'</span><br></pre></td></tr></table></figure></p>
<p>查看表是否存在：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exists 'students'</span><br></pre></td></tr></table></figure></p>
<p>禁用表：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">disable 'students'</span><br></pre></td></tr></table></figure></p>
<p>启用表：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">enable 'students'</span><br></pre></td></tr></table></figure></p>
<p>查看表是否被禁用/启用：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">is_enabled 'students' # 表是否启用</span><br><span class="line">is_disabled 'students' # 表是否禁用</span><br></pre></td></tr></table></figure></p>
<p>为表增加列族：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alter 'students', 'Extra'</span><br></pre></td></tr></table></figure></p>
<p>删除一个列族：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alter 'students', &#123;NAME=&gt;'Extra', METHOD=&gt;'delete'&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除表，需要注意，删除表之前要先禁用表:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">disable 'students'</span><br><span class="line">drop 'students'</span><br></pre></td></tr></table></figure></p>
<h2>增</h2>
<p>表创建好了就可以往表里面写数据了，添加数据使用 put 命令。</p>
<p>插入学生 ID：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">put 'students', '100001', 'No', '100001'</span><br></pre></td></tr></table></figure>
在上面的语句中，直接向 No 这个列族中插入了一条数据。</p>
<p>插入学生姓名，在 Info 列族下，多加了一个 name 列：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">put 'students', '100001', 'Info:name', 'Tom'</span><br></pre></td></tr></table></figure></p>
<p>还可以插入年龄:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">put 'students', '100001', 'Info:age', '18'</span><br></pre></td></tr></table></figure></p>
<p>只要你愿意，可以增加任意多的列（qualifier）。</p>
<p>HBase 中更新数据使用的也是 put 命令：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">put 'students', '100001', 'Info:age', '24'</span><br></pre></td></tr></table></figure></p>
<h2>查</h2>
<p>HBase 中查询数据有两种方式 get 和 scan，get 直接通过 rowkey 获取数据，因为有索引的加持，速度非常快，而 scan 则需要通过扫描区间来获取数据，性能会低很多。</p>
<p>通过 get 获取数据:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get 'students', '100001'</span><br></pre></td></tr></table></figure></p>
<p>结果如下：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">COLUMN                                        CELL</span><br><span class="line"> Info:age                                     timestamp=1591224539219, value=24</span><br><span class="line"> Info:name                                    timestamp=1591224215833, value=Tom</span><br><span class="line"> No:                                          timestamp=1591224003381, value=100001</span><br><span class="line">1 row(s)</span><br></pre></td></tr></table></figure></p>
<p>使用 scan 方式如下:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan 'students'</span><br></pre></td></tr></table></figure></p>
<p>也可以指定返回结果的行数：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan 'students', &#123;LIMIT=&gt;10&#125;</span><br></pre></td></tr></table></figure></p>
<p>还可以获得指定列族或者列的数据:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan 'students', &#123;COLUMNS=&gt;'Info:age'&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果获取多个列族，或者多个列：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan 'students', &#123;COLUMNS=&gt;['Info:age', 'No']&#125;</span><br></pre></td></tr></table></figure></p>
<p>还可以通过制定 rowkey 的前缀查询，这个功能很常用，这样查询的速度会快很多：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan 'students', &#123;STARTROW =&gt; '100'&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要统计整个表中数据的行数:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">count 'students'</span><br></pre></td></tr></table></figure></p>
<h2>删</h2>
<p>删除数据也很简单，可以删除一个列或者一个列族或者一行：</p>
<p>删除一个列族的最新数据：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">delete 'students', '100001', 'No'</span><br></pre></td></tr></table></figure></p>
<p>删除一个列的最新数据:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">delete 'students', '100001', 'Info:age'</span><br></pre></td></tr></table></figure></p>
<p>delete 只能删除一个版本的数据，如果要删除所有版本的数据，需要使用 deleteall:</p>
<p>删除一个列的所有:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deleteall 'students', '100001', 'Info:age'</span><br></pre></td></tr></table></figure></p>
<p>删除一行数据：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deleteall 'students', '100001'</span><br></pre></td></tr></table></figure></p>
<p>文 / 王二不二</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器系列-ConcurrentHashMap源码分析</title>
    <url>/2019/12/28/Java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%97-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>ConcurrentHashMap 用法上与 HashMap 差别不大，但 ConcurrentHashMap 是线程安全的，可以在多线程环境中使用。这篇文章主要会说明 ConcurrentHashMap 专有的一些特点，与 HashMap 类似部分将不再赘述。</p>
<p><img src="concurrenthashmap-class.png" alt=""></p>
<blockquote>
<p>本文基于 JDK1.8</p>
</blockquote>
<h2>成员变量及常量</h2>
<p>ConcurrentHashMap 的代码复杂度高了不少，用到了很多的成员变量和常量，先认识一下（HashMap 已经存在的变量或常量就不再赘述）。</p>
<h3>常量</h3>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认并发度，同时允许多少个线程访问</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 扩容时每个线程扩容时至少要迁移的桶的数量，最低不能少于 16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 辅助变量，没啥用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 可用于扩容的最大线程数，但一般肯定到不了这个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 会用来计算一个标志位，实际上也没什么用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">// 下面三个常量是几个特殊的哈希值</span></span><br><span class="line"><span class="comment">// MOVED：表示桶正在经被迁移</span></span><br><span class="line"><span class="comment">// TREEBIN：表示桶正在进行树化</span></span><br><span class="line"><span class="comment">// RESERVED：表示节点运行 computeIfAbsent 等方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>;</span><br><span class="line"><span class="comment">// 用于计算 key 的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; </span><br><span class="line"><span class="comment">// CPU 的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure></p>
<h3>变量</h3>
<p>这些变量基本都使用了 volatile 关键字，那是因为这些变量的再并发环境中必须都保持可见性。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 桶数组，与 HashMap 基本一致，也是延迟加载，不过这里使用了 volatile 关键字</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 桶数组，用于扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// 记录所有的元素的个数，类似于 HashMap 的 size</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"><span class="comment">// 初始化和扩容的标志位</span></span><br><span class="line"><span class="comment">// 默认值：0</span></span><br><span class="line"><span class="comment">// 初始化前：初始化容量大小</span></span><br><span class="line"><span class="comment">// 正在初始化：-1</span></span><br><span class="line"><span class="comment">// 扩容前：触发扩容操作的元素个数,相当于 HashMap 的 threshold</span></span><br><span class="line"><span class="comment">// 正在扩容：-(1 + 参与扩容的线程数量)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"><span class="comment">// 扩容的时候需要对桶内的元素进行迁移，这个变量用来记录桶的下标，表示迁移的进度，下面会详细介绍这个变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"><span class="comment">// 更新 counterCells 时使用的自旋锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"><span class="comment">// 计数用，用于计算还没来的及更新到 baseCount 中的变化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure></p>
<h2>具体实现</h2>
<p>与 HashMap 相比，ConcurrentHashMap 是线程安全的。允许多个线程并发的访问容器的不同部分来减少线程间的竞争。这个容器设计出来不是为了替代 HashMap，而是为了在满足多线程环境下的需求，它有两个设计目标：</p>
<ul>
<li>使容器可以支持并发读（比如 get(), 迭代器等）同时让多线程更新竞争的代价最小化。</li>
<li>对空间的消耗与 HashMap 持平甚至更好</li>
</ul>
<p>总的来说就是 ConcurrentHashMap 既要能支持高并发，也要有高性能。具体实现也经过了多次变化，特别是在 JDK1.8，几乎进行了重写，底层的存储机制也完全不一致。JDK 1.7 和 JDK1.8 底层存储的差异：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK1.7</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table; <span class="comment">// 每一个分段锁都会有一个 table</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK1.8</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
在 JDK1.8 中，并发的粒度更细一些，可以认为 table 的长度就是并发数，而之前的版本中，Segment 的数量是并发度。</p>
<p>因为使用了 CAS，所以在 ConcurrentHashMap 中存在大量的自旋操作，自旋操作其实就是一个死循环，等到完成操作时就会通过 break 跳出循环。</p>
<p>ConcurrentHashMap 的 hash 函数与 HashMap 的相差不大，不过除了与自身进行 XOR(异或) 操作，还会与 <code>HASH_BITES</code> 进行与运算：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap.spread()</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>HASH_BITS</code> 的二进制表示是：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">01111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span></span><br></pre></td></tr></table></figure></p>
<h3>CAS</h3>
<p>在 JDK1.8 以前，ConcurrentHashMap 主要使用分段锁的机制来实现，在 JDK 1.8 及以后，主要使用了 CAS(sun.misc.Unsafe) + synchronized 来实现。CAS 是一种无锁的并发技术，以高效率著称，CAS 需要硬件的支持，如今的 CPU 都支持这一特性。</p>
<p>但 ConcurrentHashMap 并没有实现自己的 CAS，而是直接使用了 <code>sun.misc.Unsafe</code>（最新的 JDK 中已经换成  jdk.internal.misc.Unsafe）。</p>
<p>ConcurrentHashMap 利用 CAS 实现了了以下三个原子方法来访问桶的<strong>第一个元素</strong>：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取桶的某个位置，任何情况下可以使用</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectAcquire(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入桶的第一个键值对，可以在并发环境下，任何情况下可以使用</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSetObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把键值对插入到桶中，只在有锁的的区域使用</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectRelease(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>桶的第一个元素有特殊的意义，在 ConcurrentHashMap 中通常被用作桶的锁</p>
</blockquote>
<p>CAS 除了用来访问桶之外，在用在其他需要并发更新变量的地方。比如更新 sizeCtl 变量：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap.initTable()</span></span><br><span class="line"><span class="comment">// 将容器的状态设置为正在扩容</span></span><br><span class="line">U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
synchronized 给人的印象是很慢，很臃肿，其实这是一个误解，synchronized 底层经过不断的优化，目前性能已经与可重入锁相当。而且 synchronized 使用简单，也不会造成是死锁的情况，所以一般情况下能用 synchronized 就别用锁了，除非满足不了需求再考虑用锁。</p>
<p>在 ConcurrentHashMap 中 synchronized 使用时粒度都比较小，被 synchronized 包裹的代码不是很多，所以还是可以保持高性能。这也是 ConcurrentHashMap 与 Hashtable 的最大区别。Hashtable 也是使用 synchronized 来保证线程安全，但是 synchronized 都是在方法级别使用，这样就会让整个容器的并发级别很低。</p>
<h3>扩容机制</h3>
<p>扩容是一个很慢的操作，可以事先预估好大小，可以减少扩容的次数。扩容机制与 HashMap 有些不同，因为 ConcurrentHashMap 可以并发访问，所以在扩容时<strong>写操作</strong>的线程都不能继续，但是这些线程也可以被利用起来，参与到扩容操作中。</p>
<p>对容器的扩容分为两种情况：</p>
<ul>
<li>**初始化：**首次插入元素时初始化，也称之为延时加载</li>
<li>**扩容：**存储的元素达到临界值开始扩容</li>
</ul>
<p>初始化和扩容这两个过程不是独立存在的，通过下面这个图来看清整体流程时如何进行的：</p>
<p><img src="concurrenthashmap-resize.png" alt=""></p>
<p>实例化时会确定table大小，但是不初始化table，以及确定下一次扩容的临界点，如果构造函数传入的是另一个 Map，调用 tryPresize 来扩容。</p>
<p>在首次插入元素时，会初始化 table（延迟加载），调用 initTable() 进行初始化。</p>
<p>如果不是首次插入元素，判断是否正在扩容，如果是，则停止操作(除了 get() 操作)，参与扩容流程。扩容完成后，通过自旋再次进行操作（插入或者更新），插入元素时需要检查是否达到树化的条件，如果满足，将链表转成树。插入完成后调用 addCount() 检查容器状态，如果元素大于等于扩容临界点的值，则开始扩容</p>
<p>初始化通过 <code>initTable()</code> 方法来完成。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap.initTable()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 检查当前桶是否为空，为空则开始初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 发现正在初始化或者在扩容，则什么也不做，进入自旋状态等待表被初始化（或扩容）完成</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// 放弃 CPU 资源</span></span><br><span class="line">        <span class="comment">// 线程开始扩容时会把 sizeCtl 的值置为 -1，让其他线程发现正在进行初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 确定初始化桶的数量，如果 sizeCtl 大于 0 则使用 sizeCtl 的值，否则使用默认容量</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 设置扩容阀值，ConcurrentHashMap 中的装载因子仅仅在构造函数中使用</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 相当于 n * 0.75</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>扩容操作通过下面两个方法来发起:</p>
<ul>
<li>addcount</li>
<li>tryPresize</li>
</ul>
<p>addcount() 在改变容器元素的方法中被调用，主要就是检查容器当前的状态，判断是否需要扩容，如果需要，就会进行扩容。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap.addcount()</span></span><br><span class="line"><span class="comment">// 这个方法主要用来给当前容器的数量进行计数顺便检查一下是否需要扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] cs; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">// 给容器中的元素进行增或者减</span></span><br><span class="line">    <span class="comment">// 如果 cs 不为 null（说明有并发情况）或者 baseCount 增减运算失败，</span></span><br><span class="line">    <span class="keyword">if</span> ((cs = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSetLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell c; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 那么就会通过 cs 来进行计数，</span></span><br><span class="line">        <span class="comment">// 如果 cs 是空（还不是并发）或者 (cs 中随机取余一个数组位置为空 或者 cs 这个位置的变量失败）</span></span><br><span class="line">        <span class="comment">// 说明通过 cs 来计数也失败了，最后才会调用 fullAddCount 来进行计数</span></span><br><span class="line">        <span class="keyword">if</span> (cs == <span class="keyword">null</span> || (m = cs.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (c = cs[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">                U.compareAndSetLong(c, CELLVALUE, v = c.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">// 与 LongAdder 实现一致，可以理解为并发情况下的一个计数器</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 统计当前节点的数量</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在增加元素的操作中 check 都会满足这个条件</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 检查扩容条件：</span></span><br><span class="line">        <span class="comment">// 1. 是否达到阀值: s &gt;= sizeCtl （上文已经解释了 sizeCtl，sizeCtl 大于 0 时表示下次扩容的临界点）</span></span><br><span class="line">        <span class="comment">// 2. 是否可以扩容: tab != null &amp;&amp; tab 当前的长度小于 1 &lt;&lt; 30</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 根据当前桶的数量生成一个标志位</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 如果正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查当前扩容的进展:</span></span><br><span class="line">                <span class="comment">// 1. 如果 sc 的低 16 位不等于标识位（ sizeCtl 变化了，说明容器状态已经变化），退出</span></span><br><span class="line">                <span class="comment">// 2. 如果 sc == 标识位 + 1 （通过下面代码可知，刚开始扩容时， sc = rs + 2，如果 sc = rs + 1，说明已经没有线程在扩容），退出</span></span><br><span class="line">                <span class="comment">// 3. 如果 sc == 标识符 + 65535，参与扩容的线程已经达到最大数量，当前线程不再参与，退出</span></span><br><span class="line">                <span class="comment">// 4. 如果 nextTable == null 说明扩容结束（nextTable 在扩容中起中转作用，所有的元素会被限移到 nextTable 中，最后让 tab = nextTable，nextTable == null 来完成扩容），退出</span></span><br><span class="line">                <span class="comment">// 5. transferIndex &lt;= 0 说明没有桶还需要迁移了（transferIndex 用于标识当前迁移到哪个桶了，小于等于 0 说明已经迁移到最后一个桶或者已经迁移完成，迁移的顺序是从最后一个桶开始），退出。</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果迁移还是进行，当前线程尝试参与扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前不在扩容中，则发起一个新的扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 统计当前节点的数量</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>tryPresize 相比于 addcount 方法相对简单，就是尝试进行扩容：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap.tryPresize()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据 size 计算扩容的容量</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 判断是否可以进行扩容，如果 sizeCtl &lt;= 0，说明已经在扩容中，那么久不会再进行扩容</span></span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 如果当前容器还没有初始化，则进行初始化，与 initTable 相同</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前的扩容阀值与传入的值之间选大的作为这次初始化的大小</span></span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="comment">// 进入初始化状态</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 相当于 n * 0.75</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果还每达到扩容的阀值或者超过了最大容量，则停止扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// 开始进行扩容</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                    (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>扩容的具体操作是通过 <code>transfer()</code> 方法来完成。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap.transfer() 该方法用于将元素都迁移到 nextTable 中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// 在迁移元素时，会将桶分段，stride 表示每段的长度，最小值为 16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; </span><br><span class="line">    <span class="comment">// 初始化 nextTable</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// 这个变量用于记录当前迁移的进度，需要注意的是迁移元素从最后一个桶开始</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// fwd 是一个特殊的 Node，没有 key，也没有 val，hash 值为 MOVED，用来标识一个桶已经迁移完毕</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 用来控制迁移的进展，如果为 true 说明当前这次循环要干的事情已经完成，可以开始下一个循环</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 标示当前线程所有桶的迁移是否完成</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 当前线程需要处理的桶的范围 [nextBound, nextindex)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// transferIndex &lt;= 0 表示已经迁移完成</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// 为当前线程分配桶的区间，当前线程需要将负责这个区间内的桶元素迁移到 nextTable 中</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前线程是否完成所有桶的迁移</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">// 如果为 true，说明所有的迁移任务已经完成</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">// 相当于 n * 0.75</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将参与扩容的线程数量减 1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果不相等说明还有其他的线程在参与扩容，当前线程直接退出就行，这行代码与 tryPresize() 中传入的参数有关，第一个进行扩容的线程传入的 sc = (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2，所以如果这是最后一个线程，那么 sc - 2 == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 最后退出的线程需要再检查一遍容器的状态</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果桶中的元素都迁移完成了，则在桶的节点置为 MOVED，表示桶中的元素都迁移完成了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd)；</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// 当前桶已经被处理</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果上面条件都不满足说明要开始迁移桶中的元素</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">             <span class="comment">// 省略搬运元素的代码...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3>树化操作</h3>
<p>树化的方式与时机和 HashMap 基本一致。在单个桶的链表元素个数大于 8 时尝试进行树化操作，但是如果此时整个容器的容量少于 64 时，会进行扩容操作，而不是进行树化操作，树化后同样也维护元素的 next 指针来保持连接关系。</p>
<p>树化操作只需要对当前线程所访问的桶进行操作，所以整个过程比扩容要简单很多，是通过 CAS + synchronized 来完成。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap.treeifyBin()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果容器的容量小于 64，则会进行扩容操作，而不是进行树化操作</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 利用 CAS + synchronized 来把链表转成红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 把转换好的树放到桶上</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3>增删改查操作</h3>
<p>在每个桶上插入第一个元素的时候使用 CAS 就够了。如果插入的不是桶上的第一个元素，或者是删除或者更新操作，就还是要用到 synchronized。但不会为每一个元素都创建一个锁对象，而是使用桶上的第一个元素作为锁对象。但是仅仅将第一个元素上锁还不够，在更新之前，还需要验证它依然是这个桶的第一个节点，如果不是，就要进行重试。</p>
<p>除了 get() 操作之外，其他的 put()、clear() 等操作，都需要使用 CAS + synchronized 来进行并发访问。get 操作相对简单，直接通过 <code>tabAt</code> 方法获取就行。其他的操作逻辑整体就是一样的。这里主要介绍 <code>putVal()</code> 方法，put()、add()等向容器中增加或者更新元素的方法都是通过 putVal() 方法来完成的。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap.putVal()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key 和 value 都不允许为 null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 做 hash 运算</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 进入自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">        <span class="comment">// 如果桶还没有被初始化，则进入初始化（延迟加载）</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 如果这个桶为空，直接使用 CAS 方式来插入元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                <span class="keyword">break</span>;                  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果发现正在扩容，则参与进扩容，扩容完成之后，通过自旋的方式再次执行插入操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 执行 computeOnlyAbsent 之类的方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent</span><br><span class="line">                    &amp;&amp; fh == hash</span><br><span class="line">                    &amp;&amp; ((fk = f.key) == key || (fk != <span class="keyword">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                    &amp;&amp; (fv = f.val) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> fv;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 使用 CAS + synchronized 机制插入元素</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 对现有的键值对进行更新</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 使用尾插法插入新的元素</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果桶上挂的是树，那就按照树的方法来插入节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                        value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果发现这个节点正在进行 computeIfAbsent 之类的操作，则抛出异常</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive update"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查桶上节点的数量，如果超过 8 了，则尝试进行树化操作</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">// 如果是更新节点操作，那么节点数量就没有增加，直接返回即可</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用这个方法来检查是否满足扩容的条件，与上面的 helpTransfer 方法不同，addCount 是在键值对插入之后再去检查是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其他操作如 clear、comput、remove 等会改变容器元素的方法原理都类似，都是通过 CAS + synchronized 来更新元素，最后调用 addcount 方法来更新计数以及判断是否需要扩容。</p>
<h3>其他功能</h3>
<p>因为是支持并发的，所以 size 方法的实现也会有点不一样，size 实际调用的是 sumCount 方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap.sumCount()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 统计 cs 和 baseCount 的和</span></span><br><span class="line">    CounterCell[] cs = counterCells;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (cs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (CounterCell c : cs)</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>)</span><br><span class="line">                sum += c.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在扩容代码中我们看到了 cs 和 baseCount 其实都是用来的统计容器个数，在并发情况下，会先记录到 cs 最后但是需要注意的是，因为 sumCount 没有加锁，所以最后返回的值也不是完全准确的。</p>
<p>另外 ConcurrentHashMap 使用的是 fail-safe 的机制，也就是说在迭代的过程中如果容器中的元素变化，也不会抛出 ConcurrentModificationException 异常。</p>
<p>最后说一下迭代器的问题，KeySetView，ValuesView，EntrySetView 这三个类分别可以迭代键、值、和键值对。具体的实现相对比较简单，而且对于迭代的过程也没有加上并发的控制，所以最后遍历的结果也不一定是准确的。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器系列-HashMap源码分析</title>
    <url>/2019/12/21/Java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%97-HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>HashMap 实现了 Map 接口。HashMap 使用的很广泛，但不是线程安全的，如果在多线程中使用，必须需要额外提供同步机制（多线程情况下推荐使用 ConCurrentHashMap）。</p>
<p><img src="hashmap-class.png" alt=""></p>
<p>HashMap 的类图相对简单，主要就是继承了 AbstractMap，有一点需要注意，虽然没有实现 <code>Iterable</code> 接口，但 HashMap 本身还是实现了迭代器的功能。</p>
<blockquote>
<p>本文基于 JDK1.8</p>
</blockquote>
<h2>成员变量及常量</h2>
<p>HashMap 是一个 <code>Node[]</code> 数组，每一个下标称之为一个<strong>桶</strong>。</p>
<p>每一个键值对都是使用 <code>Node</code> 来存储，这是一个单链表的数据结构。每个桶上可以通过链表来存储多个键值对。</p>
<h3>常量</h3>
<p>HashMap 中用到的常量及其意义如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始容量（桶的个数） 2^4 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; </span><br><span class="line"><span class="comment">// 最大容量（桶的个数） 2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认的装载因子(load factor)，除非特殊原因，否则不建议修改</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 单个桶上的元素个数大于这个值从链表转成树（树化操作）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 单个桶上元素少于这个值从树转成链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 只有桶的个数大于这个值时，树化操作才会真正执行</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure></p>
<h3>成员变量</h3>
<p>HashMap 中用到的成员变量如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap 中的 table，也就是桶</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 缓存所有的键值对 </span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">// 键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// HashMap 被修改的次数，用于 fail-fast 检查</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 进行 resize 操作的临界值，threshold = capacity * loadFactor</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 装载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
table 是一个 Node 数组，<code>length</code> 通常是 $2^n$，但也可以为 0。</p>
<h2>初始化</h2>
<p>HashMap 的初始化其实就只干了两件事：</p>
<ul>
<li>确定 threadhold 的值</li>
<li>确定 loadFactor 的值</li>
</ul>
<p>用户可以通过传入初始的容量和装载因子。HashMap 的容量总是 $2^n$，如果传入的参数不是 $2^n$，也会被转化成 $2^n$：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap.tableSizeFor()</span></span><br><span class="line"><span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<code>Integer.numberOfLeadingZeros()</code> 返回一个 int 类型（32位）在二进制表达下最后一个非零数字前面零的个数。比如 2：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">010</span></span><br></pre></td></tr></table></figure>
所以 Integer.numberOfLeadingZeros(3) 返回 30。</p>
<p>-1 在用二进制表示为：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span></span><br></pre></td></tr></table></figure>
<code>&gt;&gt;&gt;</code> 表示无符号右移，-1 右移 30 位则得到:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">011</span></span><br></pre></td></tr></table></figure>
得到 3。</p>
<p>所以经过了 <code>-1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1)</code> 返回的值一定是 $2^n-1$，所以最后返回的值一定是 $2^n$，感兴趣的可以去验证一下。</p>
<p>HashMap 在初始化的时候也可以接受一个 Map 对象，然后把传入的 Map 对象中的元素放入当前的容器中。</p>
<p>除了传入 Map 对象的实例化方式，都不会实际去创建桶数组，这是一种延迟初始化的方式，在插入第一个键值对的时候，会调用 <code>resize()</code> 方法去初始化桶。</p>
<p>下面来详细看看 <code>resize()</code> 操作。</p>
<h2>扩容机制</h2>
<p>与 ArrayList 不同，HashMap 没有手动扩容的过程，只会根据容器当前的情况自动扩容。</p>
<p>扩容操作由 <code>resize()</code> 方法来完成，扩容操作主要干三件事：</p>
<ul>
<li>确定桶的个数</li>
<li>确定 threshold 的值</li>
<li>将所有的元素移到新的桶中</li>
</ul>
<blockquote>
<p><strong>参数说明</strong>
oldCap: 扩容前桶的个数
oldThr: 扩容前 threshold 的值
newCap: 扩容后桶的个数
newThr: 扩容后 threshold 的值</p>
</blockquote>
<p>扩容流程如下：
<img src="hashmap-resize.png" alt=""></p>
<p>扩容时会新建一个 Node（桶）数组，然后把原容器中的键值对重新作 hash 操作，然后放到新的桶中。</p>
<p>HashMap 的容量有上限，为 $2^{30}$，也就是 1073741824，桶的个数不会超过这个数，threshold 的最大值是 2147483647，是最大容量的两倍少1。</p>
<p>这样设置代表这个如果桶的个数达到了最大容量，就不会再进行扩容操作了。</p>
<h2>具体实现</h2>
<p><img src="hashmap-con.png" alt=""></p>
<p>HashMap 的结构图如上，每个桶都是一个链表的头结点，对于 hash 值相同（哈希冲突）的 key，会放在同一个桶上。这也是 HashMap 解决哈希冲突的方法称之为<strong>拉链法</strong>。在 JDK1.8 以后，在插入键值对时，使用的是<strong>尾插法</strong>，而不再是头插法。</p>
<p>HashMap 与 Hashtable 的功能大致上一致。HashMap 的 key 和 value 都可以为 null。下面是主流 Map 的键值对是否可以为 null 的对比：</p>
<table>
<thead>
<tr>
<th>Map</th>
<th>key 是否可以为null</th>
<th>value 是否可以为 null</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Hashtable</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>TreeMap</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>HashMap 不是线程安全的。在多线程环境中，需要使用额外的同步机制，比如使用 <code>Map m = Collections.synchronizedMap(new HashMap(...));</code>。</p>
<p>HashMap 也支持 fail-fast 机制。</p>
<h3>hash 方法</h3>
<p>hash 方法对 HashMap 非常重要，直接会影响到性能。键值对插入位置由 hash 方法来决定。假设 hash 方法可以让元素在桶上均匀分布，基本操作如 <code>get</code> 和 <code>put</code> 操作就是常量操作时间（$O(1)$）。</p>
<p>hash 方法需要有两个特点：</p>
<ul>
<li>计算的结果需要足够随机</li>
<li>计算量不能太大</li>
</ul>
<p>HashMap 中具体实现如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;&gt;</code> 是无符号右移操作，上面已经说到。假设现在有个 key 是 &quot;name&quot;，在我电脑上计算出来的值是：3373707，转变成二进制就是：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0111</span> <span class="number">1010</span> <span class="number">1000</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure>
右移 16 位后：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span> <span class="number">0011</span></span><br></pre></td></tr></table></figure>
然后进行<strong>异或</strong>运算：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0111</span> <span class="number">1010</span> <span class="number">1011</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
最后拿这个值与 HashMap 的长度减 1 进行与操作，因为 n 一定是 $2^x$，所以 (n-1) 的二进制全部是由 1 组成，下面这个操作相当于取 hash 值的后几位：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>
index 就是键值对的插入位置。</p>
<p>hash() 函数其实就是用来使键值对的插入位置足够随机，称之为<strong>扰动函数</strong>，如果对具体的策略感兴趣，可以参考这篇<a href="https://www.todaysoftmag.com/article/1663/an-introduction-to-optimising-a-hashing-strategy" target="_blank" rel="noopener">文章</a>。</p>
<blockquote>
<p>注：Object.hashcode() 是一个本地方法，返回对象的内存地址。Object.equals() 方法默认比较对象的内存地址，如果某个类修改了 equals 方法，那么 hashcode 方法也需要修改，要让 equals 和 hascode 的行为是一致的。否在在查找键值对的过程中就会出现 equals 结果是 true， hashcode 却不一样，这样就无法找到键值对。</p>
</blockquote>
<h3>容量和装载因子</h3>
<p>使用 HashMap 时，有两个参数会影响它的性能：<strong>初始容量</strong>和<strong>装载因子</strong>。</p>
<p>容量是指 HashMap 中桶的个数，初始容量是在创建实例时候所初始化桶的个数。</p>
<p>装载因子用来决定扩容的<strong>时机</strong>，进行扩容操作时，会把桶的数量设为原来的<strong>两倍</strong>，容器中所有的元素都会重新分配位置，扩容的代价很大，应该尽可能减少扩容操作。</p>
<p>装载因子的默认值是 0.75，这是权衡<strong>时间性能</strong>和<strong>空间开销</strong>的一个值。装载因子设置的越大，那么空间的开销就会降低，但查找等操作的性能就会下降，反之亦然。</p>
<p>在初始化 HashMap 的时候，初始容量和装载因子的值必须仔细衡量，以便尽可能减少扩容操作，如果没有特殊的情况，使用默认的参数就可以。</p>
<p>遍历 HashMap 所需的时间与容器的容量（桶的个数）及元素的数量成正比。如果迭代的时间性能很重要，就不要把<strong>初始容量</strong>设置的太大，也不要把<strong>装载因子</strong>设置的很小。</p>
<h3>树化操作</h3>
<p>在讲解具体的方法前，需要了解 HashMap 中一个重要的内部操作：<strong>树化</strong>。</p>
<p>HashMap 使用拉链法来解决哈希冲突问题。多个键值对被分配到同一个桶的时候，是以链表的方式连接起来。但这样会面临一个问题，如果链表过长，那么 HashMap 的很多操作就无法保持 $O(1)$ 的操作时间。</p>
<p>极端情况下，所有的键值对在一个桶中。那么 get、remove 等操作的时间复杂度度就都是 $O(n)$。HashMap 的解决方法是用<strong>红黑树</strong>来替代链表，红黑树查询的时间复杂度稳定在 $O(logn)$。</p>
<p>HashMap 在单个桶的的元素的个数超过 8(TREEIFY_THRESHOLD) 且桶的个数大于 64(MIN_TREEIFY_CAPACITY) 时，会把桶后面的链表转成树（类似于 <code>TreeMap</code>），这个操作称之为树化操作。</p>
<p>需要注意的是，当单个桶上的元素超过了8个，但桶的个数少于 64 时，不会进行树化操作，而是会进行<strong>扩容</strong>操作，代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap.treeifyBin() method</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// other code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
树化的过程是把链表的所有节点都替换成 TreeNode，然后再组成一棵红黑树（红黑树的具体构建过程可以查看这篇<a href="https://time.geekbang.org/column/article/68976" target="_blank" rel="noopener">文章</a>）。而且在链表转成树的过程中，每个节点之间的相对关系不会变化，通过节点的 <code>next</code> 变量来保持这个关系。</p>
<p>当树上的节点树少于 6(UNTREEIFY_THRESHOLD) 时，树结构会重新转化成链表。把树的每一个节点换成链表的节点，通过 next 重新组成一个链表：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap.ubtreeify()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">            tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即使遇到极端情况（所有的键值对在一个桶上），树化操作也会保证 HashMap 的性能也不会退化太多。</p>
<h3>增删改查操作</h3>
<p><strong>get 方法：</strong>
get 方法的实际操作是使用 getNode 方法来完成的。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap.getNode()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先检查容器是否为 null 以及 key 在容器中是否存在</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到相应的桶，从第一个节点开始查找，如果第一个节点不是要找的，后续节点就分成链表或者红黑树进行查找</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;</span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果链表已经转成了红黑树，则在红黑树中查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是树，则在链表中查找</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                   ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                   <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>put 方法：</strong>
用于插入或者更新键值对，实际使用的是 <code>HashMap.putVal()</code> 方法来实现。如果是第一次插入键值对，会触发<strong>扩容</strong>操作。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap.putVal() 删减了部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果是第一次插入键值对，首先会进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果一个桶的还没有插入键值对，则对第一个节点进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果是红黑树的结构，则按照红黑树的方式插入或者更新节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 否则按照链表的方式插入或者更新节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 如果没有找到键值对，则新建一个节点，把键值对插入</span></span><br><span class="line">                   p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                   <span class="comment">// 如果链表的长度大于等于 8，就会尝试进行树化操作</span></span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果找到了 key，则跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                   ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 已经存在，则把 value 更新为新的 value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">           V oldValue = e.value;</span><br><span class="line">           <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">               e.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fail-fast 版本号更新</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果容器中元素的数量大于扩容临界值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>remove 方法的实现与 get 方法类似。</p>
<p>clear 方法会将 map 中所有的桶都置为 null 来清空键值对。</p>
<p>其他的操作都是组合这几个基本的操作来完成。</p>
<h3>JDK8 的新特性</h3>
<p>在 JDK8 中，Map 中增加了一些新的方法，HashMap 对这些方法都进行了重写，加入了对 fail-fast 机制的支持。</p>
<p>这些方法是用上面的增删改查方法来实现的。</p>
<p>getOrDefault 方法，在值不存在的时候，返回一个默认值：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"xiaomi"</span>);</span><br><span class="line"></span><br><span class="line">map.getOrDefault(<span class="string">"gender"</span>,<span class="string">"genderNotExist"</span>); <span class="comment">// genderNotExist</span></span><br></pre></td></tr></table></figure></p>
<p>forEach 方法，遍历 map 中的键值对，可以接收 lambda 表达式：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"xiaomi"</span>);</span><br><span class="line"></span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(k +<span class="string">":"</span>+ v));</span><br></pre></td></tr></table></figure></p>
<p>putIfAbsent 方法，只有在 key 不存在时才会插入键值对：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"xiaomi"</span>);</span><br><span class="line"></span><br><span class="line">map.putIfAbsent(<span class="string">"gender"</span>, <span class="string">"man"</span>);</span><br></pre></td></tr></table></figure></p>
<p>computeIfAbsent 方法用来简化一些操作，下面方法1和方法2功能一样，都是在 key 不存在的情况下，通过某些处理后然后把键值对插入 map：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"xiaomi"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">Integer age = (Integer)map.get(<span class="string">"key"</span>);</span><br><span class="line"><span class="keyword">if</span> (age == <span class="keyword">null</span>) &#123;</span><br><span class="line">    age = <span class="number">18</span>;</span><br><span class="line">    map.put(<span class="string">"key"</span>, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line">map.computeIfAbsent(<span class="string">"age"</span>,  k -&gt; &#123;<span class="keyword">return</span> <span class="number">18</span>;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>computeIfPresent 方法则是在键值对存在的情况下，对键值对进行处理，然后再更新 map，下面方法1和方法2功能完全一样：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"xiaomi"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">Integer age = (Integer)map.get(<span class="string">"key"</span>);</span><br><span class="line">Integer age = <span class="number">18</span> + <span class="number">4</span>;</span><br><span class="line">map.put(<span class="string">"key"</span>, age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line">map.computeIfPresent(<span class="string">"age"</span>, (k,v) -&gt; &#123;<span class="keyword">return</span> <span class="number">18</span> + <span class="number">4</span>;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>merge 方法用来对相同的 key 的 value 进行合并，以下方法1和方法2的功能一致：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"xiaomi"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">Integer age = (Integer)map.get(<span class="string">"key"</span>);</span><br><span class="line">age += <span class="number">14</span>;</span><br><span class="line">map.put(<span class="string">"key"</span>, age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line">map.merge(<span class="string">"age"</span>, <span class="number">18</span>, (oldVal, newVal) -&gt; &#123;<span class="keyword">return</span> (Integer)oldVal + (Integer)newVal;&#125;);</span><br></pre></td></tr></table></figure></p>
<h3>其他功能</h3>
<p>HashMap 同样也实现了迭代功能，HashMap 中有三个具体 Iterator 的实现：</p>
<ul>
<li>KeyIterator: 遍历 map 的 key</li>
<li>ValueIterator: 遍历 map 的 value</li>
<li>EntryIterator: 同时遍历 map 的 key 和 value</li>
</ul>
<p>但是这个三个迭代器都不会直接使用，而是通过调用 HashMap 方法来间接获取。</p>
<ul>
<li>KeyIterator 通过 HashMap.keySet() 方法获取并使用</li>
<li>ValueIterator 通过 HashMap.vlaues() 方法获取并使用</li>
<li>EntryIterator 通过 HashMap.entrySet() 方法获取并使用</li>
</ul>
<p>Spliterator 的实现与迭代器的类似，分别对于 key、value 和 key + value 分别实现了 Spliterator。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS 中如何优雅的创建定时任务</title>
    <url>/2019/03/31/Mac-OS-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>Mac 中可以使用 crontab 一样的方式来使用定时任务。但是 crontab 来配置定时任务很容易出错。在 Mac 中，配置定时任务有更好的选择。</p>
<p>Mac 中有一个 <strong>launchctl</strong> 工具，这个工具是 Mac OS X 中用于启动进程的工具。Mac 中的各个进程都被配置成了 <strong>plist</strong> 文件。需要启动一个进行的时候只要执行以下命令：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">launchctl load xxx.plist</span><br></pre></td></tr></table></figure>
停止一个进程只需要：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">launchctl unload xxx.plist</span><br></pre></td></tr></table></figure></p>
<h3>Plist 文件配置</h3>
<p>在 Mac 系统中，可以将需要处理的事情都写在 plist 文件中，plist 是一个 xml 格式的文件。plist 文件根据不同的需要可以放在不同的目录底下。Mac OS X 中支持放 plist 的目录如下：</p>
<ul>
<li>/Library/LaunchDaemons: 系统启动后就会执行</li>
<li>/Library/LaunchAgents: 当用户登录系统后才会执行</li>
<li>~/Library/LaunchAgents: 用户自定义的 plist</li>
<li>/System/Library/LaunchAgents: 由 Mac OS X 为用户定义的任务</li>
<li>/System/Library/LaunchDaemons: 由 Mac OS X 定义的守护进程任务</li>
</ul>
<p>一个常见的 plist 文件模板如下：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> <span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Plist 名称，必须唯一--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>cn.rayjun..plist<span class="tag">&lt;/<span class="name">string</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 指定要运行的程序的名称，可以是一个程序或者是一段脚本 --&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>/path/to/programer<span class="tag">&lt;/<span class="name">string</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 执行时间的指定 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>StartCalendarInterval<span class="tag">&lt;/<span class="name">key</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!--在第几分钟会被执行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>Minute<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">integer</span>&gt;</span>00<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在第几个小时会被执行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>Hour<span class="tag">&lt;/<span class="name">key</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">integer</span>&gt;</span>22<span class="tag">&lt;/<span class="name">integer</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 运行日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/path/to/log/x.log<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 错误日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardErrorPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/path/to/err/x.err<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>plist 脚本编写完成后放入到相应的目录底下即可，然后执行一下 <strong>launchctl load xx.plist</strong> 就可以启动任务。</p>
<h3>定时任务配置</h3>
<p>在 Plist 中，支持两种定时任务的设置：</p>
<ul>
<li>StartInterval：定义任务多长时间（单位，秒）执行一次</li>
<li>StartCalendarInterval：这个配置类似在 crontab 中的配置，指定具体的执行日期、星期、每月、每日的各个时间点，具体参照上面的配置文件。月份和天数的配置类似。</li>
</ul>
<p>（完）</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器系列-Java容器总览</title>
    <url>/2019/11/23/Java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%97-Java%E5%AE%B9%E5%99%A8%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<p>Java 的容器是 Java 语言中很重要的一部分，日常写代码会大量用到各种容器。Java 中的容器有一个庞大的体系，纠缠于细节很难全面掌握。这篇文章就总览一下 Java 的容器，然后再深入到细节中学习。</p>
<p>Java 中的容器主要分为两部分，<strong>Collection</strong> 和 <strong>Map</strong> 两种。Collection 主要用于存储单个的元素。而 Map 则主要是存储键值对。</p>
<blockquote>
<p>本文基于 JDK1.8</p>
</blockquote>
<h3>Collection</h3>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/Java/collection/collection.jpg" alt=""></p>
<p>上图中圆圈代表<strong>接口</strong>, 长方形代表<strong>类</strong>，包括抽象类和普通类。绿色代表线程安全，黄色代表不是线程安全。上面的类图中只包括了 <code>java.util</code> 下的类，<code>java.util.concurrent</code> 下面的容器类从功能的角度上来说并没有太大不同，但是这个包下的类都是线程安全的。</p>
<p>从类图中可以看到 Collection 继承了 Iterator 接口,说明所有的 Collection 都可以通过<strong>迭代器</strong>来进行访问。</p>
<p>Collection 接口有三个子接口，<code>List</code>、<code>Set</code> 和 <code>Queue</code>。List 会按照元素的插入顺序保存元素，Set 中的元素都不能重复。Collection 中定义了一些公共的方法，都是一些基础的工具方法，比如获取容器的大小、判断容器时候为空、清空容器、迭代容器元素等方法。在 JDK1.8 以后，在 Collection 接口中加入了 default 方法，这些方法都是用于支持 Java8 的函数式编程。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Object[] toArray();</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) &#123;</span><br><span class="line">        <span class="keyword">return</span> toArray(generator.apply(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(java.util.Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(java.util.Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(java.util.Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(filter);</span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;E&gt; each = iterator();</span><br><span class="line">        <span class="keyword">while</span> (each.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter.test(each.next())) &#123;</span><br><span class="line">                each.remove();</span><br><span class="line">                removed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(java.util.Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>List</h4>
<p><code>List</code> 接口下的 ArrayList 日常写代码使用的很多。ArrayList 的部分代码如下。从代码中可以看到，ArrayList 底层的数据结构就是一个数组，而且 ArrayList 实现了 RandomAccess 来支持随机访问。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ArrayList 与数组的功能很像，但是提供了更多便利的操作。Vector 与 ArrayList 的功能基本一致，但是是线程安全的，Vector 的子类 Stack 同样也是线程安全的，但是这些类基本都不推荐再使用了。如果要使用线程安全的类，java.util.concurrent 中的 <code>CopyOnWriteArrayList</code> 是一种更好的选择。</p>
<p>LinkedList 与 ArrayList 功能也比较相近，从功能的角度上来说，它们之间最大的区别在于 ArrayList 支持<strong>随机访问</strong>，而 LinkedList 则不支持。LinkedList 部分代码如下，可以看到 LinkedList 底层使用的是双向链表的数据结构。而且还实现了 Deque 接口，所以除了可以作为列表容器来使用之外，还可以作为队列或者双端队列来使用。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LinkedList 同样在 java.util.concurrent 中提供 LinkedBlockingQueue 和 LinkedBlockingDeque 来实现同样的功能，除了在多线程环境比 LinkedList 更有优势外，功能方面基本没有差别。</p>
<h4>Set</h4>
<p>各类 <code>Set</code> 的共同点在于 set 的元素是不重复的，这一特性在一些情况下非常有用，HashSet 是用的最多的 Set 类。以下是 HashSet 的部分代码，比较有意思的是 HashSet 底层是使用 HashMap 实现的，所有的值都存着在 HashMap 的 Key 中，Value 的位置就放一个固定的对象 PRESENT。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E, Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HashSet 里面的元素是无序的，如果需要让 set 中元素有序，那么就可以使用 LinkedHashSet，LinkedHashSet 中通过构造一个双向链表来记录插入顺序。而 TreeSet 则是通过底层的红黑树结构提供了排序顺序的访问方式，具体用哪种可以看具体的需求。同样 Set 也有线程安全的版本 <code>CopyOnWriteArraySet</code>。</p>
<h4>Queue</h4>
<p><code>Queue/Deque</code> 是 Java 中的提供的 队列接口。ArrayQueue 是具体可以使用的队列类，可以作为普通队列或则双端队列来使用。但是队列在并发情况使用的更多一点，使用 LinkedBlockingQueue 或者 LinkedBlockingDeque 会是更好的选择。有时候除了顺序队列之外，可能还需要通过优先级来调度的队列，PriorityQueue 就是为这个需求而生的，在并发情况下与之对应的就是 PriorityBlockingQueue。</p>
<h3>Map</h3>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/Java/collection/map.jpg" alt=""></p>
<p>Map 的类图结构相对来说就简单很多。所有的 Map 类都继承了 Map 接口。HashMap 是使用的最多的 Map 类，HashMap 也是无序的，和 Set 类似，LinkedHashMap 和 TreeMap 也从不同的方面保证顺序，LinkedHashMap 通过双向链表来记录插入顺序。TreeMap 则是对其中的元素进行排序，可以按照排序的顺序进行访问。</p>
<p>作为 Map 的典型实现，HashMap 代码结构就复杂的多，HashMap 号称是有着 $O(1)$ 的访问速度（只是近似，在极端情况下可能退化成 $O(N)$）。这么快速的关键在于哈希函数的实现，哈希函数好的实现可以帮助键值对均匀的分布，从而有 $O(1)$ 的访问速度，以下是 HashMap 的哈希函数的实现，而且 HashMap 的扩容和处理哈希碰撞等问题的处理也很复杂。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>与 Collection 中的结构类似，HashTable 也与 HashMap 功能类似，但是 HashTable 是线程安全的。同样因为 HashTable 实现的方式不如 java.util.concurrent 中提供的性能好，所以不推荐使用 HashTable。在并发情况下推荐使用 ConcurrentHashMap，ConcurrentHashMap 通过分段锁的机制，在并发情况下也能有较好的性能。如果在并发情况下也需要保证 Map 的顺序，那就使用 ConcurrentNavigableMap。</p>
<h3>Collections 工具类</h3>
<p>在 java.util 包下有一个 Collections 类，这是一个工具类，里面所有的方法都是静态的，而且类不能被实例化。里面提供了各种方法，可以用来更有效率的操作各类容器对象。</p>
<p>比如对 List 排序：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line">list.add(<span class="number">6</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">8</span>);</span><br><span class="line">Collections.sort(list);</span><br></pre></td></tr></table></figure>
当然还可以自定义排序的规则，自己实现一个 <code>Comparator</code> 然后作为参数传入就好了。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123; </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1 &gt; o2 ? <span class="number">1</span> : <span class="number">0</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
还有开箱即用的二分查找算法:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.binarySearch(list, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>还可以直接把 list 进行反转：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.reverse(list);</span><br></pre></td></tr></table></figure>
还可以把 list 使用洗牌算法打乱：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.shuffle(list);</span><br></pre></td></tr></table></figure>
以上只是其中的一部分方法，还有可以交换 list 中的元素，找出 list 中的最小、最大值等方法。</p>
<p>因为 java.util 包下的容器大部分都不是线程安全的，Collections 有一类方法可以把 普通的容器对象转成线程安全的对象：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>
对于 Map 和 Set 也有类似的工具方法。</p>
<p>在并发环境下，还可以把一个普通容器对象转化成一个不可变的容器对象，这样在并发环境下也是线程安全的：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.unmodifiableList(list);</span><br></pre></td></tr></table></figure></p>
<p>(完)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器系列-LinkedList源码分析</title>
    <url>/2019/12/07/Java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%97-LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>LinkedList 作为 <code>List</code> 的另一种实现，也非常的经典。与 ArrayList 不同，LinkedList 底层使用的是<strong>双向链表</strong>来实现的，具体类图如下：</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/Java/collection/LinkedList.png" alt=""></p>
<p>相比于 ArrayList，LinkedList 继承了 AbstractSequentialList 类，而且实现了 Deque 接口，RandomAccess 接口就被没有实现。</p>
<p>但在实际的使用当中，LinkedList 使用的并没有 ArrayList 多，LinkedList 可以被当做队列和栈来使用，但是 <code>BlockingQueue</code> 使用的比它更为广泛，因为一般使用队列的地方都会涉及到比较高的并发，在高并发的情况下，<code>BlockingQueue</code> 比 LinkedList 更好用，<code>BlockingQueue</code> 以后会写专门的文章来介绍。</p>
<blockquote>
<p>本文基于 JDK1.8</p>
</blockquote>
<h3>成员变量</h3>
<p>LinkedList 的结构比 ArrayList 更简单，核心的成员变量如下，<code>size</code> 记录当前元素的个数，<code>first</code> 指向头结点，<code>last</code> 指向尾节点。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure></p>
<p><code>Node</code> 的代码如下，通过泛型来存储具体的元素，每个节点都可以获取前一个或者后一个节点，所以 LinkedNode 底层数据结构是<strong>双向链表</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为底层使用的双向链表，所以理论上来说 LinkedList 的容量是没有限制的，自然也没有了扩容的过程。</p>
<h3>实例化过程</h3>
<p>LinkedList 的实例化过程也相对简单，只提供了两个构造函数。</p>
<p>一个不带任何参数，也不需要做任何的数据初始化，头结点和尾节点的初始化都放在添加第一个元素的时候。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个构造函数接收一个 <code>Collection</code> 类型的对象，会把对象中的所有元素都添加到当前 LinkedList 对象中。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>();</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3>具体实现</h3>
<p>与 ArrayList 相比，LinkedList 有如下特点:</p>
<ul>
<li>不能随机访问</li>
<li>容量无限</li>
<li>可以用作<strong>队列</strong>、<strong>双向队列</strong>和<strong>栈</strong></li>
</ul>
<p>因为 LinkedList 没有实现 <code>RandomAccess</code> 接口，再加上本身底层的数据结构是双向链表，所以对链表中的元素不能随机访问，只能按照顺序访问。</p>
<p>而且对于链表来说，元素时可以无限扩展（理论上）的，所以 LinkedList 的容量也没有上限。</p>
<p>从 JDK1.6 开始，LinkedList 实现了 <code>Deque</code> 接口，这就表明 LinkedList 可以用作<strong>队列</strong>或者<strong>双向队列</strong>。</p>
<h4>增删改查方法</h4>
<p>List 中有的方法，LinkedList 中都实现了。</p>
<p>可以添加元素：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，添加元素的操作实际上是用 <code>linkLast()</code> 方法来完成的，在添加元素的过程中，如果发现头结点为空，那说明是添加第一个元素，只需要把头结点指向刚添加的节点就可以，以下代码是在尾部添加一个节点:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是把元素添加到链表的尾部，因为 LinkedList 还可以被用作队列和栈，因此还提供了从头部添加元素的方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然有添加元素的操作，也有删除元素的操作，代码如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>;</span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>清空 LinkedList 就是把所有的元素置为 null:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从以上代码可以发现，LinkedList 的操作都是对链表的操作。</p>
<h4>用作队列和栈</h4>
<p>做为普通队列时，可以在队列中进行入队和出队的操作。从队列头部获取一个元素，但是不删除元素 <code>peek()</code>:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从队列头部获取一个元素并删除，<code>poll()</code>:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在队列的尾部添加一个元素，<code>offer()</code>:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>普通队列只可以在一端入队，在另一端出队，但是对于双向队列，可以在两端执行入队和出队操作。</p>
<p>所以在在作为双向队列时，拿 peek 操作来说即可以 <code>peekFirst()</code> 也可以 <code>peekLast()</code>。其他的操作例如 offer、poll 同样类似。</p>
<p>LinkedList 中还有 <code>push()</code> 和 <code>pop()</code> 操作。被当做栈使用时，只需要对头部节点进行操作就行。</p>
<p>入栈操作:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>出栈操作:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4>其他功能</h4>
<p>LinkedList 中也实现了 ListIterator 和 Spliterator 接口。</p>
<p>所以 LinkedList 也可以从两端进行遍历。在遍历的时候，同样也有 fail-fast 机制来检查遍历的过程当中，容器中的元素是否被修改。</p>
<p>在实现 Spliterator 接口之后，也可以对容器中的元素进行分段，然后同时让多个线程同时进行处理，提高处理效率。分割 LinkedList 的代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Spliterator&lt;Integer&gt; splitor = list.spliterator();</span><br><span class="line">    Spliterator&lt;Integer&gt; s1 = splitor.trySplit();</span><br><span class="line">    Spliterator&lt;Integer&gt; s2 = s1.trySplit();</span><br><span class="line"></span><br><span class="line">    System.out.println(s1.estimateSize()); <span class="comment">// 10</span></span><br><span class="line">    System.out.println(s2.estimateSize()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
(完)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器系列-Fail-Fast机制到底是什么</title>
    <url>/2019/12/14/Java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%97-Fail-Fast%E6%9C%BA%E5%88%B6%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p><code>fail-fast</code> 实际上是一种系统设计的方法，维基百科上是这样解释的：</p>
<blockquote>
<p>在系统设计中，一个 fail-fast 的系统可以通过特定的接口快速报告系统中任何潜在的故障。fail-fast 系统在发现故障时不会尝试继续运行系统，而会立即停止当前的操作。在进行一个操作时，会在多个检查点检查系统的状态，所以出现故障可以被尽早发现。fail-fast 模块的职责就是检查是否有故障，发现故障后会尽快通知上层系统来处理故障。</p>
</blockquote>
<p>上面的文字看起来有点晦涩，实际的意思就是 fail-fast 是一种快速发现系统故障的机制，在检测到系统状态不对时，会立即停止当前的操作，让上层的系统来处理这些故障。</p>
<p>与 fail-fast 相对的是 fail-safe。顾名思义，fail-safe 在故障发生之后会维持系统继续运行。Java 在容器中用到了这两种机制。</p>
<p>当使用迭代器(iterator)遍历容器时，迭代器分为两种情况，一种是 fail-fast，另一种是 fail-sale。</p>
<p>fail-fast 在遍历时，如果容器的元素被修改，就会报 ConcurrentModificationException 异常，然后终止遍历。</p>
<p>fail-safe 意味着在遍历元素时，即使容器的元素被修改，不会抛出异常，也不会停止遍历。</p>
<blockquote>
<p>本文基于 JDK1.8</p>
</blockquote>
<h3>fail-fast 具体实现</h3>
<p>看如下的代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">integers.add(<span class="number">1</span>);</span><br><span class="line">integers.add(<span class="number">2</span>);</span><br><span class="line">integers.add(<span class="number">3</span>);</span><br><span class="line">Iterator&lt;Integer&gt; itr = integers.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line">    Integer a = itr.next();</span><br><span class="line">    integers.remove(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面使用 ArrayList 的代码会报 ConcurrentModificationException 异常。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">integers.add(<span class="number">1</span>);</span><br><span class="line">integers.add(<span class="number">2</span>);</span><br><span class="line">integers.add(<span class="number">3</span>);</span><br><span class="line">Iterator&lt;Integer&gt; itr = integers.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line">    Integer a = itr.next();</span><br><span class="line">    integers.remove(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而使用 CopyOnWriteArrayList 的代码则不会报异常。</p>
<p>fail-fast 机制和 modCount 这个变量有关，这个变量会记录容器被修改的次数，可以理解为容器对象的版本号。</p>
<p>那么容器怎样才算是被修改呢？</p>
<ul>
<li>当容器元素被删除</li>
<li>当容器增加一个元素</li>
<li>当容器中的元素执行了排序操作</li>
<li>当容器被其他容器对象替代</li>
</ul>
<blockquote>
<p>需要注意，修改容器中元素的内容 modCount 不会增加</p>
</blockquote>
<p>当容器使用迭代器对元素进行迭代时，会把 modCount 赋值给 expectedModCount。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure></p>
<p>在迭代的过程中，会不断的去检查 expectedModCount 与 modCount 的值是否相等，如果不相等，就说明在容器迭代的过程中，有其他的操作修改了容器，导致 modCount 的值增加，那么就会报 ConcurrentModificationException 异常。</p>
<blockquote>
<p>注：fail-fast 机制不仅仅在迭代器中使用了，容器的增删改查和序列化等操作中也用到了。</p>
</blockquote>
<p>有没有办法在迭代的过程中删除某些元素？使用迭代器本身的 remove 方法就行，这样不会产生异常:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; itr = integers.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (itr.next() == <span class="number">2</span>) &#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不会产生异常的原因是在删除元素后，把最新的 modCount 的值赋值给了 expectedModCount，代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListItr.remove() method</span></span><br><span class="line">ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">cursor = lastRet;</span><br><span class="line">lastRet = -<span class="number">1</span>;</span><br><span class="line">expectedModCount = modCount;</span><br></pre></td></tr></table></figure></p>
<p>fail-fast 机制可以用来检测容器元素是否被修改，但是需要注意的是，不能依赖 fail-fast 机制来保证容器的元素不被修改，也就是说，不要在没有<strong>同步</strong>的情况下并发的修改容器中的元素。fast-fast 机制本来的职责就是检测系统的错误，所以仅仅只用它来检测 bug，而不要作其他的用途。</p>
<blockquote>
<p>注：同步是并发编程中的一个术语，如果说一段代码是同步的，那就代表是线程安全的</p>
</blockquote>
<h3>fail-safe 具体实现</h3>
<p>和 fail-fast 不同的是，使用了 fail-safe 的容器则可以在迭代的过程中任意的修改容器的元素而不会报错。本质是因为迭代的是容器元素的副本，也就是说是将容器的元素拷贝了一份再进行遍历，这样即使原容器被修改，也不会影响到当前正在遍历的元素。</p>
<p>CopyOnWriteArrayList 是一个支持 fail-safe 的容器，它获取迭代器的代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CopyOnWriteArrayList.listIterator() method</span></span><br><span class="line">Object[] es = getArray();</span><br><span class="line"><span class="keyword">int</span> len = es.length;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; len)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBounds(index, len));</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(es, index);</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// COWIterator inner class</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">COWIterator(Object[] es, <span class="keyword">int</span> initialCursor) &#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
COWIterator 将容器的元素做了一个快照，后续的操作都是在这个快照上进行的。</p>
<p>为了支持 fail-safe 特性，需要付出额外的代价：</p>
<ul>
<li>迭代器中的元素不是容器的最新状态</li>
<li>需要额外的内存或者时间上的开销</li>
</ul>
<p><code>java.util</code> 包下的容器都有 fail-fast 机制，而<code>java.util.concurrent</code> 包下的容器则都是 fail-safe 的。</p>
<p>REF:</p>
<ul>
<li>https://medium.com/@mr.anmolsehgal/fail-fast-and-fail-safe-iterations-in-java-collections-11ce8ca4180e</li>
<li>https://en.wikipedia.org/wiki/Fail-fast</li>
<li>https://en.wikipedia.org/wiki/Fail-safe</li>
<li>JDK document</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引简明教程</title>
    <url>/2019/01/06/MySQL%E7%B4%A2%E5%BC%95%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3>MySQL 索引</h3>
<p>在 MySQL 中建立索引就像是为一本书创建目录一样，建立了索引之后，MySQL 就能快速在表中找到所要查询的内容的大致区域，如果不使用索引，那么就需要去整张表中遍历数据才能查询到结果。</p>
<p>MySQL 的索引是建立在表的基础之上的，一个表中可以用多个索引。在表中建立索引后，虽然查询的效率提高了，但是 insert 和 update 操作的效率就降低了。</p>
<h4>索引的类型</h4>
<p>在 MySQL 中可以建立多种类型的索引，比如最常用的就是<strong>主键索引</strong>，索引有以下的类型：</p>
<ul>
<li>唯一索引(UNIQUE)：不允许出现相同的值，可以有 NULL 值</li>
<li>普通索引(Index)：允许出现相同的索引内容</li>
<li>主键索引(PRIMARY KEY)：不允许出现相同的值</li>
<li>全文索引(FULLTEXT INDEX)：可以为值中的某个值建立索引，但是全文索引的效率很低，而且全文索引的优先级很高</li>
</ul>
<p>通常是把一个字段创建为一个索引，但是同时也可以在一个索引中使用多个字段，这种索引称之为<strong>组合索引</strong>。</p>
<h4>索引的创建与删除</h4>
<p>索引可以在建表阶段或者表建立之后进行创建，在建表阶段，使用 <strong>CREATE INDEX</strong> 建立索引：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">on</span> table_name (column_list)</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">on</span> table_name (column_list)</span><br></pre></td></tr></table></figure>
CREATE INDEX 只能创建<strong>普通索引</strong>和<strong>唯一索引</strong>这两种类型的索引。</p>
<p>还有一种方式就是通过 <strong>ALTER TABLE</strong> 方式创建索引：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 省略索引名称，索引名称和第一个列名一样</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">index</span> (column_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">index</span> index_name (column_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> uniuque (column_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> primary <span class="keyword">key</span> (column_list)</span><br><span class="line"></span><br><span class="line">// 为索引指定长度</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">index</span> index_name (<span class="keyword">column</span>(<span class="keyword">length</span>))</span><br></pre></td></tr></table></figure></p>
<p>删除索引可以通过 <strong>ALTER TABLE</strong> 和 <strong>DROP INDEX</strong> 来实现：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">on</span> table_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> <span class="keyword">index</span> index_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> primary <span class="keyword">key</span></span><br></pre></td></tr></table></figure></p>
<h4>索引的使用</h4>
<p>在创建完索引之后，并不需要手动去使用索引，而是由 MySQL 的引擎来决定是否使用索引，可以通过 <strong>EXPLAIN</strong> 关键字来查看 MySQL 是如何使用索引的，同时也可以通过这个关键词来分析 SQL 语句，使用起来很方便，只需要加在 SQL 前就可以：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username = <span class="string">'ray'</span></span><br></pre></td></tr></table></figure></p>
<p>在 SQL 要避免以下的查询，以下的查询都不会使用索引：</p>
<ul>
<li>索引列参与了计算或者使用了函数运算</li>
<li>查询的时候使用了正则表达式</li>
<li>字符串与数字进行比较</li>
<li>使用 or 查询，但是不是所有的条件都有索引</li>
<li>语句中使用 NOT IN、&lt;&gt;、!= 操作</li>
</ul>
<h4>索引建立原则</h4>
<ul>
<li>单表中索引的数量需要控制</li>
<li>添加索引时最好不要加在字符串字段上</li>
<li>如果非要加在字段上，要限制索引的长度，只使用前缀索引</li>
<li>不要使用 not in \ like 等查询字段，如果非要使用 like，使用后匹配 like， 如 &quot;beijing%&quot;，not in 使用 not exists 替代</li>
<li>不要在低基数列创建索引，比如 <strong>status</strong> 字段</li>
<li>尽量不要在经常修改的列上添加索引</li>
<li>删除冗余索引，没有用到的索引必须全部删除</li>
<li>创建索引的列不应该有 null 值，有 null 值得列是不会加入到索引中的</li>
<li>如果是多条件查询，不要为每个条件字段创建索引，而是应该创建复合索引，<strong>MySQL一次只会使用一个索引</strong></li>
<li>在创建复合索引时，要注意索引的左匹配原则，如果创建了 index(c1, c2, c3)，那么就相当于同时创建了 index(c1), index(c1, c2) 和 index(c1, c2, c3) 这三个索引</li>
<li>数据库的主键最好是使用自增的，如果担心主键泄露信息，可以再使用一个uuid类型的字段对外展示</li>
</ul>
<h4>字符串索引优化</h4>
<p>添加一个冗余字段，将字符串使用 hash 方法将字符串转化为整数，例如：username_key=hashToInt(username)，对username_key建立索引，查询时可以用如下查询</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username_key = hashToInt(‘ray’) <span class="keyword">and</span> username = ‘ray</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引与B+树</title>
    <url>/2019/05/14/MySQL%E7%B4%A2%E5%BC%95%E4%B8%8EB+%E6%A0%91/</url>
    <content><![CDATA[<p>索引是 MySQL 中最重要的功能之一。</p>
<p>在日常使用数据库的过程中，使用的最多功能是:</p>
<ul>
<li>根据某一列特定的值查找数据</li>
<li>根据某一列特定值的范围查找数据。</li>
</ul>
<p>在数据库中数据规模不大的情况下，每次查询都进行全表的扫描查询，这样也是可以接受的。一旦数据库的数据规模增长了很大之后，如果还是使用全表扫描的方式，那么查询的性能就会直线下降。</p>
<p>索引的存在就是为了解决这个问题的。理解索引最好的方式就是类比树的目录。实际上这两者的思想也是类似的。对于书的目录，有两个很重要的特性：</p>
<ul>
<li>目录是按照内容的顺序组织起来的</li>
<li>目录中不包含所有的内容，只包含章节的标题</li>
</ul>
<p>这两点也是索引最重要的特性。第一个特性保证了可以支持区间查找和排序，第二个特性保证了索引的查询要比直接全表扫描的速度快的多。</p>
<p>那么索引的底层数据结构是什么呢？如果才能满足索引的这些要求。MySQL 中目前使用的最为广泛的索引的底层数据结构就是 B+ 树。</p>
<h3>B+ 树</h3>
<p>B+ 树是基于 B 树改造而来的，B 树就是平衡树（Balance Tree），二叉查找树就是一种典型的平衡树。</p>
<p>B+ 树与二叉查找树的结构很像，但是 B+ 树与二叉查找树最大的不同之处有两个地方:</p>
<ul>
<li>B+ 树的所有节点通过一条<strong>双向链表</strong>连接</li>
<li>B+ 树不是二叉，是 m 叉，m 的值根据实际的情况调整</li>
</ul>
<p>所以 B+ 树是下面这个样子:</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/mysql/B%2B%E6%A0%91.png" alt=""></p>
<p>对于 B+ 树来说，这两个设计很关键，第一个是为什么要使用双向链表，因为索引需要支持区间查找，如果使用单链表，那就只能支持单向区间查找了，反向的查找就支持不了，比如 ：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> age &lt; <span class="number">18</span>;</span><br></pre></td></tr></table></figure></p>
<p>第二就是为什么 B+ 树是 m 叉，而不是二叉。二叉树的每个节点最多有两个子节点，如果一张数据库表中的数据有百万条，那么按照二叉树的方式来构造索引，二叉树的高度就会过高。这样会带来两个问题：</p>
<ul>
<li>树的高度过高就会占据更多的内存，这个与建立索引的初衷相违背</li>
<li>索引是不断在动态调整的，如果树的高度过高，在调整的过程中就会带来更多的元素移动和计算</li>
</ul>
<p>为了避免上述的原因，B+ 被设计成了 m 叉树。B+ 树与<strong>跳表</strong>的结构非常类似。</p>
<p>即使是设计成了 m 叉树，也还是存在没有解决的问题。因为索引是在数据的增删改查中不断被动态调整的。所以很有可能出现某个节点的节点树超过了 m 个，如果不对这种情况进行处理，最后 B+ 树甚至会退化成一个链表。还有就是一个节点上的数据不断被删除，最后剩下的节点远远少于 m 个，这样就会造成空间的浪费。</p>
<p>针对这些情况，都需要在索引更新的过程中进行调整。如果一个节点的子节点超过了 m，那就会将这个节点分裂成两个节点，如果一个节点的节点数少于 m / 2，那么就会将这个节点与相邻的节点进行合并。通过这样的方式来保证 B+ 树上所有的节点是均衡分布的。</p>
<h3>MySQL 索引</h3>
<p>MySQL 中索引是在存储引擎上实现的。除了 B+ 树索引外，也还支持其他的索引，但是 B+ 树是使用的最为广泛的索引。</p>
<ul>
<li>B+ 树索引：大多数 MySQL 存储引擎默认的索引</li>
<li>哈希索引：$O(1)$ 的查找效率，但是失去了有序性，不支持范围查找</li>
<li>全文索引：MyISAM 存储引擎支持的全文索引</li>
<li>空间数据索引：用于存储地理数据</li>
</ul>
<p>使用索引减少了数据查询时需要扫描的数据行数。之前有提到索引都是按照内容的顺序组织起来的。所以通过索引查询时也就避免了创建临时表去排序，特别是在查询语句种使用了 <strong>order by</strong> 和 <strong>group by</strong> 时。</p>
<p>但是也不是所有的情况都适合使用索引，在数据库中数据规模很小时，使用索引还不如不使用的效率高。对于特大型的表，维护索引的代价太大，这个时候索引已经解决不了问题了，可能就需要考虑使用拆分数据库了。</p>
<h4>索引的优化</h4>
<p><strong>索引必须使用在独立的列上</strong></p>
<p>索引必须单独使用，不能是表达式，也不能是函数的参数:</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> age + <span class="number">1</span> &gt; <span class="number">19</span>;</span><br></pre></td></tr></table></figure>
上面的用法就会导致 age 上的索引失效</p>
<p><strong>多列索引</strong></p>
<p>索引可以多列组合使用：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'xm'</span> <span class="keyword">and</span> age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure>
<strong>索引的排列顺序</strong></p>
<p>在使用索引时，需要注意索引列的排列顺序，应当将索引选择性大的列放在前面。比如上面 sql 中的 <strong>name</strong> 和 <strong>age</strong> 列，假设 <code>name = 'xm'</code>  可以区分出查找出 5 条记录，而 <code>age = 18</code> 可以查出 20 条记录，那么 name 索引的选择性就是大于 age 的。</p>
<p><strong>前缀索引</strong></p>
<p>对于 <code>BLOB</code> 、<code>TEXT</code> 、<code>VARCHAR</code> 类型的列，必须使用前缀索引，只索引前面特定长度的字符。</p>
<p>如果对整个字段进行索引，就会导致整个索引过于庞大，反而会降低查询的效率。</p>
<p><strong>覆盖索引</strong></p>
<p>索引中包含所有需要查询的值。</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Play with Go</title>
    <url>/2021/04/17/Play-with-Go/</url>
    <content><![CDATA[<p>在开始学习 Go 语言之后，我发现 Go 语言对于初学者实在是太友好了。</p>
<p>Go 语言的文档很全面，可以说，在开始学习 Go 语言的时候，直接通过 Go 的文档开始就可以了，比如从 <a href="https://tour.golang.org/welcome/1" target="_blank" rel="noopener">A tour of Go</a> ， 就是一份很不错的入门教程，可以直接在网页端的交互式学习，都不需要在本地安装 Go 的环境，而且里面的知识点覆盖的很全面，跟完整个教程之后，对 Go 就有了一个基本的了解。</p>
<p>还有 <a href="https://blog.golang.org/" target="_blank" rel="noopener">Go blog</a> 也很很不错，Go 语言的最新动态，版本的发布，特性的更新，都会第一时间在这里更新。</p>
<p>当学完 A tour of Go 之后，需要开始进一步的学习，<a href="https://play-with-go.dev/" target="_blank" rel="noopener">play-with-go</a> 是一个不错的教程。这个教程可以看做是 A tour of Go 的进阶版。</p>
<p>这也是一个网页版的交互式教程：</p>
<p><img src="0.png" alt=""></p>
<p>左边是一个教程，包含一个个程序的片段和讲解，右边是一个交互式的命令行，这个命令行其实是 Google cloud 上的一台机器，每个用户使用的时候都会创建一个 session，但是不要在这里输入任何私密信息，毕竟是共享的，不是很安全。</p>
<p>左边的每个代码块都是可以点击的，点击之后，就会在右边的命令行中执行，当然也可以自己在右边的命令行中自己输入相关命令。</p>
<p>在一些教程中，需要你提交代码，在这里，会自动为你创建一个远程的 git 仓库，直接使用就可以，这个 git 仓库在 3个小时之后会随着 session 一起被销毁。</p>
<p>play-with-go 的具体教程还在不断丰富，目前已经覆盖如何写测试，Go Modules 、代码生成等教程，后续还会出现更多。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>RingBuffer 源码解析</title>
    <url>/2020/04/25/RingBuffer-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>RingBuffer 主要用于在生产者和消费者之间传递数据。至于核心的控制机制已经被转移到 <code>Sequencer</code> 中了，具体的控制机制后续会有写专门的文章，这里先聚焦 RingBuffer。</p>
<h2>RingBuffer 基本结构</h2>
<p>缓存行填充技术在 Disruptor 中被大量使用，在这里同样也用到了，关于缓存行填充在上一篇文章中已经姜的很详细了，就是为了将 RingBuffer 中不会修改的值一直缓存在 CPU 缓存中，减少访问内存的次数。</p>
<p>而且 RingBuffer 中的对象在 Disruptor 启动时就会被创建后，后续会对这些对象进行重复利用，而不用创建新的对象，所以 Disruptor 中也基本不用进行垃圾回收，以下的代码就是用来初始化对象：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(EventFactory&lt;E&gt; eventFactory)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bufferSize; i++)    &#123;        </span><br><span class="line">        entries[BUFFER_PAD + i] = eventFactory.newInstance();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在初始化 RingBuffer 时，需要指定三个参数，EventFactory，bufferSize 和 WaitStrategy。EventFactory 就是用来生成数组中元素的工厂，如上代码。</p>
<p>bufferSize 是用来存储消息的数组的容量， 必须是 2 的次方，在 Java 的 HashMap 中，也需要保证容量是 2 的次方，这两个地方的设计是相同的，都是为了可以快速找到目标地址。</p>
<p>我们知道 RingBuffer 中是使用循环数组来存储消息，获取元素位置的时候一般会使用 &amp; 来获取元素位置，如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">long</span> sequence)</span></span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> (E) UNSAFE.getObject(entries, REF_ARRAY_BASE + ((sequence &amp; indexMask) &lt;&lt; REF_ELEMENT_SHIFT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
sequence 就是当前消息的序列号，indexMask 的值是 bufferSize - 1。在 bufferSize 的值为 2 的 N 次方的情况下，sequence &amp; indexMask 的值就是元素的位置。在 HashMap 中，如果传入的值不是 2 的 N 次方，会被自动转成最接近传入值的 2 的 N 次方，而在 Disruptor 中，则会直接报错。</p>
<p>其实利用取余操作也可以获取到元素的位置，但是取余的操作效率是比 &amp; 操作效率低，对于 Disruptor 这么最求性能极致的框架来说，怎么会放过这个压榨性能的机会。</p>
<p>WaitStrategy 是消费者在等待 RingBuffer 中消息的策略，默认是 BlockingWaitStrategy，也就是获取不到消息时进行阻塞，也可以根据的自己的需要实现自己的等待策略。</p>
<p>创建 RingBuffer 时，可以指定是一个生产者还是多个生产者，但实际就是创建不同的 Sequencer，Sequencer 的原理我们下篇文章再讲：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成支持多个生产者的 RingBuffer， 实际是创建不同的 Sequencer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">RingBuffer&lt;E&gt; <span class="title">createMultiProducer</span><span class="params">( EventFactory&lt;E&gt; factory, <span class="keyword">int</span> bufferSize, WaitStrategy waitStrategy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MultiProducerSequencer sequencer = <span class="keyword">new</span> MultiProducerSequencer(bufferSize, waitStrategy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RingBuffer&lt;E&gt;(factory, sequencer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成支持单个生产者的 RingBuffer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">RingBuffer&lt;E&gt; <span class="title">createSingleProducer</span><span class="params">(EventFactory&lt;E&gt; factory, <span class="keyword">int</span> bufferSize, WaitStrategy waitStrategy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SingleProducerSequencer sequencer = <span class="keyword">new</span> SingleProducerSequencer(bufferSize, waitStrategy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RingBuffer&lt;E&gt;(factory, sequencer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了上面两种默认的方式之外，还可以通过 create 方法来创建指定类型的 RingBuffer。</p>
<p>RingBuffer 的核心功能就是存储和传输消息，其他功能已经被抽离到其他组件中。</p>
<h2>RingBuffer 如何传输数据</h2>
<p>RingBuffer 的核心功能就是将消息从生产者取过来，然后给消费者处理。</p>
<h3>生产者生产数据</h3>
<p>在 RingBuffer 中有很多 translateAndPublish 重载方法，支持不同的参数，但是核心都是传入一个 <code>EventTranslator</code> 的实现类，并且需要实现 <code>translateTo</code> 方法，也就是说，如何将数据放进 RingBuffer 操作又回到了用户的手上。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">translateAndPublish</span><span class="params">(EventTranslatorOneArg&lt;E, A&gt; translator, <span class="keyword">long</span> sequence, A arg0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        translator.translateTo(get(sequence), sequence, arg0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        sequencer.publish(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的 EventTranslator 实现如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventTranslatorOneArg&lt;LongEvent, ByteBuffer&gt; TRANSLATOR =</span><br><span class="line">            <span class="keyword">new</span> EventTranslatorOneArg&lt;LongEvent, ByteBuffer&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">translateTo</span><span class="params">(LongEvent event, <span class="keyword">long</span> sequence, ByteBuffer bb)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    event.set(bb.getLong(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure></p>
<p>除了利用 EventTranslator，我们也可以自己来实现完整的生产者，如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongEventProducer</span><span class="params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span><span class="params">(ByteBuffer bb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sequence = ringBuffer.next();  </span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            LongEvent event = ringBuffer.get(sequence); </span><br><span class="line">            event.set(bb.getLong(<span class="number">0</span>));  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对比这两种不同的实现可以发现，在将消息存入 RingBuffer 时，需要获取一个 sequence，并且在存入数据后需要调用 publish 方法。</p>
<p>获取 sequence 表示的就是当前可以存入数据的位置，在存入数据之后，需要通过 publish 方法高速消费者这个位置的消息可用。</p>
<h3>消费者处理数据</h3>
<p>在实例化 Disruptor 时，需要配置 Handler：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;LongEvent&gt;(factory, bufferSize, DaemonThreadFactory.INSTANCE);</span><br><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> LongEventHandler());</span><br></pre></td></tr></table></figure>
同样，数据具体如何处理，也由用户自己来决定：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LongEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Event: "</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Disruptor 支持多个消费者，所以可以添加多个消费者:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> LongEventHandler(), <span class="keyword">new</span> AnotherLongEventHandler());</span><br></pre></td></tr></table></figure></p>
<p>当然也可以调整这几个 Handler 之间的执行顺序：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> LongEventHandler()).then(<span class="keyword">new</span> AnotherLongEventHandler());</span><br></pre></td></tr></table></figure></p>
<p>随着 Disruptor 的演进，RingBuffer 功能也慢慢变的单一，只要负责数据的存储和传输，不需要负责具体的控制逻辑，这样整个框架结构更je简单，内聚性更好，这个符合 Disruptor 追求极致性能的目标。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java Disruptor</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis集群是如何运行的</title>
    <url>/2020/03/13/Redis%E9%9B%86%E7%BE%A4%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p>Redis 在线上环境使用的时候，基本不会使用单机，而是会使用多台机器来配合使用，以便提高 Redis 的可靠性。</p>
<p>多机器情况下，Redis 有三种使用方式：</p>
<ul>
<li>主从模式</li>
<li>哨兵模式</li>
<li>集群模式</li>
</ul>
<p>但是主从模式和哨兵模式比较适合机器数量比较少的情况，如果机器的数量很多，那么这两种方式就不合适了。</p>
<p>这时候就需要用到集群模式了。Redis 实现集群的关键有两点，<strong>主从复制</strong>和<strong>分片</strong>。</p>
<h3>主从复制</h3>
<p>主从复制是用来保证服务高可用的常见方式，Redis 中的实现也没有特别之处。</p>
<p>Redis 配置主从模式很简单，假设现在有两个节点，10.123.123.100：6379 和 10.123.123.101：6379，将前一台机器设置为主节点，后台一台设置为从节点，只需要执行以下的命令就可以：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10.123.123.101:6379&gt; SLAVEOF 10.123.123.100 6379</span><br></pre></td></tr></table></figure></p>
<p>主节点和从节点的数据完全一样。从节点在接上主节点时，就会从主节点上开始同步数据，第一次同步时，会复制完整的数据，后续断开重连时，不需要复制完整的数据，只需要复制缺失的那部分。</p>
<p>主节点和从服务器会都会维护一个偏移量，掉线的节点重新连上来之后会把自己的偏移量发送给主节点。然后主节点就会把缺失的那部分数据发给从节点。</p>
<p><img src="redis1.png" alt=""></p>
<p>主从节点通过心跳检测来判断网络连接状态。</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10.123.123.101:6379&gt; REPLCONF ACK offset</span><br></pre></td></tr></table></figure>
其中 offset 是复制的偏移量。</p>
<p>一个 Redis 集群就是有多个这样的主从节点来组成。Redis 在集群状态下，所有<strong>写操作都会在主节点上进行，读操作都会在从节点上操作</strong>，这样也达到了读写分离的效果。</p>
<h3>分片</h3>
<p>分片还有一个常见的名称，<strong>分表分库</strong>，通过一定的算法将 key 放到某个节点之中。</p>
<p>Redis 中将数据的的存储区域分成了 16348 个 slot。每一个 slot 中存放的键值对都不相同，就相当于分表分库。</p>
<p>每个主节点会管理其中一部分 slot，至于 key 会被分配到哪个区域是靠 CRC16 这个算法来实现的。</p>
<p>CRC16 算法用来计算 key 的 CRC-16 校验和。</p>
<blockquote>
<p>CRC 的全称是循环冗余检测，通常用于错误检测，CRC-16 表示是16位循环冗余检测算法，类似还有 CRC-8 和 CRC-32 算法</p>
</blockquote>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CRC16(key) &amp; <span class="number">16383</span></span><br></pre></td></tr></table></figure></p>
<p>上面函数的结算结果会产生一个 0 - 16383 之间的值，根据值将请求分配到不同的节点进行操作。</p>
<p>当 Redis 主从和 slot 机制组合之后，就会形成如下的结构。</p>
<p><img src="redis3.png" alt=""></p>
<p>这样的结构下，每个主节点及其从节点中的数据是完全一致的，而不同主节点之间的数据则是完全不同的。</p>
<p>这样的架构设计让 Redis 有很好的弹性，可以自由的扩容和缩容。新的主节点上线之后，就会被分配部分 slot，后续的请求都会转到该节点之上。下线一个主节点之后，该主节点管理的 slot 就会被分配到其他的主节点上。</p>
<p>需要注意的是，Redis 的 16348 个 slot 都必须处在上线状态，整个集群才能对外提供服务，因为 slot 会分配到每一个主节点，如果 Redis 集群中一个主节点及其从节点都挂了，就会导致整个 redis 集群挂掉。</p>
<p>slot 的数量最大为16384，所以一个 Redis 集群中主节点的最大个数是 16384，但每个主节点又可以有多个从节点，这个数量没有限制。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 简明教程</title>
    <url>/2018/12/23/Jenkins-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>持续交付现在是一个软件团队非常想达到的一个目标，一个良好运转的持续交付平台能够大大提高开发的效率。持续交付可以分为两部分：</p>
<p><strong>持续交付 = 持续集成 + 自动部署</strong></p>
<blockquote>
<p>本文以 Java Web 项目为基础进行</p>
</blockquote>
<h4>持续交付的工作流程</h4>
<p>持续交付的流程可以分成 <strong>代码提交-&gt;代码拉取-&gt;构建-&gt;部署到机器</strong></p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/autodeploy.png" alt=""></p>
<p>现在主流的内部代码托管平台是 <strong>Gitlab</strong>，而持续集成使用的比较多的工具就是 <strong>Jenkins</strong> 了。这两个工具都是开源的，而且都有着丰富的插件来支持不同的持续交付的需求。至于部署应用对于不同的需求差别就很大了，简单的部署写一个部署脚本就可以解决了，复杂的大量的部署就需要自动部署的工具了。</p>
<h4>Jenkins 简介：</h4>
<p>Jenkins 是一个开源的持续集成工具，Jenkins 有着丰富的插件，可以按照自己的环境灵活的定制构建和发布流程。还能监控集成环境中产生的错误，并且会产生详细的日志文件，这些日志对于排错有着非常大的帮助。通过图表可以方便的统计出近期的构建质量。</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/jenkins.png" alt=""></p>
<p>在整个持续交付的过程中，Jenkins 主要干两件事，第一件事就是从托管平台上拉取最新的代码，然后将这些代码构建成我们的部署包。第二件事就是就这些应用包分发到目标机器上。</p>
<p>Jenkins 可以安装代码托管平台的插件，比如 Gitlab 的插件，在流程构建起来后，只要 Gitlab 上有新的代码提交，那么 Jenkins 就会触发自动的构建的流程将代码部署上去。</p>
<p>目前在 Jenkins 上使用的最多的是 Pipline 流程。</p>
<h4>Jenkins Pipline 工作流程</h4>
<p>Jenkins Pipline 是运行在 Jenkins 上的一个工作流框架，并且支持将原来运行的一个个单独的工作串联起来构建一个复杂的工作流程。而且这个工作流程是非侵入式的，也就是说，对于不同的项目可以灵活的构建不同的工作流程，而不需要去对 Jenkins进行二次开发。而定义一个 Pipline 的工作流程，只需要一个简单的 <strong>Groovy</strong> 脚本：</p>
<p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Build'</span>) &#123;</span><br><span class="line">        steps &#123;</span><br><span class="line">            sh <span class="string">'~/shell/jenkins_check_build.sh'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Test'</span>) &#123;</span><br><span class="line">        steps &#123;</span><br><span class="line">            echo <span class="string">'Testing'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Deploy - Staging'</span>) &#123;</span><br><span class="line">        steps &#123;</span><br><span class="line">            echo <span class="string">'./deploy staging'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Deploy - Production'</span>) &#123;</span><br><span class="line">        steps &#123;</span><br><span class="line">            sh <span class="string">'~/shell/jenkins_check_deploy.sh'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个完成的 Pipline 中有多个 <strong>stage</strong>，对于不同的 stage 可以执行的不同的任务，这些任务都是可以通过自定义脚本来实现的。</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/pipline.png" alt=""></p>
<p>这些脚本甚至都不用部署到 Jenkins 平台上，只需要在源代码的目录底下新建一个 Jenkinsfile 的文件，把这段脚本放进去。然后将代码提交，Jenkins 就会根据 Jenkinsfile 中的配置自动去进行工作了。</p>
<blockquote>
<p>Jenkins 在 Windows 上和 Linux 上都是可以工作的，但是部署应用到 Windows 服务器上时，需要在 Windows 上配置 freesshd。</p>
</blockquote>
<p>[1] https://jenkins.io/doc/
[2] https://time.geekbang.org/column/104</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL如何做Join</title>
    <url>/2020/09/25/SQL%E5%A6%82%E4%BD%95%E5%81%9AJoin/</url>
    <content><![CDATA[<p>使用SQL 时，一个常见的场景就是多个表之间的关联查询。</p>
<p>本文总结一下联表 Join 的多种形式。</p>
<p>ANSI 的 SQL 标准中，SQL  join 共有 5 种，可以分为 <code>Inner Join</code>、<code>Left Join</code>、<code>Right Join</code>、 <code>Full join</code>、和 <code>Cross Join</code>，还有一种特殊的情况，与表自身 join 的 <code>Self join</code>。</p>
<p>在这篇文章中只考虑两张表的情况，多张表的情况同理。</p>
<p>两张表的结构（schema）如下：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_a (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">bigint</span> auto_increment,</span><br><span class="line">    <span class="keyword">key</span> <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_b (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">bigint</span> auto_increment,</span><br><span class="line">    <span class="keyword">key</span> <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>下文的 SQL 只是伪代码，在不同的数据库系统中不同的表示， join 关系使用文氏图表示。</p>
<h2>Cross Join</h2>
<p>两个表做笛卡尔积，基本不会在正式的业务中使用，主要用来测试服务的性能。</p>
<p><img src="0.png" alt=""></p>
<p>笛卡尔积就是把两个集合中的每一项两两组合，得到一个新的集合，在数据库中，就是把两张表中的数据两两组合。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a <span class="keyword">cross</span> <span class="keyword">join</span> t_b;</span><br></pre></td></tr></table></figure></p>
<p>Cross jojn 还有一种写法：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a, t_b;</span><br></pre></td></tr></table></figure></p>
<h2>Inner Join</h2>
<p>Innner join 表示只取两张表重合的部分，重合的部分也就是满足条件的记录。</p>
<p><img src="1.png" alt=""></p>
<p>Inner Join SQL 如下：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a a <span class="keyword">inner</span> <span class="keyword">join</span> t_b b <span class="keyword">on</span> a.key = b.key;</span><br></pre></td></tr></table></figure></p>
<p>对于 Inner join，也可以看作是从上面的 Cross Join 中找出那些满足条件的记录。</p>
<h2>Outer Join</h2>
<p>下面将要说到的这些 Join 方式都可以统称为 Outer Join，Outer Join 是相对于 Inner Join ，Outer Join 会保留表的全部记录，至于保留哪部分，就取决于具体的 Join 方式。</p>
<p>Left Join 就会保留左边表的全部记录，然后只取右边表的匹配记录。Right Join 就会保留右边表的全部记录，然后只取左边表的匹配记录。Full Join 则会把两个表的记录都取出来。</p>
<h3>Left Join</h3>
<p>Left join 也称之为 Left outer join。</p>
<p>表示以 a 表为主，会将 a 表的数据全部查询出来，同时只查出 b 表中与 a 表相交的那部分。</p>
<p><img src="2.png" alt=""></p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a a <span class="keyword">left</span> <span class="keyword">join</span> t_b b <span class="keyword">on</span> a.key = b.key;</span><br></pre></td></tr></table></figure></p>
<p>上面的 SQL 也可以写成：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a a <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> t_b b <span class="keyword">on</span> a.key = b.key;</span><br></pre></td></tr></table></figure></p>
<p>Left join 有一种变体，只获取那些不在表 b 中出现的结果，很简单，只需要做一个改动：</p>
<p><img src="3.png" alt=""></p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a a <span class="keyword">left</span> <span class="keyword">join</span> t_b b <span class="keyword">on</span> a.key = b.key <span class="keyword">where</span> b.key <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<h3>Right Join</h3>
<p>Right join 也称之为 Right outer join。</p>
<p>Right join 与 Left join 刚好相反，Right join 会以 b 表为主，会把 b 表中的数据都查询出来，同时只查询出 a 表中与表 b 相交的那部分。</p>
<p><img src="4.png" alt=""></p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a a <span class="keyword">right</span> <span class="keyword">join</span> t_b b <span class="keyword">on</span> a.key = b.key;</span><br></pre></td></tr></table></figure></p>
<p>上面的 SQL 也可以写成：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a a <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> t_b b <span class="keyword">on</span> a.key = b.key;</span><br></pre></td></tr></table></figure></p>
<p>Right join 同样也有一种变体，只获取那些不在 a 表中出现的结果：</p>
<p><img src="5.png" alt=""></p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a a <span class="keyword">right</span> <span class="keyword">join</span> t_b b <span class="keyword">on</span> a.key = b.key <span class="keyword">where</span> a.key <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<h3>Full Join</h3>
<p>Full join 也称之为 Full outer join。</p>
<p><img src="6.png" alt=""></p>
<p>Full join 比较特殊，会把两张表的中数据全部查询出来：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a a <span class="keyword">full</span> <span class="keyword">join</span> t_b b <span class="keyword">on</span> a.key = b.key;</span><br></pre></td></tr></table></figure></p>
<p>上面的 SQL 也可以写成：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a a <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span> t_b b <span class="keyword">on</span> a.key = b.key;</span><br></pre></td></tr></table></figure></p>
<p>Full join 也有一种变体，只获取 a 表与 b 表相交之外的区域，刚好与 inner join相反：</p>
<p><img src="7.png" alt=""></p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a a <span class="keyword">full</span> <span class="keyword">join</span> t_b b <span class="keyword">on</span> a.key = b.key <span class="keyword">where</span> a.key <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> b.key <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<h2>Self join</h2>
<p>在实际场景中，还有一种比较特殊的需求，比如我们需要查出一张表中某个字段相同的所有记录，这个时候就需要用到 Self join 了。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_a a1 <span class="keyword">inner</span> <span class="keyword">join</span> t_a a2 <span class="keyword">on</span> a1.key = a2.key;</span><br></pre></td></tr></table></figure></p>
<p>文 / Rayjun</p>
<h2>REF</h2>
<p>[1] <a href="https://en.wikipedia.org/wiki/Join_(SQL)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Join_(SQL)</a></p>
<p>[2] <a href="https://en.wikipedia.org/wiki/Venn_diagram" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Venn_diagram</a></p>
<p>[3] <a href="https://en.wikipedia.org/wiki/American_National_Standards_Institute" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/American_National_Standards_Institute</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis骚操作系列-如何让 Redis 的值过期</title>
    <url>/2020/01/11/Redis%E9%AA%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%97-%E5%A6%82%E4%BD%95%E8%AE%A9-Redis-%E7%9A%84%E5%80%BC%E8%BF%87%E6%9C%9F/</url>
    <content><![CDATA[<p>Redis 的过期时间设置是一个很常用的操作，毕竟 redis 不是用来做持久化存储的。</p>
<h2>问题</h2>
<p>Redis 自带的过期机制只能对 key 过期，而不能对具体的值过期，但是在某些特定的场景下需要对部分值过期。设想一个场景，有一篇文章，通过唯一的 id 进行标识。现在有个需求是要对每篇文章 15 分钟内的的阅读量进行统计，每分钟统计一次，然后查看文章阅读量的变化。所以数据形式大致如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">16</span> ...]</span><br></pre></td></tr></table></figure></p>
<p>但是我只需要 15 分钟内的数据，要不然内存可能就不够用了，这个时候利用 key 过期的方式就无法满足需求了，所以可以利用 Redis 的一些特性来完成这个需求。</p>
<h2>解决方法</h2>
<p>Redis 的有序集合可以存储一系列有序的值，对于值可以指定 score，然后根据 score 来进行排序:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZAAD key score value</span><br></pre></td></tr></table></figure></p>
<p>然后可以通过 ZRANGEBYSCORE 来获取一定范围内 score 所对应的 value。</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZRANGEBYSCORE key score1 score2</span><br></pre></td></tr></table></figure></p>
<p>可以利用上面的这个特性来完成需求。</p>
<p>可以把统计的文章的阅读数量通过如下的格式添加进行 Redis，以文章的 id 作为 key， 当前的时间戳作为 score，当前文章的阅读数作为 value。像下面这样：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">   文章id   时间戳    阅读数 </span></span><br><span class="line">ZADD id    1577591750 54</span><br></pre></td></tr></table></figure></p>
<p>然后要获取 15 分钟内的阅读数量统计，假设当前的时间戳是 now:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZRANGEBYSCORE id now - 15 * 60 now</span><br></pre></td></tr></table></figure>
上面的操作就可以达到目的了，但是还是有点不完美，因为随着时间的推移，这个有序列表会越来越长，最后内存还是会被搞爆掉。所以在每次获取 15 分钟内的值时，还要把超过 15 分钟的值给删掉，这样就和过期的效果一样了：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZRANGEBYSCORE id 0 now - 15 * 60</span><br></pre></td></tr></table></figure></p>
<p>现在看起来比较完美了，即能完成需求，又能保住内存。但是还是存在一个小问题，假设这篇文章不再有人访问了，那么这个值就会永远停在内存中（假设不宕机）。所以保险一点，可以给这个 key 也设置一个过期的时间：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 24 小时后整个 key 过期，内存回收</span></span><br><span class="line">EXPIRE key 24* 60 * 60</span><br></pre></td></tr></table></figure></p>
<p>现在果真完美了，即满足了要求，也保全了内存。不是我啰嗦，但是这个从功能的角度还是有点小问题，因为有序集合中存储的值只能是唯一的，要是两次统计的阅读量一样，就会有点小问题。这个也容易解决，把每个 value 设计成如下的形式就可以了:</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    value: numbers,</span><br><span class="line">    timestamp: 1577591750</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，每个 value 都是独一无二的了，这样真的是完美了。示意图如下：</p>
<p><img src="redis-zset.png" alt=""></p>
<p>只有 黄色框内的值才是有效的，这个框就表示15分钟的有效时间。框外的就表示过期的 value。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 简明教程</title>
    <url>/2019/05/12/Redis-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>Redis 是一个非常快的非关系型的数据库，通过 key-value 的形式保存数据。key 总是字符串，而 value 支持 5 种类型（字符串、列表、集合、哈希表、有序集合），单个 value 的大小不超过 512 M。Redis 的键值对是存储在内存中的，但是也能持久化到硬盘中。</p>
<h3>5 种数据类型和基本操作</h3>
<h4>字符串</h4>
<p>字符串中可以存储的内容有字符串，数值等，针对不同的值，可以进行不同的操作，以下是字符串的值常用的操作。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>通过给定的 key 获取 value</td>
</tr>
<tr>
<td>SET</td>
<td>通过给定的 key 存储 value</td>
</tr>
<tr>
<td>DEL</td>
<td>通过给定的 key 删除 value</td>
</tr>
<tr>
<td>INCR</td>
<td>通过给定的 key 给 value 增加 1（value 必须为整数）</td>
</tr>
<tr>
<td>DECR</td>
<td>通过给定的 key 给 value 减 1（value 必须为整数）</td>
</tr>
<tr>
<td>INCRBY</td>
<td>通过给定的 key 给 value 增加特定的值（value 必须为整数）</td>
</tr>
<tr>
<td>DECRBY</td>
<td>通过给定的 key 给 value 减少特定的值（value 必须为整数）</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>通过给定的 key 给 value 减少特定的值（value 必须为浮点数）</td>
</tr>
<tr>
<td>APPEND</td>
<td>通过给定的 key 在 value 上追加内容</td>
</tr>
</tbody>
</table>
<blockquote>
<p>除了上面那些命令外，还有其他的比如获取字符串的部分值，修改字符串的部分值等操作。</p>
</blockquote>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; <span class="built_in">set</span> hello world</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; get hello</span></span><br><span class="line">"world"</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; del hello</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; get hello</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></p>
<h4>列表</h4>
<p>列表实际上是一个双向链表，在插入数据的时候可以选择从头部插入，也可以选择从尾部插入。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPUSH</td>
<td>从列表的头部插入数据</td>
</tr>
<tr>
<td>RPUSH</td>
<td>从列表的尾部插入数据</td>
</tr>
<tr>
<td>LPOP</td>
<td>从列表的头部取出一个数据</td>
</tr>
<tr>
<td>RPOP</td>
<td>从列表的尾部取出一个数据</td>
</tr>
<tr>
<td>LRANGE</td>
<td>从列表种查询某个范围的数据</td>
</tr>
<tr>
<td>LINDEX</td>
<td>从列表种查询给定位置的数据</td>
</tr>
<tr>
<td>LTRIM</td>
<td>从列表种裁剪元素，只保留区间内的数据</td>
</tr>
</tbody>
</table>
<blockquote>
<p>列表还支持不同的列表之间进行数据的转移</p>
</blockquote>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; rpush list-key item</span></span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; lpush list-key item</span></span><br><span class="line">(integer) 6</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; lrange list-key 0 -1</span></span><br><span class="line">1) "item"</span><br><span class="line">2) "item"</span><br><span class="line">3) "item2"</span><br><span class="line">4) "item"</span><br><span class="line">5) "item"</span><br><span class="line">6) "item"</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; lindex list-key 1</span></span><br><span class="line">"item"</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; lpop list-key</span></span><br><span class="line">"item"</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; rpop list-key</span></span><br><span class="line">"item"</span><br></pre></td></tr></table></figure></p>
<h4>集合</h4>
<p>集合中存储的都是不重复的值，但是所有的值都不是有序的。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD</td>
<td>在集合中添加一项</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td>返回集合中所有的项</td>
</tr>
<tr>
<td>SISMEMBER</td>
<td>检查某一项是否在集合中</td>
</tr>
<tr>
<td>SREM</td>
<td>如果某项在集合中存在，就删除</td>
</tr>
<tr>
<td>SCARD</td>
<td>计算集合中数据的个数</td>
</tr>
<tr>
<td>SRANDMEMBER</td>
<td>从集合中随机取出几个数据</td>
</tr>
<tr>
<td>SPOP</td>
<td>从集合中随机取出一个数据</td>
</tr>
<tr>
<td>SMOVE</td>
<td>从集合中取出一个特定的数据并且转移到另一个集合中</td>
</tr>
</tbody>
</table>
<blockquote>
<p>集合中还支持集合的各种交并集的运算</p>
</blockquote>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; sadd <span class="built_in">set</span>-key item3</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; smembers <span class="built_in">set</span>-key</span></span><br><span class="line">1) "item1"</span><br><span class="line">2) "item3"</span><br><span class="line">3) "item"</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; sismember <span class="built_in">set</span>-key item3</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; srem <span class="built_in">set</span>-key item1</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<h4>哈希</h4>
<p>哈希对象的每个 key 都是不重复而且无序的。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET</td>
<td>在 hash 种添加一个键值对</td>
</tr>
<tr>
<td>HGET</td>
<td>通过 key 在 hash 中获取一个键值对</td>
</tr>
<tr>
<td>HGETALL</td>
<td>查询 hash 中所有的键值对</td>
</tr>
<tr>
<td>HDEL</td>
<td>通过 key 在 hash 中删除一个键值对</td>
</tr>
<tr>
<td>HLEN</td>
<td>返回 hash 中键值对的个数</td>
</tr>
<tr>
<td>HMGET</td>
<td>通过多个 key 在 hash 中获取值</td>
</tr>
<tr>
<td>HMSET</td>
<td>批量在 hash 中添加键值对</td>
</tr>
<tr>
<td>HEXISTS</td>
<td>判断 hash 中某个键值对是否存在</td>
</tr>
<tr>
<td>HKEYS</td>
<td>返回 hash 中所有的 key</td>
</tr>
<tr>
<td>HVALS</td>
<td>返回 hash 中所有的 value</td>
</tr>
<tr>
<td>HINCRBY</td>
<td>为 hash 中键值对的值添加特定的整数（value 必须为整数）</td>
</tr>
<tr>
<td>HINCRBYFLOAT</td>
<td>为 hash 中键值对的值添加特定的浮点数 （value 必须为浮点数）</td>
</tr>
</tbody>
</table>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; hset <span class="built_in">hash</span>-key sub-key3 value6</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; hgetall <span class="built_in">hash</span>-key</span></span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value6"</span><br><span class="line">3) "sub-key3"</span><br><span class="line">4) "value6"</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; hget <span class="built_in">hash</span>-key sub-key1</span></span><br><span class="line">"value6"</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; hdel <span class="built_in">hash</span>-key subkey1</span></span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></p>
<h4>有序集合</h4>
<p>有序集合类似哈希，存储的是键值对，但是有序集合是按照 value 的顺序排列的，value 必须是浮点数。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD</td>
<td>在有序集合中添加数据</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>根据范围查询数据</td>
</tr>
<tr>
<td>ZRANGEBYSCORE</td>
<td>根据 value 的范围查询数据</td>
</tr>
<tr>
<td>ZREM</td>
<td>从有序集合中删除数据</td>
</tr>
<tr>
<td>ZCARD</td>
<td>获取集合中数据的条数</td>
</tr>
<tr>
<td>ZINCRBY</td>
<td>给某个数据添加特定的值</td>
</tr>
<tr>
<td>ZCOUNT</td>
<td>获取给定的范围内数据的个数</td>
</tr>
<tr>
<td>ZSCORE</td>
<td>返回某个数据的数值</td>
</tr>
<tr>
<td>ZRANK</td>
<td>返回某个数据的排名</td>
</tr>
</tbody>
</table>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; zadd zset-key 666 memeber4</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores</span></span><br><span class="line"> 1) "member4"</span><br><span class="line"> 2) "123"</span><br><span class="line"> 3) "member2"</span><br><span class="line"> 4) "635"</span><br><span class="line"> 5) "memeber4"</span><br><span class="line"> 6) "666"</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; zrangebyscore zset-key 0 800 withscores</span></span><br><span class="line">1) "member4"</span><br><span class="line">2) "123"</span><br><span class="line">3) "member2"</span><br><span class="line">4) "635"</span><br><span class="line">5) "memeber4"</span><br><span class="line">6) "666"</span><br><span class="line"><span class="meta">$</span><span class="bash"> 127.0.0.1:6379&gt; zrem zset-key member2</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<p>Redis 中完整的命令可以在<a href="https://redis.io/commands" target="_blank" rel="noopener">这里</a>查找到。</p>
<h3>Redis 中的数据结构</h3>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>用途</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单动态字符串</td>
<td>Redis 默认字符串的表示</td>
<td></td>
</tr>
<tr>
<td>双向链表</td>
<td>列表键、发布与订阅、慢查询、监视器</td>
<td></td>
</tr>
<tr>
<td>字典</td>
<td>数据库</td>
<td>数据库的增删改查也是在字典的基础上</td>
</tr>
<tr>
<td>跳表</td>
<td>有序集合键</td>
<td></td>
</tr>
<tr>
<td>整数集合</td>
<td>集合键</td>
<td></td>
</tr>
<tr>
<td>压缩列表</td>
<td>列表键、哈希键</td>
<td></td>
</tr>
</tbody>
</table>
<p>上面的这些数据结构在 Redis 种都有用到，但是 Redis 并不是直接使用这些数据结构，而是在这些数据结构的基础上创建了一个<strong>对象系统</strong>、这个系统中有<strong>字符串对象</strong>、<strong>列表对象</strong>、<strong>哈希对象</strong>、<strong>集合对象</strong>以及<strong>有序集合对象</strong>这五种对象。每个对象都至少用到了一种表中的数据结构。</p>
<h3>Redis 数据持久化</h3>
<p>Redis 数据是基于内存进行存储的，为了保证数据在 Redis 服务退出后还可以存在，就得使用持久化的方法就数据保存下来。</p>
<p>Redis 提供了两种持久化的方法，一种是 RDB，一种是 AOF。</p>
<h4>RDB 持久化</h4>
<p>RDB持久化锁生成的 RDB 文件实际上是一个经过了压缩的二进制文件。通过该文件可以还原生成 RDB 文件时候的数据库状态。</p>
<p>RDB 文件的生成有两个命令，一个是 <strong>SAVE</strong>，一个是 <strong>BGSAVE</strong>。</p>
<ul>
<li>SAVE：阻塞 Redis 服务器进程，直到 RDB 文件创建完成</li>
<li>BGSAVE: 不会阻塞 Redis 服务器进程，由子进程去创建 RDB 文件</li>
</ul>
<p>可以通过设置 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE 命令:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 900 秒内，对数据库至少进行了一次修改就执行 BGSAVE</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> save 900 1 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 300 秒内，对数据库至少进行了 10 次修改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> save 300 10</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 60 秒内，对数据库至少进行了 10000 次修改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> save 60 10000</span></span><br></pre></td></tr></table></figure></p>
<h4>AOF 持久化</h4>
<p>与 RDB 将整个 Redis 种的数据就行保存来记录数据库状态不同，AOF 持久化时通过保存 Redis 服务器锁执行的<strong>写</strong>命令来保存数据库。</p>
<p>AOF 执行的策略有三种:</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>always</td>
<td>每个写命令都同步</td>
</tr>
<tr>
<td>everysec</td>
<td>每秒同步一次</td>
</tr>
<tr>
<td>no</td>
<td>让操作系统来决定何时同步</td>
</tr>
</tbody>
</table>
<h3>Redis 其他特性</h3>
<p>Redis 除了支持基本的存储之外，也提供了很多的工具，帮助应对更加复杂的业务场景。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>使用方式</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>发布与订阅</td>
<td>使用 PUBLISH 发布频道、SUBSCRIBE 订阅、UNSUBSCRIBE取消订阅、PSUBSCRIBE 支持正则模式订阅</td>
<td></td>
</tr>
<tr>
<td>事务</td>
<td>如果一次想保证原子性支持多个写命令，就需要使用事务，事务通过 MULTI、EXEC、WATCH 命令来实现事务</td>
<td></td>
</tr>
<tr>
<td>排序</td>
<td>通过 sort 命令可以对列表键、集合键或者有序集合键进行排序</td>
<td></td>
</tr>
<tr>
<td>慢查询日志</td>
<td>用于记录执行时间超过给定时长的命令请求、可以通过这个来监视和优化查询速度</td>
<td></td>
</tr>
<tr>
<td>监视器</td>
<td>通过 monitor 命令，客户端可以讲自身编程一个监视器，实时的接收并且打印服务器当前处理的命令</td>
<td></td>
</tr>
</tbody>
</table>
<h3>Redis 分布式和高可用方案</h3>
<p>Redis 对于分布式环境下的部署有着成熟的解决方案，常用的方式如下:</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>部署方式</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>复制</td>
<td>通过 slaveof 去配置主从服务器</td>
<td>主从服务器上的数据一致</td>
</tr>
<tr>
<td>Sentinel</td>
<td>高可用的解决方案，实际上是在 复制方案的上层添加了一个 sentilnel 系统，来监视所有 redis 服务器，一旦主服务器宕机之后，会把其中一台从服务器选择为主服务器</td>
<td></td>
</tr>
<tr>
<td>集群</td>
<td>Redis 分布式数据库的方案，通过分片（sharding）来进行数据共享、并提供复制和故障转移功能</td>
<td></td>
</tr>
</tbody>
</table>
<p>（完）</p>
<ol>
<li>Redis 设计与实现</li>
<li>Redis In Action</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 简明教程</title>
    <url>/2019/04/14/SQL-%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>SQL(Structed Query Language)是结构化查询语句，在如今各类系统中有广泛的应用。在多次 <strong>No SQL</strong> 浪潮中依然生存下来，如今依然有着强大的生命力。是值得花时间投资的学习的一门技能。</p>
<blockquote>
<p>SQL 是一种标准，由美国国家标准化组织（ANSI）制定</p>
</blockquote>
<p>RDBMS 是关系型数据库管理系统。  比如 SQL Server、MySQL、Oracle 等。</p>
<blockquote>
<p>在不同的 RDBMS 中都有自己的 SQL 扩展。</p>
</blockquote>
<p>SQL 可以分成 <strong>DML(数据操作语言)</strong> 、<strong>DDL(数据定义语言)</strong> 以及<strong>DCL(数据控制语言)</strong>。</p>
<p>最简单区分这三者的方法就是：</p>
<ul>
<li>操作表中数据的操作就是 DML</li>
<li>操作数据库表、视图等操作就是 DDL</li>
<li>操作数据库及数据库权限的就是 DCL</li>
</ul>
<blockquote>
<p>本文实践的环境是 MySQL</p>
</blockquote>
<h3>DML 基础</h3>
<blockquote>
<p>c 代表列名，v 代表值</p>
</blockquote>
<p><strong>SELECT</strong></p>
<p>select 用于从数据库中查询数据。
有两种使用方式，一种是将表中的<strong>列</strong>全部查询出来，一种只查询出来指定的列。
查询全部列：
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure></p>
<p>查询指定列：
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c1, c2, c3 <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure></p>
<p>在返回的数据中，有些列的值是重复的，可以使用 <strong>distinct</strong> 来返回一列的唯一值：
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> c2 <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure></p>
<p>如果需要在查询的的过程中加入条件，那就需要使用 <strong>where</strong> 来指定查询条件:
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> c1 = v1;</span><br></pre></td></tr></table></figure>
where 支持的运算符如下：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在某个范围内</td>
</tr>
<tr>
<td>LIKE</td>
<td>模糊查询</td>
</tr>
</tbody>
</table>
<p>假如说不止一个条件，可以使用 <strong>AND</strong> 和 <strong>OR</strong> 来连接多个 条件，AND 和 OR 可以组合使用。
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> c1 = v1 <span class="keyword">and</span>  c2 = v2 <span class="keyword">or</span>  c3 &lt;&gt; v3;</span><br></pre></td></tr></table></figure></p>
<p>使用 select 查询出来的结果的顺序可能不是想要的，那么就可以使用 <strong>ORDER BY</strong> 来对结果进行排序，order by 默认使用的是升序排序。</p>
<p>使用 <strong>desc</strong> 来进行降序排序：
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">form</span> table_name <span class="keyword">where</span> c1 = v1 <span class="keyword">order</span> <span class="keyword">by</span> c1 <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
对多个字段使用 order by：
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> c1 = v1 <span class="keyword">order</span> <span class="keyword">by</span> c1, c2;</span><br></pre></td></tr></table></figure>
对不同的字段使用不同的排序规则:
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> c1 = v1 <span class="keyword">order</span> <span class="keyword">by</span> c1 <span class="keyword">asc</span>, c2 <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>INSERT INTO</strong></p>
<p>insert into 用于向数据库中插入数据。
两种使用方式，一种是直接插入表中，不指定列，这样需要为每一列都填充数据，否则会报错:
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name <span class="keyword">values</span> (v1, v2, v3, v4);</span><br></pre></td></tr></table></figure></p>
<p>也可以指定列:
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name (c2, c3, c4) <span class="keyword">values</span> (v2, v3, v4);</span><br></pre></td></tr></table></figure></p>
<p><strong>UPDATE</strong></p>
<p>update 用于更新数据，在更新数据的时候也可以使用 where 来限定某些条件的数据可以被更新。
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> c1 = v1 <span class="keyword">where</span> c1 = v;</span><br></pre></td></tr></table></figure></p>
<p><strong>DELETE</strong></p>
<p>delete 用于删除表中的数据，可以使用 where 删除限定的数据，也可以删除全部数据。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> c1 = v1;</span><br></pre></td></tr></table></figure></p>
<p>删除全部数据：
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></p>
<p><strong>SELECT TOP</strong></p>
<p>用于返回指定的记录的条数：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">2</span> * <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></p>
<p>但是这个特性在有的数据库中不支持，但是有相应的替代方案可以选择，在 MySQL 中可以这样实现：
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">limit</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p><strong>LIKE</strong>
like 用于 where 子句中进行模糊查询。</p>
<p>表示查询 c1 列以 bar 开头的记录。
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> c1 <span class="keyword">like</span> <span class="string">'bar%'</span>;</span><br></pre></td></tr></table></figure>
like 支持如下的通配符:</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>%</td>
<td>替代一个或者多个字符</td>
</tr>
<tr>
<td>_</td>
<td>仅替代一个字符</td>
</tr>
<tr>
<td>[chars]</td>
<td>字符列中的任何单一字符（MySQL 不支持）</td>
</tr>
<tr>
<td>[^chars] 或者 [!chars]</td>
<td>不在字符列中的任何单一字符（MySQL不支持）</td>
</tr>
</tbody>
</table>
<p>如果想使用 like 来排除条件，可以使用 <strong>not like</strong>。</p>
<blockquote>
<p>在 MySQL 中，还支持正则表达式，可以使用 <strong>REGEXP(RLIKE)</strong> 和 <strong>NOT REGEXP(NOT RLIKE)</strong></p>
</blockquote>
<p><strong>IN</strong>
in 可以指定 where 子句中在固定范围的内进行查询:</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> c1 <span class="keyword">in</span> (v1, v2, v3);</span><br></pre></td></tr></table></figure></p>
<p><strong>BETWEEN AND</strong></p>
<p>between and 可以在 where 子句中指定查询的范围。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> c1 <span class="keyword">between</span> v1 <span class="keyword">and</span> v2;</span><br></pre></td></tr></table></figure>
between and 同样可以使用 not 来表示查询不在这个范围内的数据，用法如下：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> c1 <span class="keyword">not</span> <span class="keyword">between</span> v1 <span class="keyword">and</span> v2;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>between and 在不同的数据库中有不同的表现</p>
</blockquote>
<p><strong>ALIAS</strong></p>
<p>在 SQL 进行查询的过程中，可以为<strong>列名</strong>和<strong>表名</strong>都增加别名。</p>
<p>为列增加别名：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c1 <span class="keyword">as</span> c1_alias <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>
为表增加别名:
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">as</span> table_name_alias;</span><br></pre></td></tr></table></figure></p>
<p><strong>多表查询</strong></p>
<p>SQL 支持同时查询多个表。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.c1,b.c2 <span class="keyword">from</span> table1 <span class="keyword">as</span> a, table2 <span class="keyword">as</span> b <span class="keyword">where</span> a.c1 = b.c2;</span><br></pre></td></tr></table></figure></p>
<p><strong>JOIN</strong></p>
<p>SQL 在查询多个表中的数据时，除了可以使用多表查询，还可以使用 join 来进行查询。</p>
<p>上面多表查询的 SQL 与这条 SQL 是等价的：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.c1, b.c2  <span class="keyword">from</span> table1 <span class="keyword">as</span> a <span class="keyword">inner</span> <span class="keyword">join</span> table2 <span class="keyword">as</span> b <span class="keyword">on</span> a.c1 = b.c2;</span><br></pre></td></tr></table></figure>
join 除了有 inner join 之外（inner join 与 join 等价），在上面的查询中，table1 称之为左表，table2 称之为右表。join 比多表关联查询功能强大的地方在于 join 可以根据需要，返回不同的结果。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>JOIN (INNER JOIN)</td>
<td>只返回表中匹配的记录</td>
</tr>
<tr>
<td>LEFT JOIN (LEFT OUTER JOIN)</td>
<td>即使右表中没有匹配的记录，也会将左表的所有记录返回</td>
</tr>
<tr>
<td>RIGHT JOIN (RIGHT OUTER JOIN)</td>
<td>即使左表中没有记录，也会将右表中所有的记录返回</td>
</tr>
<tr>
<td>FULL JOIN (FULL OUTER JOIN)</td>
<td>将两个表中所有的记录都返回</td>
</tr>
</tbody>
</table>
<p><strong>UNION</strong>
union 用于合并多个 select 的查询结果。使用 union 需要满足以下几个条件:</p>
<ul>
<li>所有的 select 语句必须要有相同数量的列</li>
<li>每列的数据类型必须一致</li>
<li>所有列的排列顺序都需要相同</li>
</ul>
<blockquote>
<p>列名不需要一致</p>
</blockquote>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c1, c2 <span class="keyword">from</span> table1 </span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> c3,c4 <span class="keyword">from</span> table2;</span><br></pre></td></tr></table></figure>
直接使用 union 返回的结果中不包含重复列，如果需要返回全部的结果，可以使用 <strong>UNION ALL</strong>。</p>
<h3>DDL 基础</h3>
<p><strong>SELECT INTO</strong></p>
<p>select into 可以用来创建表的备份，可以配合 where 、JOIN 等语句一起使用。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">into</span> new_table <span class="keyword">from</span> lod_table <span class="keyword">where</span> c1 = v1;</span><br></pre></td></tr></table></figure>
select into 直接使用是在同一个数据库操作，也可以通过 in 来实现跨数据库操作:
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">into</span> new_table <span class="keyword">in</span> new_datebase <span class="keyword">from</span> old_table <span class="keyword">where</span> c1 = v1;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>MySQL 不支持 SELECT INTO</p>
</blockquote>
<p><strong>CREATE DATABASE</strong></p>
<p>create database 用于创建数据库，使用起来很简单。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> database_name;</span><br></pre></td></tr></table></figure></p>
<p>删除数据库:
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> database_name;</span><br></pre></td></tr></table></figure></p>
<p><strong>CREATE TABLE</strong></p>
<p>create table 用于创建数据库表。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name &#123;</span><br><span class="line">    c1 datatype,</span><br><span class="line">    c2 datatype,</span><br><span class="line">    c3 datatype</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中 datatype 是 SQL 支持的数据类型。</p>
<p>上面的 SQL 展示了如何创建一个基本的数据库表，但是实际使用的过程中，创建数据表的语句不会这么简单，通常来说会给数据库中的列加上各种各样的<strong>约束</strong>来满足需要，下表是 SQL 支持的几种约束。</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>NOT NULL</td>
<td>列不能为 NULL，主键通常不能为 NULL</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>列的值在该表中唯一</td>
</tr>
<tr>
<td>PRIMARY KEY</td>
<td>数据的主键，在该表中也是唯一</td>
</tr>
<tr>
<td>FOREIGN KEY</td>
<td>数据的外键，通常是其他表中数据的主键</td>
</tr>
<tr>
<td>CHECK</td>
<td>对某列数据的值加以限制</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>给某列数据设定默认值</td>
</tr>
<tr>
<td>AUTO_INCREMENT</td>
<td>加上了该约束的列的值会自增</td>
</tr>
</tbody>
</table>
<p>not null 就是标识一个字段不能为 null，通常在建表时指定:</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name &#123;</span><br><span class="line">    c1 datatype <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    c2 datatype,</span><br><span class="line">    c3 datatype</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
unique 指定每条记录的唯一标识，每个表可以用多个 unique 标识。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name &#123;</span><br><span class="line">    c1 datatype <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    c2 datatype,</span><br><span class="line">    c3 datatype,</span><br><span class="line">    <span class="keyword">unique</span>(c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
也可以把多个字段组合成为唯一标识:
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name &#123;</span><br><span class="line">    c1 datatype <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    c2 datatype,</span><br><span class="line">    c3 datatype,</span><br><span class="line">    <span class="keyword">constraint</span> uc_c1_c2 <span class="keyword">unique</span> (c1, c2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于已经创建的表添加 unique 约束以及删除现有的约束可以使用 <strong>alter table</strong> 来进行修改。</p>
<p>删除表：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure>
清除表中数据但是不删除表:</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure></p>
<p><strong>ALTER TBALE</strong></p>
<p>使用 alter table 可以增加和删除表的字段，也可以修改字段的类型。</p>
<p>增加字段：
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> c1 datatype;</span><br></pre></td></tr></table></figure>
删除字段（有些数据库不允许这个操作）:
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> <span class="keyword">column</span> c1;</span><br></pre></td></tr></table></figure>
修改表中字段的数据类型:
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">column</span> c1 datatype;</span><br></pre></td></tr></table></figure></p>
<p><strong>INDEX</strong></p>
<p>在表中可以创建 index，以便更快更高效的查询数据。但是凡事都有代价，增加了索引的表在更新数据的时候会更慢。所以只会在经常被搜索的列和表上创建索引。</p>
<p>创建一个索引，与 unique 一样，可以为一个字段创建一个索引，也可以为多个字段创建一个索引:</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name (c1);</span><br></pre></td></tr></table></figure>
上面创建的这个索引的值是可以重复的，也可以创建唯一索引，唯一索引的值是不能重复的:</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name (c1);</span><br></pre></td></tr></table></figure></p>
<p>删除索引（MySQL）:</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> <span class="keyword">index</span> index_name;</span><br></pre></td></tr></table></figure></p>
<p><strong>VIEW</strong></p>
<p>view 是基于 SQL 语句的结果集的可视化的表，也就是说，视图是一个 SQL 查询结果的集合，视图的结构和表一样，但是其中的字段数据一般来自于多个表。</p>
<p>创建一个视图:</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span>  a.c1, b.c2 <span class="keyword">from</span> table1 <span class="keyword">as</span> a, table2 <span class="keyword">as</span> b </span><br><span class="line"><span class="keyword">where</span> a.c1 = b.c2;</span><br></pre></td></tr></table></figure></p>
<p>然后可以在这个视图中进行查询:</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> view_name;</span><br></pre></td></tr></table></figure></p>
<p>删除视图:</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> view_name</span><br></pre></td></tr></table></figure></p>
<h3>DCL 基础</h3>
<p>DCL 用于控制数据库中的授权和事务。</p>
<p><strong>GRANT</strong></p>
<p>给 user1 在 table1 上赋予 select 和 update 的权限。
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> privilege [<span class="keyword">select</span>, <span class="keyword">update</span>] <span class="keyword">on</span> table1 [user1]</span><br></pre></td></tr></table></figure></p>
<p><strong>TRANSACTION</strong></p>
<p>事务处理严格来说是 RDBMS 的功能，事务用来确保一组 SQL 要么全部执行，要么全部不执行。</p>
<p>主要就是利用 <strong>COMMIT</strong> 来提交一个事务，利用 <strong>ROLLBACK</strong> 来回滚一个事务。</p>
<h3>SQL 函数</h3>
<p>除了基本的 SQL 语法外，SQL 中还有很重要的一个部分就是<strong>函数</strong>。</p>
<p>函数可以分成两类：</p>
<ul>
<li><strong>聚合查询函数</strong>：操作一系列的值，然后返回单一的值</li>
<li><strong>标量查询函数</strong>：操作一个单一的值，并且返回一个单独的值</li>
</ul>
<p>函数的使用方式：
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">function</span>(c1) <span class="keyword">form</span> table1;</span><br></pre></td></tr></table></figure></p>
<p>基本上所有的函数都是这样使用的，但是有一点需要注意的是，如果聚合查询函数在和普通字段一起查询时，一定要加上 <strong>group by 关键字</strong>。
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c1 , <span class="keyword">max</span>(c2) <span class="keyword">from</span> table1 <span class="keyword">group</span> <span class="keyword">by</span> c1;</span><br></pre></td></tr></table></figure></p>
<p>如果有时候我们需要把聚合查询函数作为一个条件来进行查询，但是聚合函数是不能和 where 一起配合使用的，这个时候就需要使用 having。
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c1, <span class="keyword">max</span>(c2) <span class="keyword">from</span> table1 <span class="keyword">having</span> <span class="keyword">max</span>(c2) &gt; v2;</span><br></pre></td></tr></table></figure></p>
<p>也可以在函数查询上使用别名:
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> c1, <span class="keyword">max</span>(c2) <span class="keyword">as</span> m1 <span class="keyword">from</span> table1 <span class="keyword">where</span> c1 &gt; v1;</span><br></pre></td></tr></table></figure></p>
<p>常见聚合函数:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>avg</td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td>count</td>
<td>返回某列的行数</td>
</tr>
<tr>
<td>max</td>
<td>返回某列的最高值</td>
</tr>
<tr>
<td>min</td>
<td>返回某列的最小值</td>
</tr>
</tbody>
</table>
<p>常见的标量函数:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>format(v, format)</td>
<td>格式化某列的显示方式</td>
</tr>
<tr>
<td>now</td>
<td>返回当前的系统时间</td>
</tr>
<tr>
<td>len</td>
<td>返回某列文本的长度</td>
</tr>
</tbody>
</table>
<h3>SQL 中的数据类型</h3>
<p>SQL 是一种编程语言，自然也有其支持的数据类型。在不同的数据库中，数据类型的差异很大。在这里使用 MySQL 的数据类型为例来说明 SQL 中的数据类型。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR(size)</td>
<td>保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。</td>
</tr>
<tr>
<td>VARCHAR(size)</td>
<td>保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>存放最大长度为 255 个字符的字符串。</td>
</tr>
<tr>
<td>TEXT</td>
<td>存放最大长度为 65,535 个字符的字符串。</td>
</tr>
<tr>
<td>BLOB</td>
<td>用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>存放最大长度为 16,777,215 个字符的字符串。</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>存放最大长度为 4,294,967,295 个字符的字符串。</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。</td>
</tr>
<tr>
<td>ENUM(x,y,z,etc.)</td>
<td>允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照你输入的顺序存储的。可以按照此格式输入可能的值：ENUM('X','Y','Z')</td>
</tr>
<tr>
<td>SET</td>
<td>与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。</td>
</tr>
<tr>
<td>TINYINT(size)</td>
<td>-128 到 127 常规。0 到 255 无符号整数。在括号中规定最大位数。</td>
</tr>
<tr>
<td>SMALLINT(size)</td>
<td>-32768 到 32767 常规。0 到 65535 无符号整数。在括号中规定最大位数。</td>
</tr>
<tr>
<td>MEDIUMINT(size)</td>
<td>-8388608 到 8388607 普通。0 to 16777215 无符号整数。在括号中规定最大位数。</td>
</tr>
<tr>
<td>INT(size)</td>
<td>-2147483648 到 2147483647 常规。0 到 4294967295 无符号整数。在括号中规定最大位数。</td>
</tr>
<tr>
<td>BIGINT(size)</td>
<td>-9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号整数。在括号中规定最大位数。</td>
</tr>
<tr>
<td>FLOAT(size,d)</td>
<td>带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td>DOUBLE(size,d)</td>
<td>带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td>DECIMAL(size,d)</td>
<td>作为字符串存储的 DOUBLE 类型，允许固定的小数点。</td>
</tr>
<tr>
<td>DATE()</td>
<td>日期。格式：YYYY-MM-DD注释：支持的范围是从 '1000-01-01' 到 '9999-12-31'</td>
</tr>
<tr>
<td>DATETIME()</td>
<td>日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'</td>
</tr>
<tr>
<td>TIMESTAMP()</td>
<td>时间戳。TIMESTAMP 值使用 Unix 纪元('1970-01-01 00:00:00' UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 '1970-01-01 00:00:01' UTC 到 '2038-01-09 03:14:07' UTC</td>
</tr>
<tr>
<td>TIME()</td>
<td>时间。格式：HH:MM:SS 注释：支持的范围是从 '-838:59:59' 到 '838:59:59'</td>
</tr>
<tr>
<td>YEAR()</td>
<td>2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。</td>
</tr>
</tbody>
</table>
<p>（完）</p>
<ol>
<li>http://www.w3school.com.cn/sql</li>
<li>MySQL必知必会（第四版）</li>
<li>高性能MySQL（第三版）</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的线程池与任务调度</title>
    <url>/2020/11/29/Spring%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<p>线程池已经成为 Java 开发中必不可少的一个组件了，在使用 Spring 时，不需要自己重头去使用线程池。</p>
<p>Spring 已经提供了非常完备的封装，可以直接使用 Spring 提供的接口。</p>
<p>本文基于 Spring5.3 和 OpenJDK11</p>
<h2>1. Spring 中的任务</h2>
<p>Spring 中对与任务的执行提供了两种抽象， <code>TaskExecutor</code> 和 <code>TaskScheduler</code>，分别表示执行异步任务和定时任务。</p>
<p><code>Executor</code> 在 JDK 中是线程池的名称。一个 executor 用来表示执行任务的线程池，其中最少会有一个线程，每个线程都可以用来执行同步或者异步任务。</p>
<p><code>Scheduler</code> 表示的是定时任务，定时任务的触发，支持 JDK 中的 <code>Timer</code> 和 <code>Quartz Scheduler</code> 。</p>
<h2>2. TaskExecutor</h2>
<p>TaskExecutor 接口继承了 JDK 中的 Executor。在 JDK 中，ThreadPoolExecutor 继承了 Executor，也是一个很常用的接口。</p>
<p>Spring 对这些实现屏蔽了细节，无论是开发 Java EE 应用还是 Java SE 应用，都可以直接使用 TaskExecutor。</p>
<h3>TaskExecutor 的实现</h3>
<p>Spring 中已经实现了多种类型的 TaskExecutor，在绝大多数情况下，不需要自己去实现。</p>
<ul>
<li>SyncTaskExecutor：用来执行非异步的任务，通常用于不需要多线程的场景，实际用的比较少，通常用来执行测试用例</li>
<li>SimpleAsyncTaskExecutor：这个实现不会重用任何的线程，每当有新任务的时候，都是重新创建一个线程</li>
<li>ConcurrentTaskExecutor：这个实现是对 Executor 的适配，可以配置 Executor 的全部参数，但是一般很少使用，除非需要完全自主配置线程池</li>
<li>ThreadPoolTaskExecutor：这个实现最常用，其中封装了 ThreadPoolExecutor，如果还需要使用 Executor 的其他实现，可以使用 ConcurrentTaskExecutor</li>
<li>WorkManagerTaskExecutor：这个用的就更少了，这个实现封装了 WebLogic 的 API，以便在 WebLogic 中间件上运行 Spring 程序</li>
<li>DefaultManagedTaskExecutor：这个实现的目标是替代 WorkManagerTaskExecutor。</li>
</ul>
<h3>TaskExecutor 的使用</h3>
<p>下面以最常见的 ThreadPoolTaskExecutor 为例来演示 TaskExecutor 的使用。</p>
<p>创建一个待执行的任务：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskDemo</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再创建一个执行任务的执行器：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTaskDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor threadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadPoolTaskExecutor.execute(<span class="keyword">new</span> TaskDemo(<span class="string">"Hello rayjun "</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThreadPoolTaskExecutor</span><span class="params">(ThreadPoolTaskExecutor threadPoolTaskExecutor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadPoolTaskExecutor = threadPoolTaskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在容器中注入这两个类：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"taskExecutor"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corePoolSize"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"queueCapacity"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"springTaskDemo"</span> <span class="attr">class</span>=<span class="string">"cn.rayjun.spring.SpringTaskDemo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"threadPoolTaskExecutor"</span> <span class="attr">ref</span>=<span class="string">"taskExecutor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>再通过单元测试来执行代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(<span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringTaskDemoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SpringTaskDemo springTaskDemo = (SpringTaskDemo) context.getBean(<span class="string">"springTaskDemo"</span>);</span><br><span class="line">        springTaskDemo.printMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>控制台中会输出10条消息。</p>
<h2>3. TaskScheduler</h2>
<p>TaskScheduler 用来执行定时任务，与 TaskExecutor 接口只提供了一个方法不同，TaskScheduler 接口提供了很多方法。</p>
<p>这些方法都接收一个 Runnable 实例，以及表示时间或者频率的参数。定时任务可以配置为执行一次，也可以配置为重复执行。</p>
<p>TaskSchduler 提供的方法如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskScheduler</span> </span>&#123;</span><br><span class="line">      <span class="function">ScheduledFuture <span class="title">schedule</span><span class="params">(Runnable task, Trigger trigger)</span></span>;</span><br><span class="line">      <span class="function">ScheduledFuture <span class="title">schedule</span><span class="params">(Runnable task, Instant startTime)</span></span>;</span><br><span class="line">      <span class="function">ScheduledFuture <span class="title">schedule</span><span class="params">(Runnable task, Date startTime)</span></span>;</span><br><span class="line">      <span class="function">ScheduledFuture <span class="title">scheduleAtFixedRate</span><span class="params">(Runnable task, Instant startTime, Duration</span></span></span><br><span class="line"><span class="function"><span class="params">  period)</span></span>;</span><br><span class="line">      <span class="function">ScheduledFuture <span class="title">scheduleAtFixedRate</span><span class="params">(Runnable task, Date startTime, <span class="keyword">long</span> period)</span></span>;</span><br><span class="line">      <span class="function">ScheduledFuture <span class="title">scheduleAtFixedRate</span><span class="params">(Runnable task, Duration period)</span></span>;</span><br><span class="line">      <span class="function">ScheduledFuture <span class="title">scheduleAtFixedRate</span><span class="params">(Runnable task, <span class="keyword">long</span> period)</span></span>;</span><br><span class="line">      <span class="function">ScheduledFuture <span class="title">scheduleWithFixedDelay</span><span class="params">(Runnable task, Instant startTime, Duration</span></span></span><br><span class="line"><span class="function"><span class="params">  delay)</span></span>;</span><br><span class="line">      <span class="function">ScheduledFuture <span class="title">scheduleWithFixedDelay</span><span class="params">(Runnable task, Date startTime, <span class="keyword">long</span> delay)</span></span>;</span><br><span class="line">      <span class="function">ScheduledFuture <span class="title">scheduleWithFixedDelay</span><span class="params">(Runnable task, Duration delay)</span></span>;</span><br><span class="line">      <span class="function">ScheduledFuture <span class="title">scheduleWithFixedDelay</span><span class="params">(Runnable task, <span class="keyword">long</span> delay)</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3>TaskScheduler 实现</h3>
<p>TaskScheduler 有三个实现：</p>
<ul>
<li>ThreadPoolTaskScheduler：使用的比较多，是对 JDK中的 ScheduledThreadPoolExecutor 进行包装</li>
<li>ConcurrentTaskScheduler：同样也是对 ScheduledThreadPoolExecutor 进行包装，但是同时也继承了 ConcurrentTaskExecutor 来提供更好的并发度</li>
<li>DefaultManagedTaskScheduler：基于 JDNI 规范的实现，功能上与 ConcurrentTaskScheduler 相同</li>
</ul>
<h3>TaskScheduler 的使用</h3>
<p>TaskScheduler 的使用和 TaskScheduler 类似。</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"taskSchedulerExecutor"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolSize"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"springSchedulerTaskDemo"</span> <span class="attr">class</span>=<span class="string">"cn.rayjun.spring.SpringSchedulerTaskDemo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"threadPoolTaskScheduler"</span> <span class="attr">ref</span>=<span class="string">"taskSchedulerExecutor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSchedulerTaskDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskScheduler threadPoolTaskScheduler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadPoolTaskScheduler.schedule(<span class="keyword">new</span> TaskDemo(<span class="string">"Ray"</span>), <span class="keyword">new</span> CronTrigger(<span class="string">"0/5 * * * * ?"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThreadPoolTaskScheduler</span><span class="params">(ThreadPoolTaskScheduler threadPoolTaskScheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadPoolTaskScheduler = threadPoolTaskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringSchedulerTaskDemo springTaskDemo = (SpringSchedulerTaskDemo) context.getBean(<span class="string">"springSchedulerTaskDemo"</span>);</span><br><span class="line">springTaskDemo.printMessage();</span><br></pre></td></tr></table></figure></p>
<p>执行上面的代码之后，每隔5 秒钟就会打印一次消息。</p>
<h2>4. task namespace</h2>
<p>在 Spring 中，提供了 task 的 namespace，这样就可以少写很多代码。</p>
<p>在 xml 中假如如下 namespace:</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:task="http://www.springframework.org/schema/task"</span><br><span class="line">xsi:schemaLocation="http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd"</span><br></pre></td></tr></table></figure></p>
<p>然后上面创建 TaskExecutor 如下：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"taskExecutor2"</span> <span class="attr">pool-size</span>=<span class="string">"5-10"</span> <span class="attr">queue-capacity</span>=<span class="string">"25"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>创建 TaskScheduler 如下：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"threadPoolTaskScheduler"</span> <span class="attr">pool-size</span>=<span class="string">"1"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ServeMux 详解</title>
    <url>/2021/08/30/ServeMux-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>在 Go 语言中，创建一个 HTTP 服务很简单，只需要几行代码就可以创建一个可用的 HTTP 服务，这是因为 Go 原生帮我们实现了一个默认的 HTTP 服务，就是 ServeMux，在这篇文章中，我们来详细看一下 ServeMux 的具体实现。</p>
<h2>1. 创建一个 HTTP 服务</h2>
<p>在 Go 语言中，创建一个 HTTP 服务只需要写下面几行代码就可以了。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">		writer.Write([]<span class="keyword">byte</span>(<span class="string">"Hello go web"</span>))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个路由，然后启动 HTTP 服务，就可以在浏览器中通过 <a href="http://127.0.0.1:8080/inde" target="_blank" rel="noopener">http://127.0.0.1:8080/inde</a>x 来访问服务，服务端会返回 <code>Hello go web</code>。</p>
<p>这样，一个简单的 HTTP 服务就创建完成了。</p>
<h2>2. HTTP 服务如何运行</h2>
<p>上面的代码有两部分，一部分是定义 HTTP 服务的路由，在服务启动之后，我们访问相应的路由，就能得到服务端的响应。</p>
<p>在 http 包中，有一个接口 <code>http.Handler</code> ，这个接口是 HTTP 服务的核心：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 HTTP 服务来说，一定发起请求的客服端和处理请求的服务端，客户端发起一个请求，然后服务端给出相应的输出。这个 Handler 接口就把这个整个过程抽象为 ServeHTTP 方法。ResponseWriter 表示服务端的输出，Request 表示来自客户端的请求。</p>
<p>在 http 包中提供了一个 Handler 的实现 ServeMux，这个Handler 做的事情也很简单，就是来维护 URL 和 Handler 之间的关系，根据 URL 判断应该把请求转发到哪个 Handler，没错这里的 Handler 也是 http.Handler，是同一个接口。用 http.Handler 来管理 http.Handler，我觉得这是一个非常优雅的设计。</p>
<h3>2.1 定义路由</h3>
<p>路由可以使用两种方式来定义，一种是实现 Handler，还有一种是使用 HandleFunc，这两个概念在上一篇文章中我们已经详细讨论过了，这里就不多说。</p>
<p>示例代码中的路由使用 HandleFunc 来定义，这里我们来看一下路由具体是如何被定义的。我们进入 HandleFunc 的源码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现实际上是调用了 <code>DefaultServerMux</code> 的 HandleFunc 方法，<code>DefaultServerMux</code> 实际上就是 ServeMux，是 Go 的 HTTP 服务的默认实现。然后 <code>DefaultServerMux</code> 调用 Handle 方法来处理路由：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">	mux.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: invalid pattern"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">	&#125;</span><br><span class="line">	e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line">	mux.m[pattern] = e</span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">'/'</span> &#123;</span><br><span class="line">		mux.es = appendSorted(mux.es, e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">		mux.hosts = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>路由由两部分组成，一个是匹配 HTTP url 的 pattern，每个pattern 都代表着一类 HTTP 请求，都需要一个对应的 handler 来处理。</p>
<p><code>DefaultServerMux</code> 的 Handle 方法其实就做了一件事，在判断路由和对应的 handler 实现都没问题，并且该路由没有重复定义之后，就把这些路由都存到  map 中。所以 HTTP 服务的路由表其实就是一个 map。</p>
<p>完整流程如下，<code>DefaultServerMux</code> 简称为 DSM ：</p>
<p><img src="0.png" alt=""></p>
<h3>2.2 启动 HTTP 服务</h3>
<p>路由定义完成之后，就需要启动服务了，就是下面这行代码:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>通常，第二个参数都会设置为 nil，设置为 nil 的时候，就会使用 Go 语言默认的 HTTP 服务实现。我们跟进代码的实现：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">	<span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，会创建一个  Server，Server 就是表示一个服务端， 其中定义了运行一个 HTTP 服务所需要的全部参数以及必要的方法，如果不给 Server 传入参数 ，那么 Server 就使用默认的参数运行。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 服务端的 host 和 端口号</span></span><br><span class="line">	Addr <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	Handler Handler <span class="comment">// 默认为 ServeMux</span></span><br><span class="line">  <span class="comment">// 省略其他参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后 server 会调用 ListenAndServe 来启动端口监听和请求接收，使用 net.Listen 来启动监听端口：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrServerClosed</span><br><span class="line">	&#125;</span><br><span class="line">	addr := srv.Addr</span><br><span class="line">	<span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">		addr = <span class="string">":http"</span></span><br><span class="line">	&#125;</span><br><span class="line">	ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> srv.Serve(ln)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后调用 Server 的 Serve 方法来接收请求和处理请求。在 Serve 方法中，最关键的是下面这段代码，这里是一个 for 循环，没有结束条件，除非发生错误或者主动结束服务，否则会一直处在接收请求的状态。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.go#Serve</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">		rw, err := l.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">				<span class="keyword">return</span> ErrServerClosed</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//......</span></span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		connCtx := ctx</span><br><span class="line">		<span class="keyword">if</span> cc := srv.ConnContext; cc != <span class="literal">nil</span> &#123;</span><br><span class="line">			connCtx = cc(connCtx, rw)</span><br><span class="line">			<span class="keyword">if</span> connCtx == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"ConnContext returned nil"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tempDelay = <span class="number">0</span></span><br><span class="line">		c := srv.newConn(rw)</span><br><span class="line">		c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">		<span class="keyword">go</span> c.serve(connCtx)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>接收到请之后，会为每一个请求创建一个 conn 实例，conn 表示服务端的一个 HTTP 连接，并启动一个新的 goroutine 来处理这个请求。</p>
<p>然后就进入到 conn 的 serve 方法。</p>
<p>因为在一个 HTTP 请求中，有可能会出现多次请求的收发，所以这里依然启动了 for 的循环来接收请求数据。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">		w, err := c.readRequest(ctx)</span><br><span class="line">		<span class="keyword">if</span> c.r.remain != c.server.initialReadLimitSize() &#123;</span><br><span class="line">			<span class="comment">// If we read any bytes off the wire, we're active.</span></span><br><span class="line">			c.setState(c.rwc, StateActive)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// .. 去掉无关代码</span></span><br><span class="line">		serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">    <span class="comment">// .. 去掉无关代码	</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 conn 的 serve 方法中，其实就只做了两件事，一件事读取请求中的数据。然后是调用 ServeHTTP 方法，进入到 ServeHTTP 方法中：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">	handler := sh.srv.Handler</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = DefaultServeMux</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">		handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断 handler 是否为 nil，如果为 nil，然后就直接使用 DefaultServeMux 的 ServeHTTP 方法来处理 HTTP 请求。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">			w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		w.WriteHeader(StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h, _ := mux.Handler(r)</span><br><span class="line">	h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现其实这个方法也只做了一件事，就是去上面路由表 muxEntry 中匹配路由，然后使用路由 的 Handler 调用 ServerHTTP 来真正的处理请求。</p>
<p>完整的流程如下：</p>
<p><img src="1.png" alt=""></p>
<h2>3. 小结</h2>
<p>Go 服务默认的 HTTP 处理流程其实不难理解，最难的地方在于满屏都是 Handler 接口和 ServeHTTP 方法，理解 Handler 接口是理解整个流程的关键。</p>
<p>所有的 HTTP 请求都需要经过 ServeHTTP 方法处理。而 Go 语言中的 ServeMux 实现了 Handler 接口，通过 url 找到对应的路由，然后在 ServeHTTP 中调用路由实现的 ServeHTTP 方法去真正处理对应的请求。</p>
<p>Go 语言对 HTTP 服务的抽象非常好，通过一个接口就把整个流程串起来了。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN 命令行简易教程</title>
    <url>/2018/12/02/SVN-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3>SVN 基础概念</h3>
<p>SVN 是一种版本管理系统(VCS)，VCS 可以完成以下的事：</p>
<ul>
<li>
<p>允许多人同时在一个项目中工作</p>
</li>
<li>
<p>不会重写每个人的修改</p>
</li>
<li>
<p>可以保持每个版本的全部历史</p>
</li>
</ul>
<p>VCS 可以分为中心化版本控制系统和分布式版本控制系统，SVN 属于中心化的版本控制系统。</p>
<p><strong>SVN 的相关概念</strong>:</p>
<ul>
<li>仓库：SVN 只有一个仓库，就是中心仓库，所有人的提交都会提交到这里</li>
<li>主干：trunk，这里存放项目代码或相关文件</li>
<li>标签：tags 用于标示项目中呗命名的快照</li>
<li>分支：用于创建项目的一个一个分支，可以在新的分支上继续工作，一个项目可以有多个分支</li>
<li>工作副本：将项目从仓库拉取到本地之后，就是一个工作副本</li>
</ul>
<h3>SVN 命令行操作</h3>
<p>svn 在使用的过程中主要包括如下的过程:</p>
<h4>从仓库获取阶段</h4>
<p><strong>从仓库检出代码</strong>：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn checkout svn://gitee.com/XXX/svn_test_items --username=leijun19930412@sina.com</span></span><br></pre></td></tr></table></figure></p>
<p><strong>查看 SVN 信息</strong>:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn info</span></span><br></pre></td></tr></table></figure></p>
<p><strong>查看提交历史</strong>:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>从仓库更新代码</strong>：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn update</span></span><br></pre></td></tr></table></figure></p>
<h4>工作副本阶段</h4>
<p><strong>查看工作副本状态</strong>:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn status</span></span><br></pre></td></tr></table></figure></p>
<p><strong>查看文件变化</strong>:
可以查看单个文件和单个文件夹的变化，也可以查看整个项目的变化。
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn diff</span></span><br></pre></td></tr></table></figure></p>
<p><strong>添加全部新增文件</strong>:
会忽略 svn.ignore 的文件，也可以只添加单独的文件和目录
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn add . --force</span></span><br></pre></td></tr></table></figure></p>
<p><strong>添加文件或者目录到 ignore</strong>:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn propset svn:ignore fileOrdir ./</span></span><br></pre></td></tr></table></figure></p>
<p><strong>解除项目的ignore</strong>:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn add fileOrDir --no-ignore</span></span><br></pre></td></tr></table></figure></p>
<p><strong>放弃文件的修改</strong>：
如果想放弃某个文件的修改
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn revert hello.c</span></span><br></pre></td></tr></table></figure>
如果想放弃整个目录的修改:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn revert -R dir</span></span><br></pre></td></tr></table></figure>
如果想放弃整个项目的修改:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn revert -R .</span></span><br></pre></td></tr></table></figure></p>
<p><strong>解决文件冲突</strong>:</p>
<ul>
<li>将代码与仓库同步</li>
</ul>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn update</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>查看冲突的文件</li>
</ul>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn status</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>手动合并被标示为 C 的文件</li>
<li>然后解决冲突</li>
</ul>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn resolve --accept=working filename</span></span><br></pre></td></tr></table></figure></p>
<p><strong>新建tag</strong>:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn copy --revision=version(版本号) trunk/ tags/tag_name</span></span><br></pre></td></tr></table></figure></p>
<p><strong>分支</strong>:
新建分支:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn copy trunk branches/branch_name</span></span><br></pre></td></tr></table></figure>
合并分支:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn merge  brancjes/branch_name</span></span><br></pre></td></tr></table></figure></p>
<h4>提交更改阶段</h4>
<p><strong>提交文件的修改</strong>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn commit -m <span class="string">"Update"</span></span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码系列-Spring框架简介</title>
    <url>/2018/09/27/Spring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97-Spring%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h4>Spring 整体架构</h4>
<p>Spring 的架构图如下所示:</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/0AF05523-590D-4F6A-A1B0-ADA8CC4D5895.png" alt="spring基础架构"></p>
<p>在 Spring 框架中，容器是核心部分，容器主要由以下几部分构成：spring-core spring-beans spring-context spring-context-support spring-expression 其中 spring-core 和 spring-brans 是构成Spring框架的基础，包括了IOC和DI的特性。 spring-context 负责容器中beans创建和管理。spring-context-support 负责集成第三方的包进入到框架中。spring-expression 是一组在运行时可以查询和操纵对象的表达式。</p>
<h4>Spring 的依赖注入</h4>
<p>提到Spring容器，就不得不提到IOC(控制反转) 和 DI(依赖注入)，其实 IOC 和 DI描述的是同一个概念。依赖注入是指一个对象定义的依赖只通过构造函数参数或者setter方法来设置，容器在创建这个对象的时候会将该对象依赖的对象都注入进来。这个过程也称之为控制反转。对象本身可以通过构造对象或者 Service Locator 模式来实例化依赖。</p>
<p>这个概念这样看起来还是太过于抽象了，那么来看一个具体的例子。 原来的开发模式:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> SpringIoc springIoc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.springIoc = <span class="keyword">new</span> SpringIoc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>依赖注入的模式是这样的：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> SpringIoc springIoc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.springIoc = <span class="keyword">new</span> SpringIoc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完了？完了。看起来这是在逗你吧。但是实际上，依赖注入干的就是这件事，依赖注入的核心是每个对象都不要去控制自己的依赖，所有的依赖都通过外部注入进来。那有人就说那这件事没有 Spring 也可以干这件事呀， 如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BarMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringIoc springIoc = <span class="keyword">new</span> SpringIoc();</span><br><span class="line">		Bar bar = <span class="keyword">new</span> Bar(springIoc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是需要注意的是，在这个代码中。还是存在需要手动去新建对象的情况，也就是说，问题根本没有被解决。这个时候，Spring 容器的出现就是为了解决这个问题的。Spring容器的出现就是为了干掉这个手动生成对象的操作。</p>
<p>Spring 容器的核心思想是所有的bean及其依赖都不需要手动去生成，都只需要通过Spring 容器来统一管理。需要实例化的时候直吴容器里面取就行了。Spring 容器这么强大，那么Spring容器到底是什么东西呢？</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/12A90F98-6146-4012-A83D-617E7AC84DA0.png" alt=""></p>
<p>可以看出来，容器就是Spring框架提供用来生成和管理bean的机制。所有被容器管理的java对象都称之为 bean，bean之间的关系是通过配置的元数据来决定的，容器也是通过元数据来创建bean的。Spring容器与Java类和配置文件有很大的关系。一句话总结就是Spring容器可以根据提供的配置文件来维护bean及其依赖关系。</p>
<p>容器的初始化需要加载一个配置，通过这个配置才能确定容器中bean的生成和管理方式。容器的配置方式可以有多种：</p>
<ul>
<li>xml配置</li>
<li>基于注解的配置</li>
<li>基于java的配置</li>
</ul>
<p>这些配置方式都不是独立的，都可以结合起来使用，比如xml配置就经常与基于注解的配置方式结合起来使用。示例代码如下:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-ioc.xml"</span>).getBeanFactory();</span><br><span class="line">		ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-ioc.xml"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		SpringIoc springIocFromBeanFactory = (SpringIoc) beanFactory.getBean(<span class="string">"springIoc"</span>);</span><br><span class="line">		SpringIoc springIocFromApplicationContext = (SpringIoc) applicationContext.getBean(<span class="string">"springIoc"</span>);</span><br><span class="line"></span><br><span class="line">		springIocFromBeanFactory.hellIoc();</span><br><span class="line">		springIocFromApplicationContext.hellIoc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常获取 ApplicationContext 对象来作为访问容器的接口。通过 ApplicationContext来获取 bean(当然实际的使用当中不会这么用)。 在容器初始化的过程中，容器会根据配置文件将大部分bean也实例化(设置了延迟加载的bean不会再启动阶段就初始化)。一个基于Spring的应用也算是启动起来了。 这些基本就是Spring框架最为核心的内容了，其他的Spring 模块都是在容器的基础之上构建出来的。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之Spring的魅力在哪</title>
    <url>/2020/01/18/Spring%E7%B3%BB%E5%88%97%E4%B9%8BSpring%E7%9A%84%E9%AD%85%E5%8A%9B%E5%9C%A8%E5%93%AA/</url>
    <content><![CDATA[<p>Spring 如今毫无疑问是 Java 中最受欢迎的框架。Spring 已经成为事实上的 Java 企业级开发的标准。所以 Spring 到底为什么有这么大的魅力，通过这篇文章来简单聊聊。</p>
<blockquote>
<p>本文基于 Spring5</p>
</blockquote>
<h2>为什么需要 Spring</h2>
<p>因为 Spring 可以<strong>简化 Java 开发</strong>。传统 Java 开发的困难之一在于代码的耦合度很高，各个组件的侵入性很强。在这里耦合度高和侵入性表达的是同样的问题。看下这个简单的例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Soldier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        weapon = <span class="keyword">new</span> Knife();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Knife</span> <span class="keyword">implements</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的代码坏在哪里？没错，就是代码的耦合度太高了，也可以说 Weapon 的侵入性太强。这样一来 Soldier 只能持有 Knife，想换一把武器就得修改一次代码，这对于运行的系统来说肯定是不能被接收了。实际要解决这个问题其实也很简单，只要做一点小小的改动：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Soldier</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gun</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Weapon gun = <span class="keyword">new</span> Gun();</span><br><span class="line">Soldier s = <span class="keyword">new</span> Soldier(gun);</span><br></pre></td></tr></table></figure>
做了一点小小的改动之后，好多了，这下 Soldier 想用什么武器就用什么武器，而不用换武器都需要修改 Solider 的代码。这个其实就是 Spring 的核心特性之一：<strong>依赖注入</strong>。但这样还是挺麻烦，每次都需要手动的去 new 一个对象，然后作为一个参数传进去，这个问题自然也有解决的办法，我们后面再讲。再来说一下引起代码复杂度的另一个原因。</p>
<p>有时候除了写业务代码之外，我们还需要做很多的其他的工作，比如安全检查，打日志等等，如果按照正常我们常用的写代码的方式，如下:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Soldier</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FightLog.fightLogBefore();</span><br><span class="line">        weapon.attack();</span><br><span class="line">        FightLog.fightLogAfter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FightLog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightLogBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Fight begin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightLogAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Fight after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们要记录 Soldier 打斗的全过程，就不得不在打斗开始和结束的地方进行记录。这些记录打斗日志的代码会出现在系统的各个地方，而且和实际的业务逻辑无关，所以这样就会使代码变得很混乱，而且也有很多重复的代码。Spring 为这个问题也准备了一个解决方法：<strong>面向切面编程（AOP）</strong>。</p>
<p>这两个问题也是日常开发中最容易遇到的问题，Spring 的核心目标就是为了解决这两个问题，以此来简化 Java 的开发，而且 Spring 也做到了。</p>
<h2>什么是 Spring 容器</h2>
<p>很难精确的使用语言去描述什么是 Spring 容器。Spring 容器就像是一台机器，你需要往里放两种原料，然后这台机器就能把你想要的系统给你生产出来。两种原料一种是<strong>业务类（POJOs）<strong>和</strong>配置数据</strong>。就像下面这个图所示：</p>
<p><img src="spring-container.png" alt=""></p>
<blockquote>
<p>POJO: Plain old Java Object，代表的就是普通的 Java 类
配置数据: 配置各个 POJO 之间的依赖关系</p>
</blockquote>
<p>Spring 容器说到底是装东西的，里面装的是 Spring Bean，也就是 POJO，这些 Bean 的生命周期都由 Spring 来管理。</p>
<h3>Spring 容器的实现</h3>
<p>在 Spring 中，容器的实现不止一种。每种不同的容器都实现了 <code>BeanFactory</code>。这么多的容器实现是为了应对不同的情况，比如 Web 开发就需要一些额外的特性。还有为了方便不同的配置文件，也实现了不同的容器，这些容器最核心的目标都是用来管理 Bean。容器的继承关系很复杂，就不完整列出了。下面是其中几个比较关键的容器实现：</p>
<p><img src="spring-context.png" alt=""></p>
<p>上面的每一个容器都可以直接使用，但是很少会直接使用 BeanFactory，一般都会使用 ApplicationContext 及其子类。ApplicationContext 及其子类提供了更多的服务，比如从配置文件中加载信息等等，可以应对不同类型的 Spring 应用。</p>
<p>以 ClassPathXmlApplicationContext 容器配置为例：
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span> xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"gun"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.springcontainer.Gun"</span>&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"solider"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.springcontainer.Soldier"</span>&gt;</span><br><span class="line">        &lt;constructor-arg name=<span class="string">"weapon"</span> ref=<span class="string">"gun"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
上面我们说到了 Spring 容器需要两种原料，上面这个 xml 配置文件就是<strong>配置数据</strong>，Soldier 以及 Weapon 和其子类就是 <strong>POJOs</strong>。在这个文件中，我们将各个 POJO 之间的依赖关系配置好。然后 Spring 容器就会根据这些配置生成一个可用的系统。配置数据除了使用 xml 之外，还可以使用注解和 Java 代码来进行配置，这部分后续再详聊。</p>
<p>这些容器也都提供了获取 Bean 的 API，如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">Soldier s = context.getBean(<span class="string">"soldier"</span>);</span><br></pre></td></tr></table></figure>
但是永远不要用上面那种方式来获取 Bean，容器本来就是用来解耦的，如果用上面那种方式，根本就没有起到解耦的目的。具体使用方式在后续文章中详解。</p>
<h3>Spring Bean 的生命周期。</h3>
<p>Spring Bean 是容器管理的基本单位。Spring Bean 与普通的 Java 对象没有什么区别。</p>
<p>每一个 Java 对象都有其生命周期，从对象被创建出来，到最后被回收，Spring Bean 自然也不例外，只是 Spring Bean 的生命周期要比普通的类稍微复制一点，但这些复杂的过程都是由容器来进行管理的，不需要开发者做额外的事情。而且开发者可以通过配置来决定一个 Bean 的生命周期。</p>
<p><img src="spring-bean-life.png" alt=""></p>
<p>其中一些陌生的类名不知道没关系，这里也不需要关注，后续分析源码的时候我们再聊，在这里我们需要关注两个地方，就是在 Bean 初始化和回收的时候，可以调用我们自定义的初始化和销毁方法，这个还是非常有用的。</p>
<h2>Spring 的两大特性</h2>
<p>Spring 有两大特性：<strong>依赖注入（DI）</strong> 和 <strong>面向切面编程（AOP）</strong>。</p>
<p>上面其实已经聊到了，Spring 的这两大特性其实就是用来解决 Java 编程的两大痛点。</p>
<p>依赖注入的目的是代码解耦。当然完全的解耦是不可能的，类之间没有交互，程序就无法跑起来了。</p>
<p>依赖注入的实现方式很简单，上文中将 Weapon 的实例通过构造函数传入就是依赖注入的一种实现。另一种注入的方式就是通过 Setter 方法来进行注入。依赖注入本身除了名字比较高端，其实比较简单，但是有一点需要注意，依赖注入经常会和<strong>面向接口编程</strong>一起出现，也就是说依赖注入需要使用多态的特性来使得解耦更加彻底。假如不使用接口编程，上面的代码会编程什么样呢：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用刀的 Soldier</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Knife knife;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Soldier</span><span class="params">(Knife knife)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.knife = knife;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        knife.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
假如说我要把刀换成枪，只能通过该代码来完成。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用枪的 Soldier</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Gun gun;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Soldier</span><span class="params">(Gun gun)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gun = gun;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        gun.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，如果不使用多态，依赖注入的威力顿时没了 90%。</p>
<p>在 Spring 中，注入这个操作是 Spring 容器来完成的，需要开发者将各个 Bean 之间的依赖关系在配置中定义好，代码中基本不会出现 new 这个关键字，但是整个程序却跑起来了。</p>
<p>依赖注入经常会和控制反转一起出现，这两个概念之间有什么关系吗？实际上可以说依赖注入是控制反转的一种实现。在没有 Spring 之前，如果需要对象，我们都需要手动 new 一个，而现在，所有的对象都不要自己来 new 了，这些事情都交给 Spring 容器来做了，也就是把生成对象的权利交给了 Spring 容器，所以 Spring 容器也称之为 IOC 容器。</p>
<p>Spring 的另一大特性叫面向切面编程（AOP）。DI 的目标是使得代码之间的耦合度更低 <strong>（低耦合）</strong>，那么 AOP 的目标就是使代码的职责更加单一，提高代码的可复用性 <strong>（高内聚）</strong>。</p>
<p>AOP 中引入了一个新的概念：<strong>切面</strong> 和 <strong>切点</strong>。我们可以把每一个 Bean 都配置为一个切面，Bean 中的每一个方法都可以配置为一个切点。</p>
<p>FightLog 类改造如下，那么在 Soldier 在 fight 方法执行之后，战斗的过程也会被记录下来。这就是 AOP 的威力，不需要修改代码，就可以增加切面的方式来使代码变得整洁。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FightLog</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* cn.rayjun.springdemo.springcontainer.Soldier.fight(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightLogBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Fight begin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* cn.rayjun.springdemo.springcontainer.Soldier.fight(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightLogAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Fight after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Soldier</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        weapon.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果不使用 AOP，这些与业务无关的代码会到处都是，而且会破坏代码职责单一性。常见的场景就是日志，我需要给某些点打日志，但是又不想代码中到处都是日志代码，那么使用 AOP 就是一个比较好的选择了，具体的原理后续的文章中再详细说。</p>
<p>Spring的这两大特性将面向对象的思想实践的淋漓尽致。学会了 Spring，也就真懂面向对象编程了。</p>
<h2>Spring 模块的架构图</h2>
<p>Spring 已经演化到了第 5 个大版本了，所以 Spring 远远不只有容器了。实际上，Spring 已经为建设企业级应用的方方面面都给出了解决方案，可以用 Spring 来建设多种类型的应用。</p>
<p>Spring 的核心架构图：</p>
<p><img src="spring-arch.png" alt=""></p>
<p>为了让开发者使用 Spring 更加便利，SpringBoot 就诞生了，SpringBoot 并不是一个新的技术，而是官方对 Spring 框架做了一个封装。</p>
<p>Spring 框架强大，使用简单，可以应对各类应用。在面对一个复杂的系统时，Spring 的依赖注入和 AOP 特性可以简化系统架构，让普通程序员也可以构建出不差的系统。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL是什么</title>
    <url>/2020/10/04/SQL%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>SQL 的全称是结构查询语言，这是第一个实现了关系模型的语言。是一种特定领域语言，如果你想开发一个软件，仅仅依靠 SQL 是无法完成的，它只能用于数据的查询和统计。与之相反，C 语言等就被称之为通用语言。</p>
<p>SQL 是关系模型的实现，在被 Oracle，MySQL 等各大关系型数据库所采用，但 SQL 不仅仅在关系型数据库中使用的很广泛，在大数据领域中也有很大的使用空间，Spark、Flink 等前沿的计算框架也都提供了 SQL 接口。</p>
<h2>1. SQL结构</h2>
<p>SQL 语言本身可以分成 DDL、DCL、DML等类型，每一类都有不同功能。</p>
<p>在 SQL 中有大量的操作符可以使用，而且为了更方便的查询和统计数据，SQL 中还内置了很多函数。</p>
<p>无论是上面三种类型的哪一种，都是由基础的元素构成，最基础的元素有三种：</p>
<ul>
<li>子句（Clauses)：每一个SQL 都可以分解成一个个子句</li>
<li>表达式（Expressions)：可以产生任何标量值</li>
<li>谓词（Predicates)：产生一个三值逻辑值（true/false/unknow）或者布尔值。</li>
</ul>
<p>还有另外两种元素是由上面的部分组成的。</p>
<ul>
<li>查询（Queries）：基于特定的条件检索数据</li>
<li>语句（Statements）：可以持久化地影响数据和数据结构</li>
</ul>
<p>也就是说，执行中的 SQL，要么是查询，要么就是语句。</p>
<p>以 SQL 中的 SELECT <strong>查询</strong>为例：</p>
<p><img src="0.png" alt=""></p>
<p>以 SQL 中的 UPDATE <strong>语句</strong>为例：</p>
<p><img src="1.png" alt=""></p>
<p>这里介绍的是 SQL 的标准语法，在不同数据库中的实现有所不同。</p>
<h3>DDL</h3>
<p>DDL 全称是 data definition language，用于定义数据结构。</p>
<p>因为如果要能使用 SQL，就要求数据是结构化的。结构化就是指数据的数据结构，有哪些字段，字段是哪种类型，都需要提前定义好。</p>
<p>通俗来说，就是用来创建数据，创建表，修改表结构等等。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">bigint</span>(<span class="number">20</span>) primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line"> author <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line"> <span class="keyword">content</span> <span class="built_in">varchar</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3>DCL</h3>
<p>每个数据库系统中都会涉及到权限和安全，DCL 就是用来维护系统访问权限，全称是 data control language。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">ON</span> book</span><br><span class="line"><span class="keyword">TO</span> user1;</span><br></pre></td></tr></table></figure></p>
<h3>DML</h3>
<p>DML 是日常使用最频繁的一类，全称是 data manipulation language。</p>
<p>对数据表的增删改查都是属于这一类。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span>  Book</span><br><span class="line"><span class="keyword">WHERE</span> price &gt; <span class="number">100.00</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> title;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book</span><br><span class="line">(<span class="keyword">name</span>, author, <span class="keyword">content</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'围城'</span>, <span class="string">'钱钟书'</span>, <span class="string">'城里的人想出来，墙外的人想进去'</span>);</span><br></pre></td></tr></table></figure></p>
<h3>操作符</h3>
<p>SQL 中还提供了很多逻辑操作符操作符，这些逻辑操作符会和表达式组合形成一个谓词，用来过滤数据。</p>
<ul>
<li>=</li>
<li>&lt;&gt;</li>
<li>
<blockquote></blockquote>
</li>
<li>&lt;</li>
<li>≥</li>
<li>≤</li>
<li>between</li>
<li>like</li>
<li>in &amp; not in</li>
<li>is null &amp; is not null</li>
<li>is true &amp; is not true</li>
<li>is false &amp; is not false</li>
<li>is not distinct from (两个值相等或者都为空)</li>
<li>as</li>
</ul>
<h3>内置函数</h3>
<p>在数据查询统计的需求中，通常会涉及到对数据的汇总和统计，SQL 中提供了很多内置的函数来帮助完成这个过程。</p>
<p>比如时间类的函数：</p>
<ul>
<li>DAY</li>
<li>MONTH</li>
<li>WEEKDAY</li>
<li>YEAR</li>
<li>...</li>
</ul>
<p>字符串函数：</p>
<ul>
<li>LOWER</li>
<li>UPPER</li>
<li>...</li>
</ul>
<p>聚合函数：</p>
<ul>
<li>COUNT</li>
<li>AVG</li>
<li>MAX</li>
<li>MIN</li>
<li>...</li>
</ul>
<h2>2. SQL标准</h2>
<p>SQL 起源于 1970 年的一篇论文[5]，然后由 IBM 实现了这篇关系模型的论文，这就是 SQL 的前身，然后自家产品不断推出相关的产品。</p>
<p>Oracle 看到了 SQL 的潜力，也加入竞争，经历了一段时间的野蛮生长之后，这两家公司共同促进了 SQL 的标准化。</p>
<p>在 1986 年，SQL 成为了 ANSI 的标准，一年之后也成为了 ISO 的标准。</p>
<p>目前最新的 SQL 标准是 SQL-2016，SQL-2019 的标准正在制定中。</p>
<p>SQL 的标准号是通过年份来决定的，历史上的各个 SQL 标准如下：</p>
<ul>
<li>1986 SQL-86</li>
<li>1989 SQL-89</li>
<li>1992 SQL-92</li>
<li>1999 SQL:1999</li>
<li>2003 SQL:2003</li>
<li>2006 SQL:2006</li>
<li>2008 SQL:2008</li>
<li>2011 SQL:2011</li>
<li>2016 SQL:2016</li>
<li>2019 SQL:2019（正在制定中）</li>
</ul>
<p>需要注意的是，SQL 标准与实际使用的 SQL 还是有很大区别的，比如在不同的数据库中，对 SQL 的实现不完全相同。</p>
<p>也就是说，很有可能 SQL 标准中的某个特性在具体的数据库中不能使用，比如在 MySQL 中，就抛弃了很多功能，但不妨碍它受欢迎。就像网络的七层协议一样，最后的实现也并不是完整按照这七层协议来，而是选择最实用的方式来实现。</p>
<p>文 / Rayjun</p>
<h3>REF</h3>
<p>[1] <a href="https://en.wikipedia.org/wiki/SQL" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/SQL</a></p>
<p>[2] <a href="https://en.wikipedia.org/wiki/SQL_syntax" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/SQL_syntax</a></p>
<p>[3] <a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Domain-specific_language</a></p>
<p>[4] <a href="https://en.wikipedia.org/wiki/General-purpose_language" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/General-purpose_language</a></p>
<p>[5] <a href="https://dl.acm.org/doi/10.1145/362384.362685" target="_blank" rel="noopener">https://dl.acm.org/doi/10.1145/362384.362685</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Thrift简明教程</title>
    <url>/2019/10/13/Thrift%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>现如今对于任何一个大型的服务，都不太可能是一个单体的服务。而是由诸多的子服务构成，具体的业务逻辑通过子服务之间的相互调用来完成。这种相互的调用称之为远程调用，也就是通常所说的 RPC。</p>
<h4>什么是 RPC</h4>
<p>RPC(Remote Procedure Call)是指远程调用，这个和本地调用有很大的区别。下面在 <code>main</code> 方法中调用 <code>helloWorld</code> 就是本地调用。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">final</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        helloWorld(); <span class="comment">// 本地调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在假设 <code>helloWorld</code> 这个方法不在本地，没法直接调用，那么就需要通过远程调用来访问这个方法，在进行远程调用的过程中，就产生了客户端-服务端（Server-Client）模式，服务的提供方就是服务端，服务的调用方就是客户端，客户端和服务端并不是绝对不变的，要看具体的服务的调用流程来认定服务端和客户端。</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/thrift/cilent-server.png" alt=""></p>
<p>远程调用的方式有很多，比如 Java 中的 RMI(Remote Method Invocation) 就是典型的 RPC， 还有 Http 也可以认为是一种 RPC。</p>
<p>Thrift 是 FaceBook 实现的一种支持多语言的 RPC 框架，对于主流的编程语言 <code>Java</code> ,<code>C++</code>, <code>Python</code> 等都有很好的支持。 Thrift 会通过自身的 <code>IDL(Interface Description Language)</code> 语言来对接口进行定义，然后 Thrift 通过定义好的 IDL 文件生成相应的接口脚手架，然后只需要分别实现接口脚手架的 Server 端和 Client 端。并将 Server 端进行部署，Client 就可以访问 Server端的服务。</p>
<h4>Thrift 特性简介</h4>
<p>下图是 Thrift 官方给出的架构图。Thrift 支持的语言多达 28 种，对于各类操作系统也都提供了支持，Thrift 将自身划为4层（不要和网络的四层协议混淆）,而且对于各个层已经做好干净的分层和实现。对于不同的业务场景就可以选择不同的协议进行组合。</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/thrift/thrift-arch.png" alt=""></p>
<p>Thrift 整体上可以分成以下四层：</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/thrift/thrift-layer.png" alt=""></p>
<ul>
<li>传输层提供了面向网络 IO 的抽象，在传输层可以使用多种传输协议，TCP、Http 提供了支持</li>
<li>协议层中定义了内存中数据到传输格式的映射机制</li>
<li>处理层封装了从输入流读取数据和从输出流写数据的能力</li>
<li>服务器层将上述的组件合并到一起并按照下列的流程工作：
<ul>
<li>创建一个 Transport 对象</li>
<li>在 Transport 基础上创建输入\输出 Protocol 对象</li>
<li>在输入\输出 Protocol 基础上创建 Processor 对象</li>
<li>监听到来的连接并移交给 Processor 处理</li>
</ul>
</li>
</ul>
<h5>Thrift 的性能</h5>
<p>Thrift 的性能在现有的 RPC 框架中属于前列，这里有详细的 <a href="http://szelei.me/rpc-benchmark-part1/" target="_blank" rel="noopener">Benchmark</a>，如果特别关注性能，那么 Thrift 是一个很好的选择。</p>
<h5>Thrift 的网络模型</h5>
<p>而且 Thrift 提供了多种网络模型，支持<strong>阻塞服务模型</strong>和<strong>非阻塞服务模型</strong>，所有的网络处理模型都继承自 <strong>TServer</strong>。</p>
<p><strong>阻塞服务模型</strong>：</p>
<ul>
<li>TSimpleServer
<ul>
<li>最简单的阻塞 IO 模型</li>
<li>一次只能接收和处理一个请求</li>
<li>实际开发基本不会用到</li>
</ul>
</li>
<li>TThreadPoolServer
<ul>
<li>采用阻塞 Socket 的方式工作</li>
<li>主线程负责监听是否有新的 Socket 到达</li>
<li>具体的业务处理交给线程池来处理</li>
</ul>
</li>
</ul>
<p><strong>非阻塞服务模型</strong>：</p>
<ul>
<li>TNonblockingServer
<ul>
<li>单线程模式，但是引入了 NIO 的机制，通过 Channel/Selector 机制来处理事件</li>
</ul>
</li>
<li>THsHaServer
<ul>
<li>THsHaServer 继承自 TNonblockingServer</li>
<li>引入了线程池提高了任务的并发处理能力</li>
</ul>
</li>
<li>TThreadedSelectorServer
<ul>
<li>这个模型是对 THsHaServer 模型的一种补充</li>
</ul>
</li>
</ul>
<h4>Thrift的序列化机制</h4>
<p>数据在网络的传输过程中，序列化和反序列化是一个很重要的过程，对于不同的系统，对序列化有着不同的要求，Thrift 提供了多种序列化的方式来满足不同的要求。传输协议总体上可以分成<strong>文本</strong>和<strong>二进制</strong>的两种协议。</p>
<p>Thrift 有如下的传输协议：</p>
<ul>
<li>TBinaryProtocol：二进制编码格式进行数据传输</li>
<li>TCompactProtocol：高效率、密集的二进制编码格式进行数据传输</li>
<li>TJSONProtocol：使用 JSON 文本的数据编码协议进行数据传输</li>
<li>TSimpleJSONProtocol：只提供 JSON 只写的协议，适用于通过脚本语言进行解析</li>
</ul>
<h4>Thrift demo 搭建</h4>
<p>Thrift 的安装在<a href="https://thrift.apache.org/docs/install/" target="_blank" rel="noopener">官方文档</a>已经介绍的很清楚了。</p>
<p>Thrift 使用 <strong>IDL</strong> 来定义（Client-Server）之间的接口。假如需要定义一个 <strong>hello</strong> 的接口，那么就可以定义一个 <code>hello.thrift</code>  文件，文件的内容如下：</p>
<p><figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> hello(<span class="number">1</span>: <span class="built_in">string</span> name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面定义了一个名为 <code>HelloWorldService</code> 的服务，在这个服务器中有一个叫 <code>hello</code> 的接口，这个接口接受一个 <code>string</code>  类型的参数。</p>
<p><code>service</code>  和 <code>string</code> 都是 IDL 的关键字，IDL 中的关键字包括：</p>
<ul>
<li>基本数据类型</li>
<li>容器类型</li>
<li>结构体</li>
<li>枚举</li>
</ul>
<p>这些都是 IDL 的基本数据结构，也还有命名空间、异常、常量等关键字。完整的 IDL文档看<a href="https://thrift.apache.org/docs/idl" target="_blank" rel="noopener">这里</a></p>
<p>上面的 IDL 代码定义好了一个 Thrift 接口的规则，Thrift 就可以根据这个规则生成相应的接口文件。通过这些接口文件，就可以方便的实现相应的业务逻辑，相当于 Thrift 通过 IDL 文件搭出了服务脚手架。</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/thrift/thrift-code.png" alt=""></p>
<p>在生成的脚手架文件中，有两个 interface 非常重要：</p>
<ul>
<li><strong>Iface</strong>: 这个 interface 由服务器来实现，向客户端提供服务的逻辑在这个接口内实现</li>
<li><strong>Client</strong>: 这个 interface 由客户端来实现，访问服务端的逻辑在这个接口内实现</li>
</ul>
<p><code>AsyncIface</code>  和 <code>AsyncClient</code> 是这两个 interface 的异步版本。</p>
<p>下面使用 <code>SimpleServer</code> 来实现这个服务：</p>
<p><strong>Iface 实现</strong>:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorldService</span>.<span class="title">Iface</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String username)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*创建一个服务器，向外暴露服务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> TTransportException </span>&#123;</span><br><span class="line">        TServerSocket serverSocket = <span class="keyword">new</span> TServerSocket(<span class="number">9090</span>);</span><br><span class="line">        HelloWorldService.Processor processor = <span class="keyword">new</span> HelloWorldService.Processor(<span class="keyword">new</span> HelloWorldServiceImpl());</span><br><span class="line">        TSimpleServer.Args tArgs = <span class="keyword">new</span> TSimpleServer.Args(serverSocket);</span><br><span class="line">        tArgs.processor(processor);</span><br><span class="line">        TServer server = <span class="keyword">new</span> TSimpleServer(tArgs);</span><br><span class="line">        server.serve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>Client实现</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 客户端，连接服务器，并且发送消息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> TTransportException, TException </span>&#123;</span><br><span class="line">        TTransport transport = <span class="keyword">new</span> TSocket(<span class="string">"127.0.0.1"</span>, <span class="number">9090</span>, <span class="number">3000</span>);</span><br><span class="line">        TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">        HelloWorldService.Client client = <span class="keyword">new</span> HelloWorldService.Client(protocol);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transport.open();</span><br><span class="line">            String result = client.say(<span class="string">"Ray"</span>);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != transport) &#123;</span><br><span class="line">                transport.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
一个简单的 Thrift 的服务也就实现了。</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>thrift</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之依赖注入</title>
    <url>/2020/02/02/Spring%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>Spring 中所有的 Bean 都是通过容器来进行管理的。每个 POJO 都可以是一个 Spring Bean。容器会管理 Bean 的依赖关系，这种依赖关系有可能是 Bean 之间的，也有可能是 Bean 对配置数据的依赖。在使用 Spring 的时候，开发者需要做的就是让 Spring 容器知道这些依赖关系，然后剩下的事情交给 Spring 容器就行了。</p>
<p><img src="spring-container.png" alt=""></p>
<p>Spring 容器在初始化的时候会做两件事，将配置中的所有 POJO 加载进容器生成 Bean 并且注入 Bean 之间的依赖关系。配置 Bean 之间的依赖关系就是我们所说的<strong>依赖注入</strong>，需要注意的是这个生成 Bean 和依赖注入之间并不存在<strong>严格的</strong>先后关系，具体下面再说。</p>
<h2>Bean 的配置</h2>
<p>如果我们想让 Spring 来管理 Bean，第一步就是要将这些 Bean 装入容器中。把 Bean 装入容器中的方式有三种：</p>
<ul>
<li>使用 xml 配置文件</li>
<li>使用注解78</li>
<li>使用 Java 代码</li>
</ul>
<p>这三种方式完成的效果都一样，而且这三种方式可以<strong>混合使用</strong>。在下面我会主要使用 xml 的方式来作为例子来进行演示，因为 xml 配置文件相对比较直观，也会提供注解版本和 Java 代码版本的例子。</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gun</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span> </span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"gun"</span> name=<span class="string">"gun1,gun2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.springcontainer.Gun"</span>&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>在上面的配置文件中，我们创建一个 xml 配置文件，其中 xml 根元素是 <code>beans</code>，然后里面有一个 <code>bean</code> 元素，这就是一个 Spring Bean。上面配置文件的意思就是告诉容器，我有一个名字叫做 <code>Gun</code> 的 Java 类，现在交给你管理了，就这么简单。</p>
<p>上面 XML Bean 的配置中有 id，name，class 等几个属性。其中 class 很简单，就是类的全限定名称，这个相当于告诉 Spring 容器要创建哪个类的实例。id 和 name 都是用来标识一个 Bean 的唯一性。每个 Bean 的 id 在容器中只能是唯一的，而 name 则可以有多个，每个 name 使用 <code>,</code>、<code>;</code> 或者空格来隔开，id 的命名需要符合 XML 的命名规范，也就是不能使用特殊字符，但 name 则可以使用特殊字符来进行命名，如果没有定义 id，则会把 name 的第一个值定为 id，如果 id 和 name 都没有定义，则使用类全名加上数字编号来作为 id。获取 bean 的时候，可以通过如下的方式获取:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">Gun gun1 = (Gun) context.getBean(<span class="string">"gun1"</span>);</span><br><span class="line">Gun gun = (Gun) context.getBean(<span class="string">"gun"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(gun == gun1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>在实际使用 Spring 的过程中是不会使用上面的方式来使用 Bean，都会通过依赖注入的方式来获取。</p>
<p>使用注解如何配置呢，使用注解的配置如下：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gun</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span> </span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"cn.rayjun.springdemo"</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码与完全使用 xml 配置的效果相同，你可能会想，这样更麻烦了，其实不是，在 xml 中添加 <code>context:component-scan</code> 之后，<code>cn.rayjun.springdemo</code> 包下所有被 @Component 注解的类都会自动添加到容器中。也就是 xml 中就不再需要 &lt;bean&gt; 这个标签了，如果想把 xml 从代码中完全剔除掉上面的代码可以写成这样：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gun</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"cn.rayjun.springdemo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoldierConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了 @Component 注解之外，还有 @Repository, @Service, @Controller 等注解，@Repository 主要用来标识数据层，@Service 主要用来标识 Service 层，@Controller 主要用来标识 Controller 层。这些注解其实并没有什么不同，这么做只是为了让代码的分层更加清晰，这些注解都可以使用 @Componenet 替代。@Repository注解的实现如下:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repository &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(</span><br><span class="line">        annotation = Component.class</span><br><span class="line">    )</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上 @Repository 等注解就是使用 @Component 注解实现的。Spring 号称是无侵入性的，但是上面的代码却在 Gun 类上添加了 @Component 的注解，虽然不影响代码的功能，但还是稍微有点侵入性的，下面是终极的方案:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gun</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoldierConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gun <span class="title">gun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里使用带 @Configuration 的配置类完全替代 XML，这样一来，代码中没有 XML，通过也做到了对代码真正的无侵入性。</p>
<p>上面是将代码放入到容器中的三种方法，这三种方法不是独立存在的，而是可以混用的。这三种配置各有各的好处，XML 让 Bean 之间的依赖很清晰，而且不用修改源码；注解可以基本消除掉配置文件，但是这样代码中就会充斥各种注解；Java 配置则可以完全替代 XML。</p>
<h2>依赖注入</h2>
<p>在上面我们说生成 Bean 和依赖注入不存在严格的先后关系，这是因为 DI有两种方式：<strong>构造方法参数注入</strong> 和 <strong>Setter 方法注入</strong>。如果是构造参数注入，那么在 Bean 生成对象的时候就需要将依赖注入，如果是 Setter 方法注入，则是在 Bean 对象生成之后才会注入。</p>
<p>下面来看看如何进行依赖注入，先来看 XML 版本：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法注入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span> xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"gun"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.springcontainer.Gun"</span>&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=<span class="string">"solider"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.springcontainer.Soldier"</span>&gt;</span><br><span class="line">        &lt;constructor-arg name=<span class="string">"weapon"</span> ref=<span class="string">"gun"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
使用构造方法注入时，需要在构造方法的参数上声明所需要的依赖，然后在 XML 配置中通过 <code>&lt;constructor-arg/&gt;</code> 将依赖注入。再来看看 Setter 方法注入:</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setter 方法注入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeapon</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span> xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"gun"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.springcontainer.Gun"</span>&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"solider"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.springcontainer.Soldier"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"weapon"</span> ref=<span class="string">"gun"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>首先 Solider 中需要有待注入依赖的 Setter 方法，然后在 XML 配置中通过 <code>&lt;property/&gt;</code> 来进行注入。那么构造参数注入和 Setter 方法注入怎么选呢？官方的推荐的做法是：<strong>如果依赖关系是强依赖时，使用构造参数注入，如果是可选依赖，则使用 setter 进行注入。强依赖可以理解为当前这个 Bean 正常运行所必须的依赖</strong>。</p>
<p>下面再来看看注解的是如何来进行依赖注入的，先看下面这段代码，下面的这段代码使用的是构造函数参数注入的方式：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Knife</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gun</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了使用构造函数参数注入之外，还可以使用 Setter 方法注入和成员变量注入，这些注入方式的效果都一样:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Setter 方法注入</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeapon</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有成员变量注入</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，我们使用的是 @Autowired 来进行注入，也可以使用 @Inject 来进行依赖注入。这两个注解是等价的，可以在代码中互相替换，但是推荐在整个项目中保持统一。如果项目的依赖比较复杂，那么代码中就会充斥着这些注解，这也是使用注解配置的问题，大量的这样的注解会让代码不好管。注解使用是最便利的，但也是最难管理的。</p>
<p>还有最后一种注入方式，使用 Java 代码进行注入：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoldierConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gun <span class="title">newGun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Knife <span class="title">newKnife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Knife();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Soldier <span class="title">newSoldier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用构造方法参数注入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Soldier(newGun());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Soldier <span class="title">newSoldier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 Setter方法参数注入</span></span><br><span class="line">        Soldier s = <span class="keyword">new</span> Soldier();</span><br><span class="line">        s.setWeapon(newGun());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@ComponentScan 注解用来配置需要扫描的包的范围，被 @Bean 注解的方法表示会得到一个返回类型的 Bean，然后可以直接通过调用相应方法为 Bean 注入依赖。使用 Java 配置的好处是即可以不使用 XML 配置文件，又不会对代码有侵入。上面的代码中都是类之间的依赖，如果依赖的是普通的字面量或者一些容器类型，也可以进行注入，注入的方式如下：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"soldier"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.container.Soldier"</span> &gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"Tom"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"age"</span> value=<span class="string">"12"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>配置的 value 会根据 Bean 中成员的类型自动进行转换。还可以注入容器类型的值：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"soldier"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.container.Soldier"</span> &gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"Tom"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"age"</span> value=<span class="string">"12"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"foods"</span>&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;apple&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;orange&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;banana&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h2>依赖冲突</h2>
<p>Soldier 中需要注入一个 Weapon 类型的 Bean，现在 Gun 和 Knife 都实现了 Weapon，采用上面的方式注入时，就会报 <code>UnsatisfiedDependencyException</code> 异常，因为容器无法决定要注入哪一个。解决的方法有三种：</p>
<ul>
<li>@Primary 注解</li>
<li>@Qualifier 注解</li>
<li>自定义注解</li>
</ul>
<p>被 @Primary 注解的 Bean 会被优先注入，这样就不会报错：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Knife</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gun</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还可以使用 @Qualifier 来明确告诉容器使用的是哪个 Bean。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(@Qualifier(<span class="string">"gun"</span>)</span> Weapon weapon) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"knife"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Knife</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"gun"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gun</span> <span class="keyword">implements</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自定义注解稍微复杂点，后续再写文章来说明。</p>
<h2>循环依赖</h2>
<p>//循环依赖图</p>
<p>在一些情况下，会出现循环依赖，虽然这种情况比较少，但还是有可能会出现.</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassB classB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassA</span><span class="params">(ClassB classB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classB = classB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassA classA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassB</span><span class="params">(ClassA classA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classA = classA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"classB"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.springcontainer.cycle.ClassB"</span>&gt;</span><br><span class="line">    &lt;constructor-arg name=<span class="string">"classA"</span> ref=<span class="string">"classA"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"classA"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.springcontainer.cycle.ClassA"</span>&gt;</span><br><span class="line">    &lt;constructor-arg name=<span class="string">"classB"</span> ref=<span class="string">"classB"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果按照上面的配置，启动的时候会报 UnsatisfiedDependencyException 异常，这就是循环依赖，解决的办法也很简单，就是把构造方法注入改成 Setter 方法注入。</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassB classB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassB</span><span class="params">(ClassB classB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classB = classB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassA classA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassA</span><span class="params">(ClassA classA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classA = classA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;bean id=<span class="string">"classB"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.springcontainer.cycle.ClassB"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"classA"</span> ref=<span class="string">"classA"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"classA"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.rayjun.springdemo.springcontainer.cycle.ClassA"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"classB"</span> ref=<span class="string">"classB"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>改成 Setter 方法之后就可以注入成功了，原因就是构造函数注入和 Setter 方法注入的时机不同，构造函数需要在生成对象的时候就注入，这是 ClassA 和 ClassB 就产生了鸡生蛋还是蛋生鸡的问题。而 Setter 方法注入这是在生成对象之后，那就可以成功注入了。</p>
<p>Spring 容器的内容很多，上面仅仅介绍了 Spring 最核心的部分，这是 Spring 容器构建的基础，下一篇会详细介绍 Spring 的另一大特性 AOP。关于容器的一些语法细节可以去查询官方文档。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之如何优雅的构建Demo环境</title>
    <url>/2020/02/08/Spring%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E6%9E%84%E5%BB%BADemo%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>在最开始学习 Java 的时候，最常用的方式就是写一个 main 方法，然后在这个方法中不断写代码，然后跑起来。通常这样也不会有问题，但是这难免有点不优雅，毕竟一个类只能有一个 main 方法。</p>
<h2>如何优雅的写 Demo</h2>
<p>特别是要系统学习一些框架的时候，通常需要写大量的示例代码。使用 main 方法时，很多代码写过一遍后就得删除或者注释掉，回头想重新看这个例子的时候就得重新写。</p>
<p>总的来是，直接在 main 中写 Demo 代码有如下的问题：</p>
<ul>
<li>一个类只能有一个 main 方法</li>
<li>一次只能执行一个 main 方法</li>
<li>每次改变 demo 逻辑都需要修改现有代码</li>
</ul>
<p>其实 Java 中已经提供了一个很好的工具来解决这个问题，没错，就是 JUnit。使用 JUnit 来写 Demo 代码有如下的好处：</p>
<ul>
<li>JUnint 配置简单，添加一个 jar 包，不需要添加额外配置</li>
<li>一个类中可以写任意多个测试用例，每个测试用例可以单独运行或者组合运行</li>
<li>每个测试用例都可以重新运行</li>
</ul>
<p>这样就可以很好的管理写过的 Demo，在必要的时候，都可以拿出来复习。更重要的是可以通过这种方式来培养写单元测试的意识，毕竟，写软件终究要回归到精雕细琢，那么单元测试就是一大利器。</p>
<blockquote>
<p>本文基于 JUnit5，Spring5，Maven3.6</p>
</blockquote>
<h2>使用 JUnit 写 Spring Demo</h2>
<p>下面来看一下如何使用 JUnit 快速的搭建一个 Spring 的 Demo 环境。</p>
<p>我们使用 Maven 作为构建工具，创建一个 maven 的普通项目后，需要引入相关的依赖。</p>
<blockquote>
<p>在这里我只引入了 Spring5 的核心依赖，如果有需要，可以自行引入其他的依赖</p>
</blockquote>
<h3>引入依赖</h3>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;spring.version&gt;5.2.2.RELEASE&lt;/spring.version&gt;</span><br><span class="line">    &lt;junit5.version&gt;5.1.0-M2&lt;/junit5.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;junit5.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p>
<p>除了引入 spring-test 之外，还需要引入 JUnit，因为 spring-test 依赖 Junit。</p>
<p>然后项目的基本结构如图：</p>
<p><img src="struct.png" alt=""></p>
<p>在 test 目录下创建一个包，和源码码包名保持一致，然后就可以开始写测试代码了。</p>
<h3>启动 Spring 容器</h3>
<p>启动 Spring 项目的关键在于启动 Spring 容器，在单元测试从也一样，这里分别演示一下 XML 版本和 Java 配置版本。</p>
<p><strong>XML版</strong>：</p>
<p>首先在 <strong>resources 目录</strong>下创建一个 beans.xml 配置文件（文件名称可以随便起）：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.rayjun.spring5demo"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>加了 <code>component-scan</code> 来扫描基本的包，该包下的 bean 会被 Spring 容器自动加载并初始化。</p>
<p>容器的配置创建好了，然后就需要在测试类中用如下的方式加载了：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:beans.xml"</span>)</span><br><span class="line"><span class="meta">@SpringJUnitConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest1</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>@SpringJUnitConfig</code> 注解是 Spring 增强过了的，加上这个注解之后，就可以在单元测试中很方便的使用 Spring 的特性。</p>
<p><code>@ContextConfiguration</code> 用来加载 Spring 容器的配置文件，除了可以加载 XML，还可以加载 Java 配置。</p>
<p>这样就完成容器的初始化了。</p>
<p><strong>Java 版</strong></p>
<p>创建一个 Java 类来充当配置文件，位置放在哪里都行：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"cn.rayjun.spring5demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoldierConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>@Configuration</code> 表明这个类是一个配置类。<code>@ComponentScan</code> 与 XML 配置中的 <code>component-scan</code> 作用一样。</p>
<p>然后同样在测试用例中启动容器：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(classes = SoldierConfig.class)</span><br><span class="line"><span class="meta">@SpringJUnitConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest2</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样，就算是配置好了。</p>
<h3>编写第一个测试用例</h3>
<p>容器相关的配置已经准备好了，接下来来编写第一条测试用例：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:beans.xml"</span>)</span><br><span class="line"><span class="meta">@SpringJUnitConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Gun gun;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assertions.assertNotNull(gun);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码我们发现，可以直接通过注入的方式来注入相关的依赖。比如 Gun 类，只要在配置中声明好，然后就可以在测试用用例使用。甚至可以通过这种方式获取到容器本身：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:beans.xml"</span>)</span><br><span class="line"><span class="meta">@SpringJUnitConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Gun gun = (Gun) context.getBean(<span class="string">"gun"</span>);</span><br><span class="line">        Assertions.assertNotNull(gun);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样，就可以很方便的测试容器中的任何代码，通过单元测试还可以判断代码质量。如果很难为一段代码写单元测试，那说明这段代码和某些依赖耦合的很紧。因为在 Spring 容器中，核心都是通过依赖注入的方式来管理依赖，如果某项依赖无法通过依赖注入，可能就要考虑一下代码是否有问题了。</p>
<h3>高阶用法</h3>
<p>除了这些之外，有时候还会有一些复杂的情况，比如涉及到 Web，数据库方面测试。</p>
<p>spring-test 提供了 Web 测试的一样方法，来模拟接口或者 web 页面的访问。然后对于其他的一些异常情况的模拟，比如网速慢，真实环境难以搭建等等问题，就需要使用 Mock 的方式来模拟这些情况，就需要 再引入一些其他的依赖，这些回头再用新的文章来说明。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim搜索神器fzf</title>
    <url>/2020/12/13/Vim%E6%90%9C%E7%B4%A2%E7%A5%9E%E5%99%A8fzf/</url>
    <content><![CDATA[<p>在上一篇文章中，介绍了命令行神器 fzf 的使用，这个工具不止能在命令行使用，还可以在 vim 中使用。</p>
<p>vim 编辑器的功能很强大，但是在项目的文件管理方面却有点弱，缺乏有效的文件搜索功能，这点与 emacs 比起来就差太多了。</p>
<p>但是 fzf 插件能够帮助 vim 补足一下短板。</p>
<p>本文基于 macOS Big Sur 11.0.1，macVim8.2</p>
<h2>1. 安装</h2>
<p>vim 的安装不再赘述，使用 Homebrew 或者直接下载安装包进行安装。</p>
<p>在安装 fzf 之前，需要先安装一下 vim 的插件管理工具，当前比较主流的管理工具有 Vundle 以及 vim-plug，这里我们使用的是后者。</p>
<p>vim-plug 的安装很简单：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/<span class="built_in">autoload</span>/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure></p>
<p>完成之后就可以安装插件了，在这里只演示安装 fzf 的插件，在 home 目录下新建一个 .vimrc 文件，然后在文件中填入以下内容:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">call plug<span class="comment">#begin('~/.vim/plugged')</span></span><br><span class="line"></span><br><span class="line">Plug <span class="string">'junegunn/fzf'</span>, &#123; <span class="string">'do'</span>: &#123; -&gt; fzf<span class="comment">#install() &#125; &#125;</span></span><br><span class="line">Plug <span class="string">'junegunn/fzf.vim'</span></span><br><span class="line"></span><br><span class="line">call plug<span class="comment">#end()</span></span><br></pre></td></tr></table></figure></p>
<p>使用 :PlugInstall 对进行安装，如下表示安装完成。</p>
<p><img src="1.png" alt=""></p>
<h2>2. 使用</h2>
<p>为了更好的使用 fzf 插件在使用之前，还需要做一个简单的配置，为了在打开文件后，能够准确的找到工作目录所在，需要在 .vimrc 中加上如下配置:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> autochdir <span class="comment"># 自动切换工作目录</span></span><br><span class="line"></span><br><span class="line">call plug<span class="comment">#begin('~/.vim/plugged')</span></span><br><span class="line"></span><br><span class="line">Plug <span class="string">'junegunn/fzf'</span>, &#123; <span class="string">'do'</span>: &#123; -&gt; fzf<span class="comment">#install() &#125; &#125;</span></span><br><span class="line">Plug <span class="string">'junegunn/fzf.vim'</span></span><br><span class="line"></span><br><span class="line">call plug<span class="comment">#end()</span></span><br></pre></td></tr></table></figure></p>
<p>vim 中的命令与命令行稍微有点差别，对 fzf 的使用做了一些简单的封装，这样就不用做更多的配置。</p>
<p>核心的命令其实就一个 <code>:Files [path]</code></p>
<p>使用这个命令之后，就会把目标目录下所有的文件（包括子目录）以一个小窗口的形式展现出来，而且带预览功能。</p>
<p><img src="2.png" alt=""></p>
<p>同样使用 CTRL-J 和 CTRL-K 对文件进行选择，直接对文件名称进行回车会在当前窗口窗口打开文件，可以使用 CTRL-T 以新 tab 的形式打开文件，CTRL-X 以水平分屏的形式打开文件，CTRL-V 垂直分屏的形式打开文件。</p>
<p>对于已经打开的文件，可以使用 <code>:Buffers</code> 来进行查看，操作和打开文件的方法与 :Files 命令一样。</p>
<p>甚至还与 git 做了一定程度的结合，使用 <code>:GFiles</code>  来查看 git 文件，相当于 <code>git ls-files</code>。使用 <code>:GFiles?</code> 查看 git 状态，相当于 <code>git status</code>。</p>
<p>还可以使用 <code>:Colors</code> 来为 vim 切换主题。</p>
<p>有了上面的这些功能之后，vim 在操作文件上面就很强了，算是补足了 vim 的一个弱点。</p>
<p>上面的功能基本已经够用了，fzf 的 vim 插件也还有不少高阶的用法，感兴趣的可以自行查看文档。</p>
<p>文 / Rayjun</p>
<h2>REF</h2>
<p>[1] <a href="https://github.com/junegunn/fzf.vim" target="_blank" rel="noopener">https://github.com/junegunn/fzf.vim</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之面向切面编程</title>
    <url>/2020/02/15/Spring%E7%B3%BB%E5%88%97%E4%B9%8B%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>面向切面编程（AOP）是 Spring 的另外一大核心，但 Spring 容器与 AOP 却不耦合，这意味着如果不需要 AOP，就不需要引入相关依赖。</p>
<p>Spring 中引入 AOP 主要用于两个方面：</p>
<ul>
<li>提供声明式企业级服务，比如声明式事务管理</li>
<li>让 Spring 的用户可以在面向对象编程中（OOP）使用面向切面编程（AOP）</li>
</ul>
<p>通过下面这张图就可以表现 AOP 的核心之处。正常的逻辑代码都是从上往下写的，是纵向的。而 AOP 则是在这些纵向的代码中插入一个切面，在这个切面里面假如一些逻辑，这些代码是横向的，这样就不会影响现有的逻辑。</p>
<p><img src="aop.png" alt=""></p>
<h2>AOP 的基本概念</h2>
<p>在第一篇文章里面，简单介绍了一些 AOP 的相关概念。这里使用日志这个例子，来详细的说明 AOP 的概念。</p>
<p>看下面这段代码，现在有一个 Soldier 类，类中有一个 fight 方法，这个类就是上图中的黄色部分，正常的逻辑代码，现在有一个需求，要记录下 fight 过程，正常来说，当然也可以在 fight 中使用 Logger 来记录日志，带上这样就需要修改原有的代码，而且代码中会充斥着各种记录日志的代码。</p>
<p>这个问题可以使用 AOP 来解决，FightLog 就是上图中的紫色部分，这些代码不会影响到原有的逻辑，却可以完成记录 fight 日志的功能。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weapon weapon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Soldier</span><span class="params">(Weapon weapon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        weapon.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FightLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* cn.rayjun.spring5demo.container.Soldier.fight(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightLogBefore</span><span class="params">(JoinPoint j)</span> </span>&#123;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        System.out.println(<span class="string">"FightBefore"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightLogAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FightAfter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightLogReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FightReturn"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightLogThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FightThrowing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightAround</span><span class="params">(ProceedingJoinPoint pr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"FightAroundBefore"</span>);</span><br><span class="line">            pr.proceed();</span><br><span class="line">            System.out.println(<span class="string">"FightAroundAfter"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"FightAroundThrowing"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"FightAround"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的 FightLog 中，有 @Aspect，@Before，@After 这些注解都代表中特定的概念。</p>
<p>AOP 中的关键概念如下：</p>
<ul>
<li>切面（Aspect）</li>
<li>连接点（Join point）</li>
<li>切点（Pointcut）</li>
<li>通知（Advice）</li>
<li>引入（Introduction）</li>
<li>织入（Weaving）</li>
</ul>
<p>如果只看上面这些概念绝对让人很头疼，但是实际上，这些概念并不难，需要重点理解的也就切面、切点、通知三个。下面来详细看一下每个概念。</p>
<p><strong>切面</strong>
切面其实很简单，就是上面图中的紫色部分，代表着一个单独的类，使用 @Aspect 注解（当然也可以使用 xml 配置）来定义。在这个类中可以定义一系列操作，这些操作就是由切点和通知组成，新加的这些操作不会影响原有的代码。</p>
<p><strong>连接点和切点</strong>
其实连接点和切点表达的是同样的东西。如下图：</p>
<p><img src="pointcut.png" alt=""></p>
<p>在正常的逻辑代码中调用方法，修改属性的操作都可以作为一个连接点，这个连接点可以作为<strong>切面</strong>的<strong>切点</strong>。现在明白了，被切面所切入的连接点就叫做切点。</p>
<p>在使用 AOP 的过程中，可以在切点上获取连接点的所有信息，包括方法名称，参数等等。</p>
<p><strong>通知</strong>
通知更好理解，通知就是在切点中进行的操作，通知有如下的种类：</p>
<ul>
<li>@Before: <strong>前置通知</strong>，在进入切点之前执行</li>
<li>@AfterReturning: <strong>返回通知</strong>，在切点正常返回后执行</li>
<li>@AfterThrowing: <strong>异常通知</strong>，在切点抛出异常后执行</li>
<li>@After: <strong>后置通知</strong>，在正常执行或者抛出异常后都会执行</li>
<li>@Around: <strong>环绕通知</strong>，这个比较特殊，这个通知方法会影响正常逻辑代码的执行，如果要使用这个通知，就必须要调用 ProceedingJoinPoint 的 proceed 方法才不影响正常的逻辑代码的执行。</li>
</ul>
<p><strong>引入和织入</strong></p>
<p>这两个概念了解一下就可以，引入是指可以向现有的类添加新方法或者属性，织入则是把切面应用到目标方法并创建新的代理对象的过程。</p>
<p>这亮光概念涉及到 AOP 底层的实现，后续再详细说明。</p>
<blockquote>
<p>Spring AOP 默认是使用 JDK 的动态代理来实现，如果有必要，也款已换成 CGLIB 代理来实现。</p>
</blockquote>
<h2>AOP 的配置及使用</h2>
<p>Spring 容器默认是不启用 AOP 的，使用 AOP 需要引入额外的依赖，如下：
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>同样，AOP 可以通过 xml 配置和 Java 配置。</p>
<p>XML 配置如下，只需要加上 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 这个配置即可。</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">       https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"cn.rayjun.spring5demo"</span> /&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>Java 配置更加简单，只需要加上 @EnableAspectJAutoProxy 注解就可以了。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"cn.rayjun.spring5demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoldierConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置完成之后就可以定义切面，任意一个类，被 @Aspect 注解之后就可以作为一个切面了。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FightLog</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在定义好了切面之后，就可以定义切点来实现自定义的功能了，从上面我们知道了切点就是被选择的连接点，定义一个切点的方式如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* cn.rayjun.spring5demo.container.Soldier.fight(..))</span><br></pre></td></tr></table></figure></p>
<ul>
<li>excution 表示这个切点的操作在连接点方法执行时触发。</li>
<li><code>*</code> 表示返回任意的类型，就是对这个连接点方法的返回值没有要求</li>
<li>中间就是连接点的全路径</li>
<li><code>..</code> 表示的是对输入参数也没有要求，可以接受任意参数</li>
</ul>
<p>这样一来，方法名称是 fight，以及这个方法的多个重载方法都可以被该切点切入。</p>
<p>切点定义好了之后就需要给这个切点自定义操作：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(* cn.rayjun.spring5demo.container.Soldier.fight(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightLogBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"FightBefore"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假如说这个切点要在多个通知上被使用，可以用如下的定义：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* cn.rayjun.spring5demo.container.Soldier.fight(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightLogBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"FightBefore"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightLogAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"FightAfter"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面说到了切点就是被选择的连接点，假如说现在需要在切点中获取连接点的一些信息和状态，直接就可以在切点中加上一个 JoinPoint 的参数，这个就表示连接点，通过这个连接点就可以做一些有意义的操作，根据当前连接点的状态来做一些操作，比如记日志，做统计</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightLogBefore</span><span class="params">(JoinPoint j)</span> </span>&#123;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    System.out.println(<span class="string">"FightBefore"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后还需要说明的是环绕通知，这个比较特殊，这个通知的囊括了之前说的所有的通知，在这个通知中如果不调用 ProceedingJoinPoint 的 procceed 方法，原有的正常逻辑就无法执行，但是它的强大之处在于可以在这里自由的实现上述的各种通知，如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fightAround</span><span class="params">(ProceedingJoinPoint pr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"FightAroundBefore"</span>);</span><br><span class="line">        pr.proceed();</span><br><span class="line">        System.out.println(<span class="string">"FightAroundAfter"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"FightAroundThrowing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"FightAround"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AOP 是 Spring 重要的组成部分，除了生僻的概念比较多，其他的也不是很复杂。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java spring</tag>
      </tags>
  </entry>
  <entry>
    <title>container 包详解</title>
    <url>/2021/08/30/container-%E5%8C%85%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Go 语言中有一个 container 包，如果只是看这个包名，可能很容易让人误解，但这个 container 和  Docker 之类的容器没有关系，这个容器是指提供的代码</p>
<p>在 container 包中，有三种开箱即用的数据结构，可以直接使用，分别是 heap、list 和 ring。</p>
<h2>heap</h2>
<p>heap 中提供了一个<strong>堆</strong>的实现，可以直接使用。如果想创建一个堆，只需要先实现一些方法，这里以整数堆为例：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的实现中，没有对堆的实现，因为 heap 包已经把这些实现抽象出来了，在使用的时候，只需要自己实现堆中数据比较大小的逻辑。上面的代码写完之后，就可以来初始化并使用堆：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h) <span class="comment">// 初始化堆</span></span><br><span class="line"></span><br><span class="line">heap.Push(h, <span class="number">3</span>) <span class="comment">// 入堆</span></span><br><span class="line">heap.Pop(h) <span class="comment">// 出堆，拿出堆顶的第一个元素</span></span><br></pre></td></tr></table></figure></p>
<p>在 Go 的官方文档中，甚至使用 heap 包实现了一个优先级队列，如果在业务场景中有这个需求，都可以直接使用了。具体见：<a href="https://golang.google.cn/pkg/container/heap/" target="_blank" rel="noopener">https://golang.google.cn/pkg/container/heap/</a></p>
<h2>list</h2>
<p>list 是一个双向链表的实现，这个数据结构的使用就更简单了，开箱即用：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">l := list.New()  <span class="comment">// 创建一个双向链表</span></span><br><span class="line">e4 := l.PushBack(<span class="number">4</span>) <span class="comment">// 从后面加入元素</span></span><br><span class="line">e1 := l.PushFront(<span class="number">1</span>) <span class="comment">// 从前面加入元素</span></span><br><span class="line">l.InsertBefore(<span class="number">3</span>, e4) <span class="comment">// 在某个元素之前插入</span></span><br><span class="line">l.InsertAfter(<span class="number">2</span>, e1) <span class="comment">// 在某个元素之后插入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照链表的顺序，从前向后遍历</span></span><br><span class="line"><span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">	  fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>ring</h2>
<p>ring 这个数据结构有点特殊，是一个环状的双向链表，这个数据结构在有些场景下很有用，比如用作任务队列。</p>
<p>这个结构有个好处是内存在初始化的时候申请一次就可以了，其中的内存式可以重复利用了。</p>
<p>使用起来也比较方便，可以使用 Next 和 Prev 方法去获取前面和后面的元素:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := ring.New(<span class="number">5</span>) <span class="comment">// 创建一个大小为 5 的ring</span></span><br><span class="line"></span><br><span class="line">n := r.Len() <span class="comment">// 获取 ring 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 ring 中填充数据</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">	r.Value = i</span><br><span class="line">	r = r.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 ring 中的数据</span></span><br><span class="line">r.Do(<span class="function"><span class="keyword">func</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(p.(<span class="keyword">int</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>ring 中还提供了两个特殊的方法：Link 和 UnLink。</p>
<p>Link 方法可以把两个 ring 连接起来:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := ring.New(<span class="number">2</span>)</span><br><span class="line">s := ring.New(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">lr := r.Len()</span><br><span class="line">ls := s.Len()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lr; i++ &#123;</span><br><span class="line">	r.Value = <span class="number">0</span></span><br><span class="line">	r = r.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; ls; j++ &#123;</span><br><span class="line">	s.Value = <span class="number">1</span></span><br><span class="line">	s = s.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs := r.Link(s)</span><br><span class="line"></span><br><span class="line">rs.Do(<span class="function"><span class="keyword">func</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(p.(<span class="keyword">int</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>UnLink 方法是从 ring 摘除调一些节点，Unlink 的参数是整数 n ，表示从 <a href="http://r.Next" target="_blank" rel="noopener">r.Next</a> 开始，摘除三个元素:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := ring.New(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">n := r.Len()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">	r.Value = i</span><br><span class="line">	r = r.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.Unlink(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">r.Do(<span class="function"><span class="keyword">func</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(p.(<span class="keyword">int</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>cglib入门前篇</title>
    <url>/2020/10/30/cglib%E5%85%A5%E9%97%A8%E5%89%8D%E7%AF%87/</url>
    <content><![CDATA[<p>cglib 是一个功能强大、高性能、高质量的<strong>字节码操作库</strong>，主要用于在运行时扩展 Java 类或者根据接口生成对象。</p>
<p>cglib 在一些开源框架中使用很广泛，比如 Spring， 数据库开源库 Hibernate，以及测试框架 mockito。正是因为 cglib 把脏活累活都干了，这些框架使用才很方便。</p>
<p>这是一个开源的库，cglib 本身的实现基于 asm 库。相比于 asm 库，cglib 的接口更友好，使用起来更简单。</p>
<p>下面介绍 cglib 的主要接口和类以及基于 cglib 的动态代理实现。</p>
<p>本文基于 OpenJDK11</p>
<h2>1. Enhancer</h2>
<p>首先要说到的就是 Enhancer 这个类，这个是 cglib 中使用的最多的类。之前  JDK 中使用反射来实现动态代理时，必须要基于<strong>接口</strong>来生成动态代理类，而 Enhancer 可以直接基于类来代理类。</p>
<p>Enhancer 可以生成被代理类的子类，并且拦截所有方法的调用，也就是通常所说的<strong>增强</strong>。</p>
<p>需要注意，Enhancer 不能增强构造函数，也不能增强被 final 修饰的<strong>类</strong>，或者被 static 和 final 修饰的<strong>方法</strong>。</p>
<p>如果不想直接生成一个对象，cglib 也可以生成一个 Class 对象，用这个 Class 对象生成对象或者其他操作。</p>
<p>Enhancer 的使用分为两步，传入目标类型，设置回调。支持不同类型回调是 cglib 最强大的地方。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(HelloImpl.class);</span><br><span class="line"><span class="comment">//enhancer.setInterfaces(HelloImpl.class.getInterfaces()); // 也可以使用接口</span></span><br><span class="line">enhancer.setCallback(...); <span class="comment">// 设置回调</span></span><br></pre></td></tr></table></figure></p>
<p>在 Enhancer 创建一个代理类之后所实现的行为要通过这些回调来实现。</p>
<p>常见的的回调类型如下：</p>
<ul>
<li>FixedValue：返回一个固定的值</li>
<li>InvocationHandler：增强方法，添加额外的功能</li>
<li>MethodInterceptor：与 InvocationHandler 功能类似，但是控制的权限更多</li>
<li>LazyLoader：可以延迟加载被代理的对象，而且每个对象只会被创建一次</li>
<li>Dispatcher：与 LazyLoader 功能基本相同，但是在获取对象时，每次都会创建不同的对象</li>
<li>ProxyRefDispatcher：与 Dispatcher 功能类似，但是会多一个被代理对象的参数</li>
<li>NoOp：什么也不做</li>
</ul>
<h3>FixedValue</h3>
<p>对于 FixedValue 类型的回调，调用所有的方法都会返回这个固定的值，如果类型不匹配，就会报错。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(HelloImpl.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello cglib"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello cglib"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">HelloImpl proxy = (HelloImpl) enhancer.create();</span><br><span class="line">proxy.sayHello(<span class="string">"ray"</span>); <span class="comment">// 会打印 Hello cglib</span></span><br></pre></td></tr></table></figure></p>
<p>除了 static 和 final 类型的方法，其他所有的方法都会执行上面的代码，打印 <code>Hello cglib</code>。但是需要注意的是，如果某个方法返回的类型和上面的代理行为不一致就会报错，java.lang.Object 中的方法也是一样。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proxy.hashCode(); <span class="comment">// java.lang.ClassCastException</span></span><br></pre></td></tr></table></figure></p>
<h3>InvocationHandler</h3>
<p>看到这个是不是很熟悉，这个与 JDK 反射自带的 InvocationHandler 基本一致。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(HelloImpl.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getReturnType() == String.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello cglib"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello cglib"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Invoke other method"</span>);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(proxy, objects); <span class="comment">// 这里可能会出现无限循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">HelloImpl proxy = (HelloImpl) enhancer.create();</span><br><span class="line">proxy.sayHello(<span class="string">"ray"</span>);</span><br></pre></td></tr></table></figure></p>
<p>只想改变其中部分方法的行为，其他的方法还的行为不变，最简单的思路就是如果不是目标方法就会调用本来的实现，假设要调用 <code>hashcode()</code> 方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proxy.hashCode();</span><br></pre></td></tr></table></figure></p>
<p>这个代码并不会正常返回结果，而是进入无限循环，这是因为这个代理对象的每一个可以被代理的方法都被代理了，在调用被代理了的方法时，会重复进入到 <code>InvocationHandler#invoke</code> 这个方法中，然后进入死循环。</p>
<p>解决办法如下。</p>
<h3>MethodInterceptor</h3>
<p>在 MethodInterceptor 中，有一个 <code>MethodProxy</code> 参数，这个就可以用来执行父类方法。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(HelloImpl.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] params, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getReturnType() == String.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello cglib"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello cglib"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> methodProxy.invokeSuper(o, params); <span class="comment">// 对上面无限问题的改善</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">HelloImpl proxy = (HelloImpl) enhancer.create();</span><br><span class="line">proxy.sayHello(<span class="string">"ray"</span>);</span><br><span class="line">proxy.hashCode(); <span class="comment">// 这个时候，调用 hashcode 方法就可以正常工作了</span></span><br></pre></td></tr></table></figure></p>
<h3>LazyLoader</h3>
<p>用来延迟加载对象。</p>
<p>在下面这个例子中，使用 LazyLoader 来延迟加载一个 ArrayList 对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(ArrayList.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> LazyLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Begin invoke lazyloader"</span>);</span><br><span class="line">                ArrayList&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                data.add(<span class="string">"hello"</span>);</span><br><span class="line">                data.add(<span class="string">"cglib"</span>);</span><br><span class="line">                System.out.println(<span class="string">"End invoke lazyloader"</span>);</span><br><span class="line">                <span class="keyword">return</span> data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (ArrayList&lt;String&gt;) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HelloImpl helloImpl = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">ArrayList&lt;String&gt; data = helloImpl.getData(); <span class="comment">// 在调用这个方法的时候，ArrayList 不会被创建</span></span><br><span class="line">System.out.println(data.get(<span class="number">0</span>));</span><br><span class="line">System.out.println(data.get(<span class="number">1</span>)); <span class="comment">// 每次调用都使用同一个对象，不会重复创建对象</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码的执行结果如下:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Begin invoke lazyloader</span><br><span class="line">End invoke lazyloader</span><br><span class="line">hello</span><br><span class="line">cglib</span><br></pre></td></tr></table></figure></p>
<p>在执行 data.get(0) 的时候，ArrayList 才会被创建，也就是说只有在被使用的，才会去创建对象，而且每个对象只会被创建一次。</p>
<h3>Dispatcher</h3>
<p>Dispatcher 与 LazyLoader 的不同之处在于，每次去获取对象的时候都会创建一个新的对象，而不是复用同一个对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">getDataDispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(ArrayList.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> Dispatcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Begin invoke dispatcher"</span>);</span><br><span class="line">                ArrayList&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                data.add(<span class="string">"hello"</span>);</span><br><span class="line">                data.add(<span class="string">"cglib"</span>);</span><br><span class="line">                System.out.println(<span class="string">"End invoke Dispatcher"</span>);</span><br><span class="line">                <span class="keyword">return</span> data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (ArrayList&lt;String&gt;) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HelloImpl helloimpl = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">ArrayList&lt;String&gt; data = helloimpl.getDataDispatcher();</span><br><span class="line">System.out.println(data.get(<span class="number">0</span>));</span><br><span class="line">System.out.println(data.get(<span class="number">1</span>));<span class="comment">// 每次调用都会获取不同送的对象</span></span><br></pre></td></tr></table></figure></p>
<p>上面代理的执行结果如下，每次使用对象都会创建一个新的对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Begin invoke dispatcher</span><br><span class="line">End invoke Dispatcher</span><br><span class="line">hello</span><br><span class="line">Begin invoke dispatcher</span><br><span class="line">End invoke Dispatcher</span><br><span class="line">cglib</span><br></pre></td></tr></table></figure></p>
<h3>ProxyRefDispatcher</h3>
<p>ProxyRefDispatcher 与 Dispatcher 功能类似，但是多了一个参数，使用这个回调同样要注意无限循环的问题。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(HelloImpl.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> ProxyRefDispatcher() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">(Object proxy)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Invoke"</span>);</span><br><span class="line">        <span class="keyword">return</span> proxy.hashCode(); <span class="comment">// 同样可能会导致无限循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">HelloImpl proxy = (HelloImpl) enhancer.create();</span><br><span class="line">proxy.hashCode(); <span class="comment">// 这样调用会无限循环</span></span><br></pre></td></tr></table></figure></p>
<h3>NoOp</h3>
<p>这个回调什么也不做，会完全继承被代理类的功能，所以 NoOp 不能使用接口来创建代理，只能使用类。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(HelloImpl.class);</span><br><span class="line"><span class="comment">//enhancer.setInterfaces(HelloImpl.class.getInterfaces()); //不能使用接口，只能使用类</span></span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> NoOp() &#123;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Hello proxy = (Hello) enhancer.create();</span><br><span class="line">proxy.sayHello(<span class="string">"Ray"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个回调在一些特定的情况下还是挺有用的，看下面的例子。</p>
<h3>CallbackFilter</h3>
<p>在上面的例子中，都是给 Enhancer 设置了单个回调，其实每个 Enhancer 可以设置多个回调，这里就需要用到 <code>CallbackFilter</code>。</p>
<p>比如现在就需要对 <code>sayHello</code> 方法进行处理，其他的方法保持父类的行为就可以，按照这个要求，实现的 CallbackFilter 如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackHelperImpl</span> <span class="keyword">extends</span> <span class="title">CallbackHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallbackHelperImpl</span><span class="params">(Class superclass, Class[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(superclass, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getCallback</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName() == <span class="string">"sayHello"</span>) &#123; <span class="comment">// 对这个方法就行增强，其他的方法不改变</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Hello cglib"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Hello cglib"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// NoOp 就可以在这种情况下使用</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NoOp() &#123;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(HelloImpl.class);</span><br><span class="line">CallbackHelper callbackHelper = <span class="keyword">new</span> CallbackHelperImpl(HelloImpl.class, <span class="keyword">null</span>);</span><br><span class="line">enhancer.setCallbackFilter(callbackHelper);</span><br><span class="line">enhancer.setCallbackTypes(callbackHelper.getCallbackTypes());</span><br><span class="line">enhancer.setCallbacks(callbackHelper.getCallbacks());</span><br><span class="line"></span><br><span class="line">HelloImpl proxy = (HelloImpl) enhancer.create();</span><br><span class="line"></span><br><span class="line">proxy.sayHello(<span class="string">"Ray"</span>); </span><br><span class="line">proxy.hashCode(); <span class="comment">// 其他方法的调用不受影响</span></span><br></pre></td></tr></table></figure></p>
<p>调用结果如下，只有 sayHello 方法会被拦截，其他的方法不会有变动。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello cglib</span><br><span class="line"><span class="number">1647766367</span></span><br></pre></td></tr></table></figure></p>
<h2>2. 实现动态代理</h2>
<p>上面介绍了 Enhancer 之后，实现动态代理应该就不难了。</p>
<p>InvocationHandler 和 MethodInterceptor 都可以用来实现动态代理，下面是两种实现。</p>
<h3>InvocationHandler 实现</h3>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGlibHelloProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setInterfaces(obj.getClass().getInterfaces());</span><br><span class="line">        <span class="comment">//enhancer.setSuperclass(obj.getClass().getSuperclass());</span></span><br><span class="line">        <span class="keyword">this</span>.target = obj;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create(); <span class="comment">// 生成代理类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        Object result = method.invoke(target, params);</span><br><span class="line">        System.out.printf(<span class="string">"Invoke time "</span> + (System.currentTimeMillis() - begin) + <span class="string">" ms"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用上面的实现来创建代理并调用方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HelloImpl helloImpl = <span class="keyword">new</span> HelloImpl();</span><br><span class="line"></span><br><span class="line">CGlibHelloProxyInvocationHandler helloProxyInvocationHandler = <span class="keyword">new</span> CGlibHelloProxyInvocationHandler();</span><br><span class="line">Hello proxy = (Hello) helloProxyInvocationHandler.bind(helloImpl);</span><br><span class="line"></span><br><span class="line">proxy.sayHello(<span class="string">"ray"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意，如果使用接口创建代理对象，第一行代码使用 <code>Hello helloImpl = new HelloImpl()</code> 或者 <code>HelloImpl helloImpl = new HelloImpl()</code> 创建对象传入都可以，如果使用是父类创建代理对象，那么只能使用第二种。</p>
<h3>MethodInceptor 实现</h3>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGlibHelloProxyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setInterfaces(obj.getClass().getInterfaces());</span><br><span class="line">        <span class="comment">//enhancer.setSuperclass(obj.getClass());</span></span><br><span class="line">        <span class="keyword">this</span>.target = obj;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] params, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        Object result = method.invoke(target, params);</span><br><span class="line">        System.out.printf(<span class="string">"Invoke time "</span> + (System.currentTimeMillis() - begin) + <span class="string">" ms"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后创建代理对象并调用：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HelloImpl hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line"></span><br><span class="line">CGlibHelloProxyMethodInterceptor cGlibHelloProxy = <span class="keyword">new</span> CGlibHelloProxyMethodInterceptor();</span><br><span class="line">HelloImpl proxyObject = (HelloImpl) cGlibHelloProxy.bind(hello);</span><br><span class="line"></span><br><span class="line">proxyObject.sayHello(<span class="string">"ray"</span>);</span><br></pre></td></tr></table></figure></p>
<p>通常来说，使用 MethodInceptor 方式来实现更好，因为可以避免出现上面说到的无限循环的问题。</p>
<p>cglib 相比于 Java 反射实现动态代理的优势就是不受类的限制，可以自由的选择根据接口或者类来生成新的代理对象。</p>
<h3>cglib 中的 Proxy</h3>
<p>在 JDK 中，动态代理主要由 <code>java.lang.reflect.Proxy</code> 来实现，在 cglib 中，同样也实现了 Proxy，功能于 JDK 中的功能基本一致，其中用到的 <code>InvocationHandler</code> 就是前面介绍的回调。</p>
<p>这样做是为了 JDK1.3 以前的版本也能使用动态代理的功能。</p>
<h2>3. 总结</h2>
<p>这篇文章主要介绍了 cglib 的如果通过 Enhancer 去生成代理类，可以同时支持<strong>接口</strong>和<strong>子类的</strong>两种方式**。**同时也介绍了通过 Enhancer 来实现动态代理。</p>
<p>cglib 的能力远不止这些，下篇文章将介绍 cglib 的其他功能。</p>
<h2>REF</h2>
<p>[1] <a href="https://dzone.com/articles/cglib-missing-manual" target="_blank" rel="noopener">https://dzone.com/articles/cglib-missing-manual</a></p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>cglib</tag>
      </tags>
  </entry>
  <entry>
    <title>cglib入门后篇</title>
    <url>/2020/11/10/cglib%E5%85%A5%E9%97%A8%E5%90%8E%E7%AF%87/</url>
    <content><![CDATA[<p>在前面一篇文章中，详解介绍了 cglib 的 Enhancer 及配合使用的各种回调，然后使用 Enhancer 实现了动态代理。</p>
<p>在这篇文章中， 再来介绍一下 cglib 的其他能力。</p>
<p>本文基于 OpenJDK11</p>
<h2>1. Bean 操作</h2>
<p>Java Bean 是最常用的类型，cglib 提供了很多工具来操作这些 Bean，以满足各类需求。</p>
<h3>Immutable Bean</h3>
<p><code>ImmutableBean</code> 用来生成不可变对象，如果强行修改，将会抛出 <code>IllegalStateException</code>。</p>
<p>对原底线所有的改变都会反应到这个不可变对象。也就是可以通过修改原对象来修改这个不可变的对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HelloImpl helloImpl = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">helloImpl.setValue(<span class="string">"ray"</span>);</span><br><span class="line">HelloImpl immutableBean = (HelloImpl) ImmutableBean.create(helloImpl);</span><br><span class="line">helloImpl.setValue(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(helloImpl.getValue().equals(<span class="string">"hello"</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(immutableBean.getValue().equals(<span class="string">"hello"</span>)); <span class="comment">// true</span></span><br><span class="line">immutableBean.setValue(<span class="string">"Hello ray"</span>); <span class="comment">//java.lang.IllegalStateException: Bean is immutable</span></span><br></pre></td></tr></table></figure></p>
<h3>Bean Generator</h3>
<p><code>BeanGenerator</code> 在运行时创建一个新的 Bean。在使用第三方库时，不确定类型，就可以使用这种方式来动态创建 Bean。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanGenerator beanGenerator = <span class="keyword">new</span> BeanGenerator();</span><br><span class="line">beanGenerator.addProperty(<span class="string">"value"</span>, String.class);</span><br><span class="line">Object myBean = beanGenerator.create();</span><br><span class="line"></span><br><span class="line">Method setter = myBean.getClass().getMethod(<span class="string">"setValue"</span>, String.class);</span><br><span class="line">setter.invoke(myBean, <span class="string">"Hello cglib!"</span>);</span><br><span class="line">Method getter = myBean.getClass().getMethod(<span class="string">"getValue"</span>);</span><br><span class="line">System.out.println(<span class="string">"Hello cglib!"</span>.equals(getter.invoke(myBean))); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3>Bean Copier</h3>
<p><code>BeanCopier</code> 用来复制对象，可以复制同类型的 bean，也可以复制不同类型的 bean。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanCopier copier = BeanCopier.create(HelloImpl.class, HelloImpl.class, <span class="keyword">false</span>); <span class="comment">// 这里也可以是在不同的 bean 之间复制</span></span><br><span class="line">HelloImpl bean = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">bean.setValue(<span class="string">"Hello cglib!"</span>);</span><br><span class="line">HelloImpl otherBean = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">copier.copy(bean, otherBean, <span class="keyword">null</span>);</span><br><span class="line">System.out.println(<span class="string">"Hello cglib!"</span>.equals(otherBean.getValue())); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>而且还可以通过传入 Converter 参数来实现自定义拷贝规则，需要把 <code>BeanCopier.create</code> 的第三个参数设置为 true。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanCopier copier = BeanCopier.create(HelloImpl.class, HelloImpl.class, <span class="keyword">true</span>); <span class="comment">// 这里也可以是在不同的 bean 之间复制</span></span><br><span class="line">HelloImpl bean = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">bean.setValue(<span class="string">"Hello cglib!"</span>);</span><br><span class="line">HelloImpl otherBean = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">copier.copy(bean, otherBean, <span class="keyword">new</span> Converter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(Object value, Class target, Object context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"Hello cglib!"</span>.equals(otherBean.getValue())); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3>Bulk Bean</h3>
<p><code>BulkBean</code> 可以通过传数数组的方式来传入 Bean 的 get 和 set 方法，以及各个属性的类型来访问对象，而不用通过方法调用的方式来完成。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BulkBean bulkBean = BulkBean.create(HelloImpl.class,</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;<span class="string">"getValue"</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;<span class="string">"setValue"</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">HelloImpl bean = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">bean.setValue(<span class="string">"Hello world!"</span>);</span><br><span class="line">System.out.println(<span class="number">1</span> == bulkBean.getPropertyValues(bean).length);</span><br><span class="line">System.out.println(<span class="string">"Hello world!"</span>.equals(bulkBean.getPropertyValues(bean)[<span class="number">0</span>]));</span><br><span class="line">bulkBean.setPropertyValues(bean, <span class="keyword">new</span> Object[] &#123;<span class="string">"Hello cglib!"</span>&#125;);</span><br><span class="line">System.out.println(<span class="string">"Hello cglib!"</span>.equals(bean.getValue())); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3>Bean Map</h3>
<p><code>BeanMap</code> 实现了 <code>java.util.Map</code>，可以把一个 Java 对象转化成 String-to-Object 键值对的 Map。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HelloImpl bean = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">BeanMap map = BeanMap.create(bean);</span><br><span class="line">bean.setValue(<span class="string">"Hello cglib!"</span>);</span><br><span class="line">System.out.println(<span class="string">"Hello cglib!"</span>.equals(map.get(<span class="string">"value"</span>)));</span><br></pre></td></tr></table></figure></p>
<h2>2. 黑魔法</h2>
<p>cglib 中提供了很多的工具类，可以用来实现一些不常用，但有时候又很重要的功能。</p>
<h3>Key Factory</h3>
<p><code>Key Factory</code> 可以用于动态创建对象，这个工厂方法只需要包含 <code>newInstance()</code> 方法，返回一个 Object，通过这种方法生成的对象动态实现了 equals 和 hashcode 方法，可以保证相同参数构造出来的对象是同一个。</p>
<p>生成的对象可以用作 Map 的 key。</p>
<p>这个工具类在 cglib 的内部被大量使用。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleKeyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">newInstance</span><span class="params">(String first, <span class="keyword">int</span> second)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SampleKeyFactory keyFactory = (SampleKeyFactory) KeyFactory.create(SampleKeyFactory.class);</span><br><span class="line">Object key = keyFactory.newInstance(<span class="string">"foo"</span>, <span class="number">42</span>);</span><br><span class="line">Map&lt;Object, String&gt; map = <span class="keyword">new</span> HashMap&lt;Object, String&gt;();</span><br><span class="line">map.put(key, <span class="string">"Hello cglib!"</span>);</span><br><span class="line">System.out.println(<span class="string">"Hello cglib!"</span>.equals(map.get(keyFactory.newInstance(<span class="string">"foo"</span>, <span class="number">42</span>)))); <span class="comment">// 如果传入的参数不变，每次创建的对象是一样的</span></span><br></pre></td></tr></table></figure></p>
<h3>Mixin</h3>
<p>在 Scala 中， <code>Mixin</code> 已经很常见了，可以将多个对象组合到一个对象中，为了支持这个操作，要求这些对象都是基于接口来实现的。而且还需要声明一个额外的接口来生成组合对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">second</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class1</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"first"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class2</span> <span class="keyword">implements</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">second</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"second"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 额外声明的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MixinInterface</span> <span class="keyword">extends</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 为空 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mixin mixin = Mixin.create(<span class="keyword">new</span> Class[]&#123;Interface1.class, Interface2.class, MixinInterface.class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> Class1(), <span class="keyword">new</span> Class2()&#125;);</span><br><span class="line">MixinInterface mixinDelegate = (MixinInterface) mixin;</span><br><span class="line">System.out.println(<span class="string">"first"</span>.equals(mixinDelegate.first()));</span><br><span class="line">System.out.println(<span class="string">"second"</span>.equals(mixinDelegate.second()));</span><br></pre></td></tr></table></figure></p>
<p>但 Mixin 这个功能模拟的不彻底，因为为了组合对象，还需要声明一个单独的接口，既然如此，为什么不直接使用 Java 的方法来实现。</p>
<h3>String Switcher</h3>
<p>这个工具类用来模拟  Java 中的 switch，并且可以接收 String，这点在 Java7 以后就支持了，对于 Java7 以前的版本，这个还有用。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strings = <span class="keyword">new</span> String[]&#123;<span class="string">"one"</span>, <span class="string">"two"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">StringSwitcher stringSwitcher = StringSwitcher.create(strings, values, <span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="number">10</span> == stringSwitcher.intValue(<span class="string">"one"</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">20</span> == stringSwitcher.intValue(<span class="string">"two"</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(-<span class="number">1</span> == stringSwitcher.intValue(<span class="string">"three"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3>Interface Maker</h3>
<p><code>InterfaceMaker</code> 可以用来动态生成一个<strong>接口</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建接口</span></span><br><span class="line">Signature signature = <span class="keyword">new</span> Signature(<span class="string">"foo"</span>, Type.DOUBLE_TYPE, <span class="keyword">new</span> Type[]&#123;Type.INT_TYPE&#125;); <span class="comment">// 设置方法签名</span></span><br><span class="line">InterfaceMaker interfaceMaker = <span class="keyword">new</span> InterfaceMaker();</span><br><span class="line">interfaceMaker.add(signature, <span class="keyword">new</span> Type[<span class="number">0</span>]);</span><br><span class="line">Class iface = interfaceMaker.create(); <span class="comment">// 获得接口</span></span><br><span class="line">System.out.println(<span class="number">1</span> == iface.getMethods().length); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">"foo"</span>.equals(iface.getMethods()[<span class="number">0</span>].getName())); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="keyword">double</span>.class == iface.getMethods()[<span class="number">0</span>].getReturnType()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3>Fast Class and Fast Members</h3>
<p><code>FastClass</code> 可以提供比 Java 中反射更快的执行速度。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FastClass fastClass = FastClass.create(HelloImpl.class);</span><br><span class="line">FastMethod fastMethod = fastClass.getMethod(HelloImpl.class.getMethod(<span class="string">"getValue"</span>));</span><br><span class="line">HelloImpl myBean = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">myBean.setValue(<span class="string">"Hello cglib!"</span>);</span><br><span class="line">System.out.println(<span class="string">"Hello cglib!"</span>.equals(fastMethod.invoke(myBean, <span class="keyword">new</span> Object[<span class="number">0</span>]))); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>除了上面的 FastMethod，还可以使用 FastConstructor，但没有 FastField，这个好理解，对于一个属性，自然就不需要加速了。</p>
<p>Java 中的反射是通过 JNI 本地调用来执行反射的代码，而 FastClass 则是直接生成字节码文件被 JVM 执行。</p>
<p>但是在 Java1.5 之后，反射代码执行的性能已经提升了不少，在新版本的 JVM 上，就没必要使用 FastClass 了，但是在老版本的 JVM 上，对性能的提升还是很可观的。</p>
<h2>3.方法委托</h2>
<p>方法委托这个概念来自于 C# 中，类似 C++ 中的函数指针，可以运行时改变委托的值。cglib 中也提供了相应的实现。</p>
<h3>Method Delegate</h3>
<p>Method Delagate 允许构造 C# 风格的方法委托，新建一个委托接口，然后将 HelloImpl 实例和 getValue 方法生成一个新的对象，就可以通过这个委托对象来调用方法。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getValueFromDelegate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HelloImpl bean = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">bean.setValue(<span class="string">"Hello cglib!"</span>);</span><br><span class="line">BeanDelegate delegate = (BeanDelegate) MethodDelegate.create(</span><br><span class="line">        bean, <span class="string">"getValue"</span>, BeanDelegate.class);</span><br><span class="line">System.out.println(<span class="string">"Hello cglib!"</span>.equals(delegate.getValueFromDelegate())); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>在使用 <code>MethodDelegate.create</code> 工厂方法时，需要注意，<strong>它只能代理没有参数的方法</strong>。</p>
<h3>Multicast Delegate</h3>
<p><code>MulticastDelegate</code> 可以接收多个对象方法的委托，而且方法可以有参数。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DelegatationProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMulticastBean</span> <span class="keyword">implements</span> <span class="title">DelegatationProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MulticastDelegate multicastDelegate = MulticastDelegate.create(DelegatationProvider.class);</span><br><span class="line">SimpleMulticastBean first = <span class="keyword">new</span> SimpleMulticastBean();</span><br><span class="line">SimpleMulticastBean second = <span class="keyword">new</span> SimpleMulticastBean();</span><br><span class="line">multicastDelegate = multicastDelegate.add(first);</span><br><span class="line">multicastDelegate = multicastDelegate.add(second);</span><br><span class="line">DelegatationProvider provider = (DelegatationProvider)multicastDelegate;</span><br><span class="line">provider.setValue(<span class="string">"Hello cglib!"</span>);</span><br><span class="line">System.out.println(<span class="string">"Hello cglib!"</span>.equals(first.getValue())); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">"Hello cglib!"</span>.equals(second.getValue())); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>MulticastDelegate 要求提供委托的接口只能有一个方法，这样在实现对第三方库进行委托代理的时候就会很困难，因为要创建很多委托代理接口。</p>
<p>而且还有一点，如果这个被委托的方法有返回值，只能接收最后一个对象的返回值，其他的返回值都会丢失。</p>
<h3>Constructor Delegate</h3>
<p>构造函数的委托相对简单，只需要定义一个有 <code>newInstance()</code> 方法的接口，返回值是 <code>Object</code>，这个方法还可以有任意个参数。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleBeanConstructorDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">newInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SampleBeanConstructorDelegate constructorDelegate = (SampleBeanConstructorDelegate) ConstructorDelegate.create(</span><br><span class="line">        HelloImpl.class, SampleBeanConstructorDelegate.class);</span><br><span class="line">HelloImpl bean = (HelloImpl) constructorDelegate.newInstance();</span><br><span class="line">System.out.print(HelloImpl.class.isAssignableFrom(bean.getClass()));</span><br></pre></td></tr></table></figure></p>
<h2>4. 其他</h2>
<h3>Parallel Sorter</h3>
<p>cglib 中甚至提供了一个排序器，号称效率要超过 Java 自带的排序工具。</p>
<p>这个排序器可以对多维数组进行排序，而且可以对不同行使用不同的排序规则，可以选择归并排序或者快速排序。</p>
<p>使用方式如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[][] value = &#123;</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ParallelSorter.create(value).mergeSort(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer[] row : value) &#123;</span><br><span class="line">    <span class="keyword">int</span> former = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> val : row) &#123;</span><br><span class="line">        System.out.println(former &lt; val); <span class="comment">// true</span></span><br><span class="line">        former = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以 <code>mergeSort</code> 为例，有四个重载方法，最多可以有四个参数。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comparator cmp)</span> </span>&#123;</span><br><span class="line">    chooseComparer(index, cmp);</span><br><span class="line">    <span class="keyword">super</span>.mergeSort(lo, hi - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个表示从哪一列开始使用归并排序，第二个表示从哪一行（包括）开始，第三个表示截止到哪一行（不包含），第四个参数是自定义的比较器。</p>
<p>看起来就不怎么好用。实际上，Java 自带的排序已经很好用了，这个排序工具不推荐使用。</p>
<p>而且它还有一个明显的 bug，如果把上面的 <code>Integer[][]</code> 换成 <code>int[][]</code>，就会报 <code>java.lang.ClassCastException</code> 异常。</p>
<h2>REF</h2>
<p>[1] <a href="https://dzone.com/articles/cglib-missing-manual" target="_blank" rel="noopener">https://dzone.com/articles/cglib-missing-manual</a></p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>一文看懂 Go 的数据类型</title>
    <url>/2021/05/23/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82-Go-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>每一门语言都有自己的数据结构，Go 语言也不例外，总共有四大类，<strong>基础类型、聚合类型、引用类型和接口类型</strong>。本文简单介绍一下这些类型。</p>
<p><img src="0.png" alt=""></p>
<h2>1. 基础类型</h2>
<h3>整型</h3>
<p>Go 的整型分为有符号和无符号整数。</p>
<p>有符号整数会分成 int8、int16、int32、int64</p>
<p>无符号整数会分成 uint8、uint16、uint32、uint64</p>
<p>但通常会直接使用 int 和 uint，因为这两种类型会根据平台的特性，自动转成运算效率最高的类型，现在 32 位以下的计算机一级很少见了，所以 int 通常是 32 或者 64位，但具体要根据平台和编译器决定。</p>
<p>int 是目前使用最广泛的数值类型，在需要明确指定数值位数的时候，直接使用 int 就可以。</p>
<p>通常来说，有符号的整数就够用，无符号整数只有在位运算或者特定算数的时候才会使用。</p>
<p>uintptr 和 rune 是两类特殊的数字类型，uintptr 大小不明确，用来存储指针，主要用于底层编程，比如用于 Go 语言与 C 语言的交互。</p>
<p>如果两个值可以使用 == 和 != 进行比较，说明这个两个值是可比较的。</p>
<p>整数是可比较的。</p>
<h3>其他数字类型</h3>
<p>除了整型数据之外，Go 语言中，还有两种数据类型：<strong>浮点数</strong>和<strong>复数</strong>。</p>
<p>浮点数有 float32 和 float64 两种类型，浮点数一般使用指数表示法，使用 e 或者 E 来表示。</p>
<p>float32 的正数范围是 1.4e-45 ~ 3.4e38</p>
<p>float64 的正数范围是 4.9e-324 ~ 1.8e308</p>
<p>在 10 进制下，float64 的有效数字是 15 位，远远超过了 float32 的 5 位，如果没有特殊的情况，应该优先使用 float64。</p>
<p>复数也有两种 complex64 和 complex128，这两种类型分别由 float32 和 float64 构成。<code>math/cmplx</code> 库提供了复数运算所需要的函数。</p>
<p>浮点数和复数都是可比较的。</p>
<h3>字符串</h3>
<p>字符串可是说是最常用的数据类型。字符串由不可变的字节序列（[]byte）构成，字符串的内容通常会用 UTF-8 的编码格式处理，这点在上一篇文章中已经详细的说明过了。</p>
<p>Go 的字符串内容是不可变的，对当前字符串做的操作都会生成一个新的字符串。Go 字符串天然支持 UTF-8，而且习惯上也会优先使用这种编码方式，乱码的烦恼会少一些。</p>
<p>Go 语言也为字符串提供了丰富的类库：</p>
<ul>
<li>bytes：用于操作字节slice（[]byte），如果需要对字符串进行频繁的修改， 使用 byte.Buffer 会高效</li>
<li>strings：用于搜索、替换等等字符传操作</li>
<li>strconv：主要用于字符串和其他基本数据类型之间的转换</li>
<li>unicode：用来判断字符的特性，比如是否是数字、是否大写等等</li>
</ul>
<p>字符串是可比较的。</p>
<h3>布尔值</h3>
<p>布尔值相对来说比较简单，只有两个值： <code>true</code> 和 <code>false</code>。可以使用 ! 符号来进行取反运算，!true 就是 false。</p>
<p>也可以使用 &amp;&amp; 和 || 来进行组合运算，在组合运算中，也会遵循短路行为，短路行为是指左边如果能直接确定最后的结果，那么后面的计算将不会进行，如下:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="comment">// i &lt; 100 代码就不会被执行</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> || i &lt; <span class="number">100</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"result %+v"</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>布尔值是可比较的。</p>
<h2>2. 聚合类型</h2>
<p>聚合类型的值由内存中的一组变量构成。数组和结构体都是聚合类型，数组和结构体的长度都是固定的。数组中的的元素类型<strong>必须</strong>都<strong>相同</strong>，而结构体中的元素<strong>可以不同</strong>。</p>
<h3>数组</h3>
<p>数组是一个长度固定，拥有0 个或多个（不超过数组长度）相同数据类型的序列。数组在声明的时候必须指定长度，可以使用常量，但是不能使用变量。</p>
<p>实际上，我们很少在代码中直接使用数组，数组在绝大部分的时候都是做为 slice 的底层存储，并不会直接使用。</p>
<p>数组的可比较性取决于元素的可比较性，如果元素是可比较的，那么数组也是可比较的，反之亦然。</p>
<h3>结构体</h3>
<p>结构体是由任意个任意类型的变量组合在一起的数据类型，和其他语言中<strong>类</strong>的概念相似。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Go 语言是一个面向对象的语言，但却又抛弃了 Java 中类和对象的概念，结构体是 Go 语言实现面向对象的基础之一，还有一部分是接口，下面会聊到。</p>
<p>在 Go 的面向对象中，已经摈弃了继承的概念，但在结构体中，通过结构体嵌套，也算是实现了部分继承的功能。</p>
<p>结构体的可比较性也取决于其中变量的可比较性。</p>
<h2>3. 引用类型</h2>
<p>引用是另外一种数据类型，很多 Go 语言的高级功能都依赖引用。引用都间接指向变量或者状态，通过引用来操作数据会让该数据的全部引用都受影响。</p>
<h3>指针</h3>
<p>指针是一种数据类型，指针的值是一个变量的地址。对于一个变量来说，可以有多个指针，通过其中任意一个指针来修改数据，通过其他指针也会获取到最新修改的值。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">p1 := &amp;i</span><br><span class="line">p2 := &amp;i</span><br><span class="line"></span><br><span class="line">*p1 = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">fmt.Println(*p2) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>指针是可比较的。</p>
<h3>slice</h3>
<p>slice 是一个拥有相同元素的可变长度序列。 slice 看起来与数组很像，但本质上不同。</p>
<p>slice 依赖数组，没有数组，就没有 slice。</p>
<p>一个 slice 有三个属性，指针，长度和容量。其中指针指向数组中的某个元素（不一定是第一个），这是 slice 可以访问的第一个元素。</p>
<p>长度是 slice 中元素的个数，不能超过容量，容量通常是指 slice 指针的位置，到底层数组的最后一个元素的位置的长度。</p>
<p>slice 不可比较， 只能和 nil 比较。</p>
<h3>map</h3>
<p>map 是散列表的引用。</p>
<p>map 的使用很简单，但是需要注意一点，map 的 key 必须是可比较的，如果 key 不可比较，那就无法通过 key 查询到响应的 value，value 的类型是没有限制的，可以是任意值。</p>
<p>map 不可比较，只能和 nil 比较。</p>
<h3>function</h3>
<p>function 就是函数，在写 Go 的 helloworld 程序时，就会用到函数。 函数也是一种引用类型。</p>
<p>function 本身不可比，只能和 nil 比较，但是可以通过反射获取函数指针进行比较。</p>
<h3>channel</h3>
<p>Go 语言天然支持搞并发。而 channel 就是其中关键一环，goroutine 用来并发执行任务。而 channel 则用来连接不同的 goroutine。channel 也是属于引用类型。</p>
<p>channel 是可比较的。</p>
<h2>4. 接口类型</h2>
<p>Go 语言中还有一个类型是接口类型。</p>
<p>接口是 Go 实现面向对象的关键。Go 的接口类型很特别，你不需要去显示的实现一个接口，只要把接口中的方法实现，就默认实现了这个接口。</p>
<p>接口类型是可比较的。</p>
<h2>5. 小结</h2>
<p>Go 的数据类型设计简洁，但扩展性很好，开发者可以根据自己的需要动态的扩展数据，不只是对于结构体这种聚合数据类型，即使对于基础数据类型，也可以根据的需要进行扩展。另外 Go 自带对 JSON、xml 以及 Protocol Buffer 的支持，不需要引入外部的库，这就使得写程序时会很轻量级，可以尽可能少的引入依赖包。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>一文看懂 nil</title>
    <url>/2021/10/23/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82-nil/</url>
    <content><![CDATA[<p>写过 Go 代码的人，肯定对下面的代码不陌生：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Go 项目中这行代码会大量存在，这里可能隐藏着陷阱。</p>
<h2>1. Go 中的 nil</h2>
<p>Go 中 nil 代表零值，表示什么都没有，其他语言中也有类似的设计，比如 Java 中的 null。</p>
<p>也不是所有类型的零值都是 nil，Go 中不同类型的零值如下：</p>
<p><img src="0.png" alt=""></p>
<p>Go 中的数据类型可以分为基本类型和复合类型。</p>
<p>基本类型的零值都不同，有的是数字，有的是空字符串，对于复合类型， 零值都是 nil。</p>
<p>零值在有些情况下会让程序崩溃，比如指针的零值，因为指针是指向一块内存地址，如果指针为 nil，那么就表示不指向任何地址，那么使用这个指针内存操作就会出现 panic。</p>
<p>还有一点需要注意，nil 并不是关键字，nil 在 Go 中是这样定义的：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">nil</span> Type <span class="comment">// Type must be a pointer, channel, func, interface, map, or slice type</span></span><br></pre></td></tr></table></figure></p>
<p>nil 的类型只能是指针，channel、函数、接口和 slice。</p>
<p>也就是说这样写代码是完全合法的：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">nil</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure></p>
<p>但永远不要这么做，否则程序就完蛋了。</p>
<h2>2. nil 中的陷阱</h2>
<p>从 nil 的定义可以知道，nil 只能和指针等几种类型一起使用。</p>
<p>指针的结构相对简单，就是指向一个内存地址，我们可以很安全的使用 nil 来判断指针是不是为空，有没有指向内存地址。</p>
<p>channel、map、function 和 slice 的本质都是在使用指针，所以也可以使用 nil 来判断这些类型是否初始化、是否能使用。slice 特殊一点，还有 len 和 cap 两个属性，但不影响 nil 的判断：</p>
<p><img src="1.png" alt=""></p>
<p>而 interface 中的 nil，有隐藏的陷阱。</p>
<p>inteface 的接口与上面的类型都不一样，interface 由两部分组成，一部分是接口的类型，另一部分是接口的值:</p>
<p><img src="2.png" alt=""></p>
<p>先看下面代码的输出：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> in io.Writer</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, in)  <span class="comment">// nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inP *io.Writer</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, inP) <span class="comment">// *io.Writer</span></span><br></pre></td></tr></table></figure></p>
<p>%T 表示输出这个值的类型。</p>
<p>声明上面的变量之后，此时 in 和 inP 的结构是下面这样的：</p>
<p><img src="3.png" alt=""></p>
<p>如果再接着写下面的代码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> in io.Writer</span><br><span class="line"><span class="keyword">if</span> in != <span class="literal">nil</span> &#123;</span><br><span class="line">	  in.Write([]<span class="keyword">byte</span>(<span class="string">"logs"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inP *io.Writer</span><br><span class="line"><span class="keyword">if</span> inP != <span class="literal">nil</span> &#123;</span><br><span class="line">		inP.Write([]<span class="keyword">byte</span>(<span class="string">"logs"</span>)) <span class="comment">// 这里会发生 panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>inP 的 type 不是 nil，那么 inP 就不等于 nil。在使用接口时要注意，只有接口的类型和值都是 nil 时，这个接口才等于 nil，否则不相等。</p>
<p>错误处理是 Go 程序的重要组成部分，但是这里也容易出现陷阱，看如下的代码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := Do()       <span class="comment">// nil</span></span><br><span class="line">	fmt.Printf(<span class="string">"result: %+v\n"</span>, (err == <span class="literal">nil</span>)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Do</span><span class="params">()</span> *<span class="title">DoError</span></span> &#123; <span class="comment">// nil</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DoError <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DoError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"doError"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码返回的不是接口，而是 DoError 类型的指针，所以判断是否为 nil 没问题。</p>
<p>如果换种形式，看下面的代码，返回的是  error 的接口类型，但是这个接口的类型是 *DoError，值是 nil，这样一来，就和预期的结果不符合。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := Do()       <span class="comment">// error(*DoError, nil)</span></span><br><span class="line">    fmt.Printf(<span class="string">"result: %+v\n"</span>, (err == <span class="literal">nil</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Do</span><span class="params">()</span> <span class="title">error</span></span> &#123;    <span class="comment">// error(*DoError, nil)</span></span><br><span class="line">   <span class="keyword">var</span> err *DoError</span><br><span class="line">   <span class="keyword">return</span> err      <span class="comment">// nil </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断 err 是不是 nil 是非常高频的使用场景，在处理这些错误时，要非常小心。</p>
<h2>3. nil 的其他作用</h2>
<p>nil 除了作为零值之外，还有其他的用途。</p>
<p>nil 作为方法的接受者是完全合法的，这里 p 是一个 *Person 类型的 nil：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p *Person <span class="comment">// nil</span></span><br><span class="line">	p.SayHi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hi"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>nil 还可以作为默认值，下面的代码应该也看的不少了，通常情况下，第二个参数我们都会直接传入 nil，这里 nil 的含义是使用默认的配置，我们在自己的代码中也可以这样使用。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"localhost:8080"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<h2>4. 小结</h2>
<p>nil 是指针，channel、函数、接口和 slice 等类型的零值，其中 interface 的零值有点特殊，只有在类型和值都是 nil 的时候，这个接口才是 nil。</p>
<p>nil 除了作为零值使用之外，还有很多其他的用途，比如作为方法的接受者，表示默认值。</p>
<p>文 / Rayjun</p>
<p>[1] <a href="https://www.youtube.com/watch?v=ynoY2xz-F8s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ynoY2xz-F8s</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump 实例-获取网络包的50种方法</title>
    <url>/2020/07/18/tcpdump-%E5%AE%9E%E4%BE%8B-%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%8C%85%E7%9A%8450%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><code>TCPDUMP</code> 毫无疑问是最重要的网络分析工具，因为它简单实用，而且功能强大。</p>
<p>这篇教程将会教你从 IP、端口、协议、应用层等多方面来获取通信数据包，确保你可以尽可能快的找到你想要的数据。</p>
<p>tcpdump 的安装很简单，在 ubuntu 上：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt install tcpdump</span><br></pre></td></tr></table></figure></p>
<p>在 Redhat/Centos 上：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install tcpdump</span><br></pre></td></tr></table></figure></p>
<p>首先通过一个简单的命令来获取 HTPPS 的数据包：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -nnSX port 443</span><br><span class="line"></span><br><span class="line">17:59:25.938214 IP 138.68.249.192.443 &gt; 10.236.216.235.65078: Flags [.], seq 3666844459:3666845907, ack 3574575735, win 248, options [nop,nop,TS val 2964126 ecr 782599132], length 1448</span><br><span class="line">	0x0000:  784f 43a0 abcd 200b c79d 065f 0800 4500  xOC........_..E.</span><br><span class="line">	0x0010:  05dc 2b11 4000 3006 b22e 8a44 f9c0 0aec  ..+.@.0....D....</span><br><span class="line">	0x0020:  d8eb 01bb fe36 da8f 9b2b d50f b277 8010  .....6...+...w..</span><br><span class="line">	0x0030:  00f8 d531 0000 0101 080a 002d 3a9e 2ea5  ...1.......-:...</span><br></pre></td></tr></table></figure></p>
<p>上面展示了一些 HTTPS 通信的内容，通过十六进制的形式展现出来，并且还加密了。当你对网络有任何疑问时，就可以通过上面的命令去获取你关注端口的信息。下面来看一些更详细的例子。</p>
<h2>基本用法</h2>
<p>现在你可以获取一些基本的流量包，再来看看其他的用法，下面的这些例子在你从事网络、安全或者其他工作时都可以用到。</p>
<h3>只需要一个接口</h3>
<p>输入下面的命令，然后看看会出现什么:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -i eth0</span><br></pre></td></tr></table></figure></p>
<p><strong>注</strong>：如果 eth0 网卡没有配置，那什么都不会出现 ，这个时候可以将 <code>eth0</code> 换成 <code>any</code></p>
<h3>通过 IP 获取流量</h3>
<p>最常用的查询方法之一，通过 <code>host</code> 参数，获取从特定 IP 发出和收到的流量：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump host 1.1.1.1</span><br></pre></td></tr></table></figure></p>
<h3>通过源地址和目标地址来过滤</h3>
<p>如果你只需要获取一个方向的流量，可以使用 <code>src</code> 和 <code>dst</code> 来限定方向：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump src 1.1.1.1</span><br><span class="line">$ tcpdump dst 1.0.0.1</span><br></pre></td></tr></table></figure></p>
<h3>通过特定网络获取流量包</h3>
<p>如果想从一个特定的网络或者子网获取流量，使用 <code>net</code> 参数：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump net 1.2.3.0/24</span><br></pre></td></tr></table></figure></p>
<h3>获取十六进制的数据包内容</h3>
<p>十六进制输出在你想看数据内容的时候非常有用，特别是你想深入其中一部分内容的时候，这是最好的方法，只需要加上 <code>-X</code> 参数：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -c 1 -X icmp</span><br><span class="line">17:47:27.844781 IP 10.236.216.1 &gt; sk-20200221gewc.mioffice.cn: ICMP 10.236.216.1 udp port nat-pmp unreachable, length 36</span><br><span class="line">	0x0000:  784f 43a0 abcd 200b c79d 065f 0800 45c0  xOC........_..E.</span><br><span class="line">	0x0010:  0038 2ef3 0000 ff01 c508 0aec d801 0aec  .8..............</span><br><span class="line">	0x0020:  d92f 0303 a6bf 0000 0000 4500 0058 a27e  ./........E..X.~</span><br><span class="line">	0x0030:  0000 ff11 520d 0aec d92f 0aec d801 14e9  ....R..../......</span><br><span class="line">	0x0040:  14e7 0044 2c29                           ...D,)</span><br></pre></td></tr></table></figure></p>
<h3>通过特定的端口获取流量包</h3>
<p>你可以通过特定的端口来获取流量数据，只需要使用 <code>port</code> 参数，在参数后加上具体的端口：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump port 3389</span><br><span class="line">$ tcpdump src port 1025</span><br></pre></td></tr></table></figure></p>
<h3>获取具体协议的流量包</h3>
<p>如果你想获得特定类型的流量包，可以使用 <code>tcp</code>， <code>udp</code>， <code>icmp</code> 或者其他的协议:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump icmp</span><br></pre></td></tr></table></figure></p>
<h3>只获取 IPv6 的流量包</h3>
<p>你也可以只获取 IPv6 的 流量包：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump ip6</span><br></pre></td></tr></table></figure></p>
<h3>通过端口范围来获取流量包</h3>
<p>你也可以指定一个流量范围，然后只获取这个范围内的流量：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump portrange 21-23</span><br></pre></td></tr></table></figure></p>
<h3>通过流量包的大小来筛选</h3>
<p>如果你想获得一个特定大小的包，你可以使用这个选项，你可以使用 <code>less</code> <code>greate</code>或者其他你可以在数学中能找到的符号：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump less 32</span><br><span class="line">$ tcpdump greater 64</span><br><span class="line">$ tcpdump &lt;= 128</span><br></pre></td></tr></table></figure></p>
<h3>读写流量包(pcap)</h3>
<p>还可以流量包存成一个文件，以便后续可以对这个流量包进行分析。这个文件的格式是 PCAP(PEE-cap)，它可以被数百种的应用处理，包括网络分析，系统入侵检测，当然也可以被 tcpdump 本身所处理。只需要使用 <code>-w</code> 参数就可以把流量包存成文件：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump port 80 -w capture_file</span><br></pre></td></tr></table></figure></p>
<p>也可以使用 <code>-r</code> 参数来读取 PCAP 文件。在读取这个文件的时候同时也可以使用其他的参数，唯一受限制的就是无法捕捉和处理文件中不存在的内容。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -r capture_file</span><br></pre></td></tr></table></figure></p>
<h2>进阶用法</h2>
<p>上面我们已经通过一些基本的例子展示 tcpdump 的能力，下来来看一下更进阶的内容。</p>
<h3>其他参数</h3>
<p>下面这些参数在你使用 tcpdump 的时候也可以使用：</p>
<ul>
<li><code>-X</code> : 通过 16 进制和 ASCII 码来展示数据包中的内容</li>
<li><code>-XX</code>: 和 -X 类似，但会另外展示以太网头部</li>
<li><code>-D</code> : 展示可用的借口列表</li>
<li><code>-l</code>: 单行输出(以便在保存时查看或者发送到其他命令)</li>
<li><code>-q</code>: 减少一些不必要的输出</li>
<li><code>-t</code>: 输出可读的时间格式</li>
<li><code>-tttt</code>: 提供最大程度的人类可读的时间戳输出</li>
<li><code>-i eth0</code>: 监听 eth0 网口</li>
<li><code>-vv</code>: 输出更详细的细节</li>
<li><code>c</code>: 只获取一定的数量包，然后停止</li>
<li><code>-s</code>: 获取以字节为单位固定大小的包，使用 -s0 可以获取到所有的内容</li>
<li><code>-S</code>: 打印绝对序列号（注：TCP 的序列号）</li>
<li><code>-e</code>: 同时获取以太网头部</li>
<li><code>-q</code>: 减少协议信息的展示</li>
<li><code>-E</code>: 通过提供加密密钥解密IPSEC通信</li>
</ul>
<h3>条件组合</h3>
<p>上面提到的这些命令就已经很强大了，但 tcpdump 的真正黑魔法是你可以随意的组合这些参数，来达到找特定内容的目的。</p>
<p>有三种组合方式，如果你会一点编程的话，这些对你来说应该很熟悉：</p>
<ul>
<li>与:  <code>and</code> 或 <code>&amp;&amp;</code></li>
<li>或:  <code>or</code> 或 <code>||</code></li>
<li>非:  <code>not</code> 或 <code>!</code></li>
</ul>
<h3>原始输出视图</h3>
<p>使用此组合可以查看详细的输出，不包含主机名或端口号的解析，使用绝对序列号，并显示人类可读的时间戳。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -ttnnvvS</span><br></pre></td></tr></table></figure></p>
<p>下面是一些使用组合命令的例子。</p>
<h3>获取特定 IP 和特定端口号的数据包</h3>
<p>比如获取所有从 10.5.2.3 发出去，并且目标端口号是 3389 的数据包：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -nnvvS src 10.5.2.3 and dst port 3389</span><br></pre></td></tr></table></figure></p>
<h3>从一个网络到另一挂网络的包</h3>
<p>比如获取从 192.168.x.x 网络发到 10.x 或者 172.16.x.x 网络的包，并且会通过16进制的形式展现出来。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -nvX src net 192.168.0.0/16 and dst net 10.0.0.0/8 or 172.16.0.0/16</span><br></pre></td></tr></table></figure></p>
<h3>到特定 IP 且不包含 ICMP 的包</h3>
<p>比如获取目标 IP 是192.168.0.2 且不包含 ICMP 的包：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump dst 192.168.0.2 and src net and not icmp</span><br></pre></td></tr></table></figure></p>
<h3>获取从特定 IP 发出但不包含特定端口的包</h3>
<p>比如获取一个从特定 IP 出发，但不包括 SSH 的包（假设使用的是默认端口）：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -vv src mars and not dst port 22</span><br></pre></td></tr></table></figure></p>
<p>如你所见，你可以构建查询来查找所需的任何内容。关键是首先精确地找出要查找的内容，然后构建语法来隔离特定类型的流量。</p>
<p>要注意的是，在构建复杂查询时，可能必须使用单引号对选项进行分组。使用单引号是为了告诉tcpdump忽略括号下面的某些特殊字符。同样的方式也可以用于使用其他表达式分组，如主机、端口、网络等。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump <span class="string">'src 10.0.2.4 and (dst port 3389 or 22)'</span></span><br></pre></td></tr></table></figure></p>
<h3>隔离 TCP 标志</h3>
<p>你还可以使用过滤器来隔离设置了特定TCP标志的数据包。</p>
<p><strong>隔离 TCP RST 标志</strong></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump <span class="string">'tcp[13] &amp; 4!=0'</span></span><br><span class="line">$ tcpdump <span class="string">'tcp[tcpflags] == tcp-rst'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>隔离 TCP SYN 标志</strong></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump <span class="string">'tcp[13] &amp; 2!=0'</span></span><br><span class="line">$ tcpdump <span class="string">'tcp[tcpflags] == tcp-syn'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>隔离设置了 SYN 和 ACK 标志的包</strong></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump <span class="string">'tcp[13]=18'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>隔离TCP URG 标志</strong></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump <span class="string">'tcp[13] &amp; 32!=0'</span></span><br><span class="line">$ tcpdump <span class="string">'tcp[tcpflags] == tcp-urg'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>隔离 TCP ACK 标志</strong></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump <span class="string">'tcp[13] &amp; 16!=0'</span></span><br><span class="line">$ tcpdump <span class="string">'tcp[tcpflags] == tcp-ack'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>隔离 TCP PSH 标志</strong></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump <span class="string">'tcp[13] &amp; 8!=0'</span></span><br><span class="line">$ tcpdump <span class="string">'tcp[tcpflags] == tcp-psh'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>隔离 TCP FIN 标志</strong></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump <span class="string">'tcp[13] &amp; 1!=0'</span></span><br><span class="line">$ tcpdump <span class="string">'tcp[tcpflags] == tcp-fin'</span></span><br></pre></td></tr></table></figure></p>
<h2>日常例子</h2>
<p>最后，我们已经看完了基本理论，下面的这些例子可以用于日常快速获取某种类型的数据包。</p>
<h3>同时设置 SYN 和 RST 标志</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump <span class="string">'tcp[13] = 6'</span></span><br></pre></td></tr></table></figure></p>
<h3>查找 HTTP 使用的 Agent</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -vvAls0 | grep <span class="string">'User-Agent:'</span></span><br></pre></td></tr></table></figure></p>
<h3>获取明文的 Get 请求</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -vvAls0 | grep <span class="string">'GET'</span></span><br></pre></td></tr></table></figure></p>
<h3>获取 HTTP 的 host 头部</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -vvAls0 | grep <span class="string">'Host:'</span></span><br></pre></td></tr></table></figure></p>
<h3>获取 HTTP 的 cookies</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -vvAls0 | grep <span class="string">'Set-Cookie|Host:|Cookie:'</span></span><br></pre></td></tr></table></figure></p>
<h3>获取 SSH 连接</h3>
<p>无论连接来自哪个端口，这个都可以工作。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump <span class="string">'tcp[(tcp[12]&gt;&gt;2):4] = 0x5353482D'</span></span><br></pre></td></tr></table></figure></p>
<h3>获取 DNS 的包</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -vvAs0 port 53</span><br></pre></td></tr></table></figure></p>
<h3>获取 FTP 的包</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -vvAs0 port ftp or ftp-data</span><br></pre></td></tr></table></figure></p>
<h3>获取 NTP 的包</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -vvAs0 port 123</span><br></pre></td></tr></table></figure></p>
<h3>获取明文的密码</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump port http or port ftp or port smtp or port imap or port pop3 or port telnet -lA | egrep -i -B5 <span class="string">'pass=|pwd=|log=|login=|user=|username=|pw=|passw=|passwd= |password=|pass:|user:|username:|password:|login:|pass |user '</span></span><br></pre></td></tr></table></figure></p>
<h3>发现包中不正常的数据</h3>
<p>在IP报头中，有一点合法的应用程序永远不会设置，如果设置了就不正常。这里有一个有趣的过滤器，可以找到它被设置的包。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump <span class="string">'ip[6] &amp; 128 != 0'</span></span><br></pre></td></tr></table></figure></p>
<h2>总结</h2>
<p>下面是一些思考：</p>
<ol>
<li>tcpdump 对于任何希望进入网络或信息安全领域的人来说都是一个有价值的工具</li>
<li>它有可以与流量交互的直接接口，加上它在检查数据包方面提供的精确性，它可能是学习TCP/IP最好的工具</li>
<li>像 Wireshark 这样的工具虽然也很棒，但是如果你想真正掌握数据包的结构，你必须先学会 tcpdump</li>
</ol>
<p>这篇初级教程应该能让你能开始使用 tcpdump，但是对于其他更多的使用场景，还是要查阅手册。我希望这对你有用，如果你有任何问题，请随时联系我。</p>
<p>原文地址：<a href="https://danielmiessler.com/study/tcpdump/#basic-communication" target="_blank" rel="noopener">https://danielmiessler.com/study/tcpdump/#basic-communication</a></p>
<p>译 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>一文看懂 slice</title>
    <url>/2021/05/23/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82-slice/</url>
    <content><![CDATA[<p>Go 语言中虽然有数组，但在代码中直接用的比较少，而是会间接的用到，slice 存储数据就是用的 数组，甚至可以认为数组是为了 slice 存在。Go 语言中的 slice 可以当做数组来使用，也可以当做其他语言中的 List 来使用。</p>
<p>slice 表示一个拥有相同类型元素的<strong>可变长</strong>的序列。可变长是 slice 最重要的一个特性，这是它和数组最不同的地方，既然 slice 是依靠数组而存在的，那么 slice 是如何做到可变长的呢，这篇文章就来聊一下。</p>
<p>先从 slice 的创建说起。</p>
<h2>slice 的创建</h2>
<p>slice 可以主动创建，也可从现有的数组中获取。</p>
<p>带初始化元素的方式：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums)) <span class="comment">// 6</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(nums)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<p>不带初始化元素的方式，下面的这种方式会自动填充零值：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">6</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums)) <span class="comment">// 6</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(nums)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<p>还可以创建一个更大容量的 slice：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">6</span>, <span class="number">12</span>) </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums)) <span class="comment">// 6</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(nums)) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p>
<p>在这里需要需要注意，虽然 slice 容量有 12，但是却不能直接访问 slice <strong>长度范围外</strong>的元素，否则会出现 panic:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(nums[<span class="number">6</span>]) <span class="comment">// panic</span></span><br></pre></td></tr></table></figure></p>
<p>要么通过扩展 slice 的长度，要么使用 append 函数来添加元素。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums = nums[:<span class="built_in">len</span>(nums)+<span class="number">1</span>] <span class="comment">// 将 slice 的长度扩展大 1</span></span><br><span class="line">nums = <span class="built_in">append</span>(nums, <span class="number">1</span>) <span class="comment">// 使用 append 将 nums 的长度加 1</span></span><br></pre></td></tr></table></figure></p>
<p>在使用上面的方式创建 slice 时，Go 会自动的创建一个底层数组来存储数据，slice 本身并不会存储数据。</p>
<p>还有一种方式是通过数组来创建 slice：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">numsArr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">numsSlice := numsArr[:] <span class="comment">// 这表示 slice 容纳数组的所有元素</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(numsSlice)) <span class="comment">// 6</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(numsSlice)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<h2>slice 的结构</h2>
<p>一般 可以把 slice 看成是一个复合结构，结构如下，由三部分组成：指针、长度和容量：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    ptr      *T</span><br><span class="line">    <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>slice 本身不会存储任何数据，slice 通过指针指向底层数组的某一个位置，这个位置就是 slice 的初始位置。长度表示当前 slice 中的元素个数，容量表示从指针的位置到底层数组的最后一个位置。</p>
<p>slice 可变长的第一个原因就是可以通过改变指针的位置来改变 slice 的长度。比如下面这样:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">numsSlice2 := numsSlice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(numsSlice2)) <span class="comment">// 2</span></span><br><span class="line">fmt.Prinltn(<span class="built_in">cap</span>(numsSlice2)) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<p>这个操作在 numsSlice 的基础上创建的一个新的 slice，其实就是移动了一下 slice 的指针。</p>
<p>另外 slice 不能使用 == 进行比较，因为 slice 的元素是非直接的，也就是 slice 本身不存储值，slice 甚至可以包含自身。另外因为 slice 的元素是靠底层的数组存储，所以当底层数组变动的时候，slice 读取到的值也会产生变化。如果 使用 == 来进行比较，可能会产生很多预料之外的结果。</p>
<h2>理解 slice 的 cap</h2>
<p>对于初学者来说，会把 slice 的长度和容量搞混。</p>
<p>先来看下面这段代码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">numsArr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">s1 := numsArr[<span class="number">0</span> : <span class="number">3</span>] </span><br><span class="line">fmt.Println(s1) <span class="comment">// [1,2,3]</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s1)) <span class="comment">// 6</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1)) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">s2 := numsArr[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(s2) <span class="comment">// [4,5]</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s2)) <span class="comment">// 3</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s2)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以发现，同样是从数组上来生成 slice，但是生成之后的 slice 的容量却不一样，在上面而我们说到了 slice 的初始位置靠指针来决定，s1 指针的位置在数组的最开始的位置。按照容量的定义，从指针到底层数组结束的地方，所以它的 容量还是 6。</p>
<p>而 s2 中，指针的位置是数组的第四个元素，长度是 3，容量也是 3。这是初学者最容易犯错的地方。</p>
<p>**长度表示 slice 中目前可访问的元素个数，容量则表示这个 slice 在不改变底层数组的情况下，最多个扩展到的长度。**如果要扩展 slice，使用下面的操作就可以：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s2 = s2[:<span class="number">3</span>] <span class="comment">// 把上面 s2 的长度从 2 扩展到 3</span></span><br><span class="line">fmt.Println(s2[<span class="number">2</span>]) <span class="comment">// 访问第三个元素</span></span><br></pre></td></tr></table></figure></p>
<p>这种方式是让 slice 可变长的第二种方式。</p>
<h2>理解 append</h2>
<p>append 方法也是让  slice 可变长的一种方式。</p>
<p>append 函数经常会配合 slice 一起使用，在使用 append 的时候，我们需要使用下面的语法：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>而且这种做法是必须的，如果没有采用这种做法，可能会产生意料之外的结果。看下面的代码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">numsArr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">s1 := numsArr[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s1)) <span class="comment">// 3</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1)) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">_ = <span class="built_in">append</span>(s1, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(s1[<span class="number">2</span>]) <span class="comment">// panic</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码在调用 append 之后，如果没有使用返回的 slice，而是直接使用原来的 slice，就会产生越界的错误。</p>
<p>因为 slice 本身虽然是可变长的，所以如果 slice 还有容量，那么每次添加元素，都需要扩展 slice 的长度，返回的也是一个新的 slice。</p>
<p>另外 slice 依赖的底层数组是固定长度，在使用 append 时，如果底层的数组不足以存储新的元素之后，就需要扩容，扩容之后就会产生一个新的 slice 返回。</p>
<p>可以理解 append 方法修改传入的 slice，而我们在调用 append 函数之后，就需要使用函数返回的结果。所以上面的代码需要修改为:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">numsArr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">	s1 := numsArr[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(s1)) <span class="comment">// 3</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s1)) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">	s1 = <span class="built_in">append</span>(s1, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(s1[<span class="number">2</span>]) <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<h2>小结</h2>
<p>slice 是一个很有用的数据接口，既可以当数组用，也可以当 list 使用。在使用 slice 的过程中，一定要注意 slice 本身不存储数据，它只是在一个底层数组上，截取不同长度序列，可以说 slice 就是一个数组的子序列。</p>
<p>另外我们说到了 slice 可变长的几种方式，一种是通过移动 slice 的指针，改变 slice 的长度，第二种是 slice 容量范围内扩展长度，第三种是通过 append 方式，这种方式会创建一个新的 slice。</p>
<p>另外我们经常会对 string 做子串的截取操作和这里 slice 工作原理是一样的。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Web3需要什么样的应用</title>
    <url>/2022/10/16/web3%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>web3 现在需要什么样的应用？</p>
<ol>
<li>公链</li>
</ol>
<p>公链也能算是一种应用，不过目前公链赛道已经有些拥挤了，而且还有 aptos 和 sui 正在准备大显身手。但我觉得在把比特币和以太坊用明白之前，造其他的链可能都显得有点急。</p>
<p>以太坊升级之后，加上 rollup 的方案，链的性能将不再是问题。那么底层最紧急的问题就解决了，之后自然就是要丰富应用层，让 web3 能真正用起来。现在 web3 中缺少的不是基础设施，而是应用。</p>
<ol start="2">
<li>数据分析</li>
</ol>
<p>做数据分析也不是一个好的赛道。数据分析这个事情在传统行业里面已经被做的太多了。币圈的数据分析不过是把数据源从传统的业务数据换成了链上的数据。这些数据源相比于传统的数据源来说，数据的量级要小很多。对于原本就是数据行业的人来说，做这个事情很简单，而对于没有做过这些事情的人来说，前期投入的成本将会巨大。数据分析在有了 dune 这样的基础设施之后，再进去卷的成本有点高。</p>
<p>而且还有人想通过对链上的数据进行分析，然后给用户打标签，对于链上用户来说，他的 NFT，他的链上行为就已经是标签了，再加一层就有点多余了。</p>
<ol start="3">
<li>游戏</li>
</ol>
<p>这个是一个更加卷的赛道，而且通常是 game + fi。想把游戏做成一个赚钱的工具，这能理解，也很合理，这个可能是以后 web3 中一个生活方式，但是首先，在它成为 gamefi 之前，它得是一个 game，要不怎么能起来。现在 gamefi 的可玩性都太低了，没有持续性。</p>
<p>游戏是一个可以做成，但是还需要时间的领域。</p>
<ol start="4">
<li>defi</li>
</ol>
<p>这个已经是一个基础的设施，想要从这里面做一些新的东西出来挺难的。</p>
<ol start="5">
<li>did</li>
</ol>
<p>did 是一个卷到投资人都不想看领域。did 确实是 web3 的一个基础设施，但方向可能有点问题。did 表示是一个身份，每一个身份都是需要经历来填充的，就比如微博上的一个大V，肯定也是某一个领域里面的大 V，正是他的经历才让他成为了一个领域里面有影响力的人。</p>
<p>在 web3 中也一样，did 肯定要伴随着一个领域。从这个角度来看，更看好伴随项目产生的身份，比如  DAO 中产生的角色，随着建设 DAO 的过程，一直在 did 中填充经历，慢慢产生影响力，在整个 web3 世界中都通用。</p>
<ol start="6">
<li>web3 还需要什么？</li>
</ol>
<p>链上的基础设施已经有很多，Defi、NFT 这些都是随时可以被用起来的功能，围绕这些基础设施去做新的应用会有很大的机会。 web3 的好应用都很轻量级，如果发现的项目需要前期投入很多，或者做的很重量级，那么就要思考一下，是不是方向有问题。</p>
<p>当前的 web3 对于普通用户来说还是太复杂了，怎么提升用户体验，让用户可以更方便、更安全地使用 web3 将会很重要。metamask 只是做了一个钱包，就掌握了大部分人进入 web3 的通道。而且 web3 的用户对应用的忠诚度会更高，毕竟 web3 中涉及的都是资产，如果出现问题，损失将会巨大，用户肯定还是愿意使用自己熟悉的应用。</p>
<p>我一直都觉得，web3 和 web2 不是对立的关系，它们最终会相互融合。目前在这方面最积极的应该就是 twitter，后面说不定可以直接使用 twitter 来互相发送 token 了。国内的即刻虽然也在做，但是鉴于目前的环境，能做成什么样就很难说。</p>
<p>总的来说，在未来很重要的方向：</p>
<ul>
<li>提升用户体验的应用或者工具，做好之后用户的忠诚度会很高</li>
<li>web3 与 web2 的融合</li>
</ul>
]]></content>
      <categories>
        <category>web3</category>
      </categories>
      <tags>
        <tag>web3</tag>
      </tags>
  </entry>
  <entry>
    <title>一文入门 Go 的性能分析</title>
    <url>/2021/08/30/%E4%B8%80%E6%96%87%E5%85%A5%E9%97%A8-Go-%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Go 为了实现更高的并发，自己实现了用户态的调度器，称之为 GMP 模型，在上一篇文章中，我们已经简单分析了它的实现。由于自己实现了 goroutine 的调度器，这也会让代码的执行过程更加复杂。而代码在执行的过程中，有可能会出现性能问题，单纯的通过日志很难排查，这就需要其他的方式来辅助。</p>
<p>Go 提供了一些工具，可以在代码运行的过程中采集一些信息，并且可以根据这些信息去生成可视化的图表，然后更方便排查问题。这些工具 Go 原生就提供了，不需要再引入其他的库。</p>
<p>在对程序进行分析，特别是对线上问题分析的时候，需要先采集数据，只有采集到数据后才能进行后续的分析，所以这篇文章我们也从两个部分出发，一部分是采集数据，另一部分是如何对采集到的数据进行分析。</p>
<h2>1. 采集信息</h2>
<h3>1.1 pprof</h3>
<p>这个工具是 Go 提供监控工具，可以实时采集程序运行过程中的性能数据。在 Go 中，有两个 pprof 的包：</p>
<ul>
<li>runtime/pprof</li>
<li>net/http/pprof</li>
</ul>
<p>其中 net/http/pprof 是对 runtime/pprof 进行了封装，提供了 Web 环境的下的访问接口，通常我们使用这个就可以。</p>
<p>这个包的使用也很简单，对于 Web 服务来说，只需要在 main.go 中引入这个包：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	_ <span class="string">"net/http/pprof"</span> <span class="comment">// 引入 pprof 包</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">		writer.Write([]<span class="keyword">byte</span>(<span class="string">"index"</span>))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"server starting"</span>)</span><br><span class="line">	http.ListenAndServe(<span class="string">":6060"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于非 Web 程序，可以通过下面的方式启动 pprof：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	_ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 其他代码</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(http.ListenAndServe(<span class="string">"localhost:6060"</span>, <span class="literal">nil</span>))</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置好了之后，直接就可以通过 <a href="http://localhost:6060" target="_blank" rel="noopener">http://localhost:6060</a>/debug/pprof/ 来采集具体的数据了，在浏览pprof 提供的接口如下：</p>
<ul>
<li>/debug/pprof/allocs : 获取内存分配的抽样数据</li>
<li>/debug/pprof/block ：获取导致同步阻塞的堆栈</li>
<li>/debug/pprof/cmdline：获取当前运行程序的命令行路径</li>
<li>/debug/pprof/goroutine：获取 goroutine 的执行堆栈</li>
<li>/debug/pprof/heap：当前活动对象内存分配的抽样（也就是堆栈内存）</li>
<li>/debug/pprof/mutex：获取互斥锁的持有者</li>
<li>/debug/pprof/profile：获取 CPU 的抽样信息</li>
<li>/debug/pprof/threadcreate：获取创建的线程信息（内核态线程）</li>
<li>/debug/pprof/trace：获取当前程序执行的轨迹（获取 GMP 以及 goroutine的调度信息）</li>
</ul>
<h3>1.2 直接在程序中获取</h3>
<p>除了通过上面的 http 接口方式采集信息，还可以直接在代码中使用代码获取信息，比如获取 trace 信息：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = trace.Start(f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取 CPU 的信息：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">"cpuprofile"</span>, <span class="string">""</span>, <span class="string">"write cpu profile to `file`"</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"><span class="keyword">if</span> *cpuprofile != <span class="string">""</span> &#123;</span><br><span class="line">    f, err := os.Create(*cpuprofile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"could not create CPU profile: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="keyword">if</span> err := pprof.StartCPUProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"could not start CPU profile: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取内存信息：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> memprofile = flag.String(<span class="string">"memprofile"</span>, <span class="string">""</span>, <span class="string">"write memory profile to `file`"</span>)</span><br><span class="line"><span class="keyword">if</span> *memprofile != <span class="string">""</span> &#123;</span><br><span class="line">    f, err := os.Create(*memprofile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"could not create memory profile: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close() </span><br><span class="line">    runtime.GC() </span><br><span class="line">    <span class="keyword">if</span> err := pprof.WriteHeapProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"could not write memory profile: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这种写代码采集的方式其实不太好，一方面，需要硬编码到代码中，特别是对于线上的代码，不好控制，所以这种方式一般不会在线上使用，线上还是会使用 Http 接口来采集信息。</p>
<h3>1.3 使用 Http 接口采集信息</h3>
<p>上面介绍了 pprof 的 Http 接口，在这里我们以采集 CPU 信息为例，可以直接在命令行使用：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8080/debug/pprof/profile?seconds=3 -o cpu.pprof</span><br></pre></td></tr></table></figure></p>
<p>上面的这条命令表示对 CPU 的信息采集三秒，然后输出到 cpu.pprof 文件中，这里文件名的后缀可以随意定义，定义为 .txt、.out、.pprof 都可以。</p>
<p>还可以采用另一种输出方式，直接采用重定向的方式输出到文件：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8080/debug/pprof/profile?seconds=3 &gt; cpu.pprof</span><br></pre></td></tr></table></figure></p>
<p>其他的信息，比如 trace 和 heap，都是采用同样的采集方式，加上 seconds，就可以设定采集的秒数。在线上环境中，这种方式很有用，既可以方便的采集到信息，又不会影响线上服务的运行。</p>
<h2>2. 可视化分析</h2>
<p>采集到数据之后，就需要进行分析，在进行数据分析的时候，我们需要用到两个工具：</p>
<ul>
<li>go tool pprof</li>
<li>go tool trace</li>
</ul>
<p>go tool pprof 可以对采集到的 CPU、内存等信息进行分析，go tool trace 则是对采集的 trace 信息进行分析。</p>
<h3>2.1 在线分析</h3>
<p>go tool pprof 既可以对采集到的离线数据进行分析，也可以是结合上面的 pprof  Http 接口，直接在线上进行分析，比如分析程序的内存使用情况:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go tool pprof -inuse_space http://localhost:8080/debug/pprof/heap</span><br></pre></td></tr></table></figure></p>
<p>go tool pprof 可以搭配的参数很多，在这里就先不展开了，上面加的 -inuse_space 就表示采集正在使用中的内存信息。</p>
<p>执行完这条命令之后，就可以进入到一个交互式的命令行：</p>
<p><img src="0.png" alt=""></p>
<p>在 这里输入 help 就可以看到所有支持的命令，发现支持的命令非常多，这里也先不都展开了。在这里用的比较多的命令是 top，输入 top 之后就可以看到占内存从大到小的排列，输入 top 10，就只会展示前  10 个。</p>
<p>还可以输入 web，直接以网页的形式展示结果（但这种方式在线上环境中通常用不了）：</p>
<p><img src="1.png" alt=""></p>
<p>通过这个图，可以直接看图的底部，基本就可以看出来那些对象占据的内存比较多，是否有内存泄漏基本也可以看出来。</p>
<p>在网页上在查看图形化结果的时候，需要安装 graphviz 库。在 Mac 上安装很简单，直接使用 Homebrew 进行安装（Homebrew 是 Mac 系统下的包管理软件，类似 Centos 中的 yum，Ubuntu 中的 apt），在 linux 系统上的安装过程类似：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install graphviz</span><br></pre></td></tr></table></figure></p>
<h3>2.2 离线分析</h3>
<p>这些图形化的结果在生产环境通常是看不了的，所以很多时候还是会把这些信息采集下来，然后在本地进行分析。内存分析的方式基本和上面一样，采集到信息之后，在本地运行：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go tool pprof memory.prof</span><br></pre></td></tr></table></figure></p>
<p>这样执行命令之后，也会进入一个与上面一样的交互式命令行环境。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go tool pprof -http=:8080 memory.prof</span><br></pre></td></tr></table></figure></p>
<p>这样会与输入 web 得到的效果是一样。</p>
<p>对于内存信息的分析，直接在线上分析就可以，但是对于 tarce 的分析，无法在线上完成，只能通过线下的方式完成。</p>
<p>采集 trace 信息：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:8080/debug/pprof/trace\?seconds\=10 &gt; trace.out</span><br></pre></td></tr></table></figure></p>
<p>开始分析 trace 信息：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go tool trace trace.out</span><br></pre></td></tr></table></figure></p>
<p>命令执行之后就会打开一个网页，提供了各项分析的指标：</p>
<p>![(2.png)</p>
<ul>
<li>View trace：可以查看 Goroutine 的可视化调度轨迹，都是以图形的方式展示</li>
<li>Goroutine analysis：可以查看到 goroutine 启动的数量及执行的时间</li>
<li>Network blocking profile：对网络阻塞的分析</li>
<li>Synchronization blocking profile：对同步阻塞的分析</li>
<li>Syscall blocking profile：对系统调用阻塞的分析</li>
<li>Scheduler latency profile：对调度器延迟的分析</li>
</ul>
<p>在进行问题排查的时候，可以先从调度器的总体的延迟看起，找到延迟比较大的区域，然后进行分析，是网络的原因、还是锁的原因、或者是系统调用的原因。</p>
<h2>3. 小结</h2>
<p>这篇文章中，我们介绍了 Go 语言常用的性能分析工具，特别是在分析线上数据的时候，需要先采集数据，采集到数据之后，再对数据进行分析。而 Go 刚好都提供了相应的工具，pprof 和 go tool trace，大大简化了 Go 程序分析的难度。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>一文看懂椭圆曲线签名算法</title>
    <url>/2022/01/09/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>如果接触过区块链，大概率听说过椭圆曲线签名算法。这个算法是区块链链技术的基石。但这个算法很抽象，很难理解，这篇文章会通过简单易懂的方式来介绍一下这个算法，尽量不涉及大量的公式，其中很多的数学证明会直接忽略，我们直接使用证明的结果。</p>
<h2>1. 对称加密与非对称加密</h2>
<p>在加密算法中，对称加密和非对称加密是两类主要的加密算法。使用对称加密算法时，需要双方都知道相同的密钥，加密和解密需要使用相同的密钥，相对来说，对称加密的效率比较高，比如我们熟知的 AES 加密算法。</p>
<p><img src="0.png" alt=""></p>
<p>但是对称加密有个问题，密钥传输是个大问题，如果在网络上传输密钥被人截获的话，那么加密的数据就很不安全了。</p>
<p>解决这个问题，就需要使用非对称加密算法。非对称加密的密钥分为公钥和私钥，公钥是可以放出去的，任何人都可以拿到你的公钥，让后用公钥加密，经过公钥加密的数据只有你手上的私钥可以解密。这样每个人只要放出自己的公钥，别人就能给你安全的传输数据。</p>
<p><img src="1.png" alt=""></p>
<p>但是非对称加密还有个问题，相比于对称加密，效率会低很多，如果把非对称加密用于网络流量很大的环境下，会对性能有很大的影响，所以在实际的使用中，通常是这两种算法结合使用，比如 HTTPS 中通过非对称加密来建立连接，传输对称加密的密钥，而后续的数据传输则使用对称加密算法。</p>
<p>而且非对称加密算法还有一种妙用，<strong>用来签名</strong>。如果对一个数据使用私钥去签名，别人可以用公钥快速的来检查这个签名是不是合法，这是区块链技术的基础之一。</p>
<p><img src="2.png" alt=""></p>
<p>这里需要注意一下：<strong>使用公钥叫加密数据，使用私钥叫签名</strong>。</p>
<p>RSA 和 ECC（Elliptic Curve Cryptography） 是两类比较出名的非对称加密算法，RSA 利用的是质数分解的原理来实现安全性。但是 RSA 对密钥长度的要求越来越高，这样也会造成计算量很大，而 ECC 使用的密钥长度则要短的多，而且安全性也更强。</p>
<p>本文所说的 ECDSA（Elliptic Curve Digital Signature Algorithm）算法是基于 ECC 的的一种签名算法，广泛用于区块链、HTTPS 等需要非对称加密的场景。</p>
<h2>2. 椭圆曲线算法</h2>
<h3>2.1 椭圆曲线的表示</h3>
<p>椭圆曲线其实是一个数学方程，通常用下面的方程式来表示:</p>
<p>$$
y^2 = (x^3 + a \times x + b)\quad mod\quad p
$$</p>
<p>如果 a 和 b 取的值不同，那么对应的曲线形状也会不一样：</p>
<p><img src="3.png" alt=""></p>
<p>上面的这些曲线的对应的是 $b = 1$，$a$ 的取值范围是2 ~ -3 分别对应的曲线。</p>
<p>在上面的方程式中，$x$ 的取值只能是整数，不能是浮点数。还要加上以 $p$ 为底的取模运算，那么 $y^2$ 的取值就在 0 ~ $p$-1 之间，由于 $x$ 只能是整数，那么说明能够取到的点也是有限的，记作 $N$。</p>
<p>关于椭圆曲线，我们了解这些就够了。</p>
<h3>2.2 椭圆曲线的运算</h3>
<p>在正式说到椭圆曲线签名算法之前，我们还需要需要了解一下在椭圆曲线上的两种运算，点加法（Point Addition）和点乘法（Point Multiplication）。</p>
<p><img src="4.png" alt=""></p>
<p>假设现在有这样一条椭圆曲线。画一条直线，与曲线相交于 3 个点，分别是 $P, Q,R$，根据点加法运算的定义，可以得到 $P + Q+R = 0$，那么 $P + Q = -R$， $-R$ 的定义是关于 $x$ 轴对称所得到的一个点，如上图所示，这就是点加法的定义。</p>
<p>如果我们移动这条直线，让 $P,Q$ 两点重合：</p>
<p><img src="5.png" alt=""></p>
<p>根据上面的点加法规则，可以得到 $2P$ 点，以此类推，不断去连接 $$ $P$ 点和 $nP$ 点，就可以得到 $3P,4P...$ $(n+1)P$ 点。点乘就定义为 $k \times P$，表示 $P$ 点的 $k$ 次相加。</p>
<h3>2.3 单向陷门函数</h3>
<p>上面说完了椭圆曲线的定义和运算，最后来说一下椭圆曲线的安全性，对于非对称加密来说，关键点就是无法从加密的数据中和公钥中去推算私钥，这里怎么实现的呢？</p>
<p>在上面我们得到了点乘的定义，任意一点$R$ 可以通过这个点乘公式 $R = k\times P$ 计算得到。这里的关键在于即使知道了 $P$ 和 $R$ 点，我们也无法计算得到 $k$，在椭圆曲线算法中没有减法或者除法这种逆向操作。 这是椭圆曲线算法安全性的基础，这个特性也称之为单向陷门函数。</p>
<p><strong>这个整数 $k$ 通常就是算法中的私钥，而 R 对应的就是公钥</strong>。</p>
<h2>3. 椭圆曲线签名算法</h2>
<p>上面已经介绍完椭圆曲线的特性，下面来看一下椭圆曲线签名算法是如何利用椭圆曲线的特性来完成签名的生成和验签。</p>
<p>在使用签名算法之前，需要确定一条椭圆曲线，根据上面知道，如果参数选的不同，那么椭圆曲线方程就会不一样。其中 $G$ 是一个选定的初始点，后面所有的运算都会基于这个点开始。</p>
<p><strong>然后需要定义一对公私钥，根据上面的定义 $P = k \times G$，其中，$k$ 是一个随机整数，对应为私钥 $k0$，$P$ 表示椭圆曲线上的一个点，对应为公钥 $P0$</strong>。</p>
<h3>3.1 生成签名</h3>
<p>在生产公钥和私钥之后，就可以用以下步骤来生成签名：</p>
<ol>
<li>生成一个随机数 $k1$，注意这个随机数不是上面生成的私钥</li>
<li>利用 $P = k1 \times G$ 计算点 $P1$，注意这个不是上面的公钥</li>
<li>$P1$ 点的 x 坐标就是 $R$</li>
<li>对需要签名的数据计算 hash，为 $H$</li>
<li>计算 $S = k1^{-1}(H + k0 \times R)\quad mod \quad p$，这个 $p$ 是模运算的底，也需要提前指定好</li>
</ol>
<p>通常签名的长度是 40 字节，前面 20 字节是 R，后面 20 字节是 S，R 和 S 拼接在一起就是最后的 DCSDA 签名。</p>
<h3>3.2 验证签名</h3>
<p>验证签名的过程更简单，只需要通过下面的公式：</p>
<p>$$
P = S^{-1} \times H \times G + S^{-1} \times R \times P0
$$</p>
<p>$P0$ 是公钥，通过这个公式，很容易就是可以计算得到 $P$， 得到 $P$ 之后，如果 $P$ 的 $x$ 坐标等于 $R$，那么就验签成功，在验签的过程中，完全不需要私钥的参与。</p>
<p>在上面的算法中，可以发现，除了签名者手上的私钥 $k0$ 之外，在签名的过程中还会生成一个随机数 $k1$，这个随机数很关键，如果这个数字不够随机，或者使用固定的数字，那么就额可以通过两次签名的使用的哈希值 $H$ 和 $H'$ 以及 $S$ 和 $S'$ 来计算这个 $k1$。</p>
<p>如果 $k1$ 知道了，就可以利用上面生成 $S$ 的公式来计算出私钥 $k0$，这样一来，私钥就泄漏了。在 2010 年，索尼的 PS3 上就是因为随机数 $k1$ 总是返回一个固定的数字，导致产生了这个安全漏洞。</p>
<h2>4. 小结</h2>
<p>椭圆曲线签名算法相比于 RSA 算法要更加安全，使用的密钥位数也更短。已经在很多领域里面被使用，HTTPS、区块链。这个算法的安全性来源于<strong>单</strong>向**陷门函数，**无法通过计算反向推出私钥，这也是这个算法最巧妙的地方。</p>
<p>文 / Rayjun</p>
<p>[1] <a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Elliptic-curve_cryptography</a></p>
<p>[2] <a href="https://www.instructables.com/Understanding-how-ECDSA-protects-your-data/" target="_blank" rel="noopener">https://www.instructables.com/Understanding-how-ECDSA-protects-your-data/</a></p>
<p>[3] <a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/" target="_blank" rel="noopener">https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么Java二维数组不用指定列的长度</title>
    <url>/2020/09/06/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8D%E7%94%A8%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<p>在使用 Java 数组的时候，假如要新建一个二维数组，可以使用以下的方式来新建，只需要指定属数组第一维的长度：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br></pre></td></tr></table></figure></p>
<p>不用指定第二维的的长度，就可以创建完成。这与 Java 中数组内存分配的方式有关，这篇文章会详细分析 Java 数组的内存分配机制及原理。</p>
<p>本文基于 JDK11</p>
<h2>数组的定义和初始化</h2>
<p>Java 中的数组与其他语言中的数组没有什么区别，内存都是连续分配，可以通过下标直接访问数组的内容，而且数组中存放的数据需要一致：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr1[<span class="number">1</span>] = <span class="number">1.1</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p>
<p>数组的长度在创建之后不能改变，如果访问超出长度范围外的位置就会报错。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">arr1[<span class="number">3</span>] = <span class="number">0</span>; <span class="comment">// 报错，超出数组长度范围，ArrayIndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure></p>
<p>定义数组有多种方式，据说第二种声明的方法是为了吸引 C 和 C++ 的程序员，但是第一种声明方法才是官方更加推荐的方式。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> arr1[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p>
<p>再回到二维数组，如果按照下面的方式使用而且数组，就会报错，这与数组的内存分配有关，下文会详细说明。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line">arr1[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p>
<p>如果要直接使用，需要指定列的长度，下文会再讲一种初始化的方式。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">arr1[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 正常运行</span></span><br></pre></td></tr></table></figure></p>
<p>如果要初始化一维数组：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>初始化二维数组：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>二维数组每维的长度都可以不一样：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于二维数组，可以被认为是数组的数组，其实二维数组的每一行都是一个单数的数组：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = arr1[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p>
<p>二维数组在初始化的时候不需要指定行列的数量，其他多维数组的创建方式类似。</p>
<p>数组最多可以到 255 维，超过 255 维在编译的时候就会出现错误。</p>
<h2>数组的内存结构</h2>
<p>为了能把上面二维数组的问题说清楚，需要先对数组的内存结构做一个说明。</p>
<p>Java 程序在运行的过程中，会为每个线程分配单独的栈空间，如果声明一个数组变量，那么变量就在栈中分配。</p>
<p>而 Java 中对象都是在堆上分配内存，Java 数组也是对象，所以数组也在堆上分配内存。</p>
<p>所以对于一维数组来说，就是如下的结构，栈中变量保存指向数组实例的引用。</p>
<p><img src="1.png" alt=""></p>
<p>对于二维或者多维数组来说，情况就有所不同。二维数组可以被认为是数组的数组。</p>
<p>数组中保存的是指向另一个数组的引用，如下图所示。</p>
<p>也就是说，每个数组中的第二维的长度可以不同。所以如果声明一个新的二维数组，只需要指明第一维的长度，就可以创建好一个数组。但在正式使用之前，还是要将其他维度初始化。</p>
<p><img src="2.png" alt=""></p>
<p>上述例子中使用的都是原生数据类型，原生类型数组存的是值，对于对象数组来说，其中存储的是对象引用。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么你应该使用markdown写作</title>
    <url>/2018/10/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8markdown%E5%86%99%E4%BD%9C/</url>
    <content><![CDATA[<p>如果说哪个技能一直值得花时间去磨练，我想可能就是写作了。好记性不如烂笔头，再好的记忆力都不如将想法落实到文字上好。</p>
<p>现在可以进行文字记录的软件非常的多，而且可以发现它们大多数都在慢慢的支持一个格式：markdown，所有主流的的编辑器上基本也支持 markdown 的扩展。markdown 是一种轻量级的标记语言。轻量级到了什么程度呢，在码字的过程中，只需要额外敲几个#号就行了。不太理解？看图。</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/3F0AC7ED-A403-4840-80E1-4FBDA431E32D.png" alt=""></p>
<p>在渲染完成之后是如下的效果，不同的编译器渲染出来的效果略有差别。</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/D703AF4E-A8D9-4336-8268-C11907C383AA.png" alt=""></p>
<p>然后还是有以下的一些简单语法可以让文档更有层次感，而且可以突出重点。</p>
<ul>
<li>加链接：  [说明] (URI)</li>
<li>加图片：  ![说明] (URI)</li>
<li>加粗：** <strong>加粗</strong> **</li>
<li>斜体字：* <em>斜体字</em> *</li>
<li>高亮：==高亮==</li>
<li>引用：&gt;</li>
<li>内嵌代码：<code></code></li>
<li>分割线：--------</li>
</ul>
<p>学会这个语法应该用不了5分钟。写markdown文档就这么简单。markdown 文档的编辑器也很多，开源的也不少，所以学会这个技能基本不需要什么成本。</p>
<p>而且 markdown 的扩展性也很强，在 markdown 中甚至可以兼容 html 语法，markdown 文档可以导出为 pdf， LaTex。借助于一些特定的工具，甚至可以生成 PPT、Word 等格式。写作的基本格式还是要遵守的，通过这份文档可以学会必要的排版。<a href="https://github.com/mzlogin/chinese-copywriting-guidelines" target="_blank" rel="noopener">https://github.com/mzlogin/chinese-copywriting-guidelines</a></p>
<p>基本上 github 和类似的开源平台上都是使用 markdown 来写文档，诸多的的博客平台也都支持 markdown。通过 markdown 来写作，基本上就可以把精力集中在写作本身，而不用太多的去关注格式的问题。其实写 markdown 某种程度上与思维导图是一样的，都是通过树结构来理清思路和观点的，思维导图可以快速的梳理结构，markdown 用来填充更多的内容， 然后形成一篇完整的文档。</p>
<p>在学会 markdown 后，任何的编辑器都可以成为写作的工具，只要用简单的语法就可以保证最后的排版是整齐美观的。对于每个人，注意力可以说是最重要的财富了，能够提升效率的工具都值得尝试。人生苦短，我用 markdown。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 DID 身份，为什么需要 DID</title>
    <url>/2021/12/26/%E4%BB%80%E4%B9%88%E6%98%AF-DID-%E8%BA%AB%E4%BB%BD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-DID/</url>
    <content><![CDATA[<p>DID 的全称是去中心化身份（<strong>Decentralized Identity</strong>）。去中心化身份是从传统的身份体系中演化而来的。从中心化身份、联盟身份、以用户为中心的身份、再到去中心化身份，总共经历了四个个阶段。理想情况下，在去中心化身份阶段，用户可以完全掌控自己的信息。</p>
<p>DID 不仅仅是一种新的身份标识方式，还是未来数字身份体系和 DPKI 体系中的重要组件。DPKI （D<strong>ecentralized Public Key Infrastructure</strong>）是指去中心化公钥基础设施。与之相对应的是 PKI 体系，目前的 SSL/TLS 协议就是最大的 PKI 体系。DID 在未来有可能是最大的 DPKI，会与 SSL/TLS 协议有相同的影响力。</p>
<h2>1. 中心化身份的问题</h2>
<p>中心化的身份就是我们现在用的最多的身份类型，使用微信、淘宝、微博都需要注册一个新的身份，要把我们的信息重新收集一遍。平台上的用户数在增长到一定程度的时候，就会进入瓶颈期，因为用户的总数是有限的，而平台对利润增长的期望是无限的。继续的利润增长只能持续的通过各种方式去获取新的用户，并且从用户的数据中提取更大利润。</p>
<p>类似 FaceBook 基本就是靠用户的信息来挣钱，但是这样的商业模式存在很大的问题，平台利用用户的数据获取利润后，只有很少部分才能到达用户那。而且用户的数据在被收集之后，中心化的存储会让用户的数据暴露在巨大的风险之下，互联网上出现用户数据泄漏、买卖的情况屡次出现。 在 FaceBook 上就出现了很多次。</p>
<p>中心化的身份还有一个很大的问题，就是注销困难，有的软件虽然提供了注销的渠道，但是你无法确认你的账号是否真的被注销了。</p>
<p>最近炒的很火爆 Web3，最终的目标就是让数据回归到用户本身，用户对自己的数据有完全的处置权。</p>
<h2>2. 为什么 DID 一定会出现</h2>
<p>个保法的出台意味着个人对信息保护越来越重视。而 DID 主要的两个特性就是<strong>安全</strong>和**隐私保护，**刚好可以解决这个问题。</p>
<p>DID 可以让我们在不暴露自己隐私的情况下，就可以完成身份认证。比如你去网吧上网，不再需要是刷身份证和做人脸识别了，只需要证明你满了 18 岁即可。网吧也无法收集到你的信息，只知道你符合上网的年龄。</p>
<p>在现在讨论的很多的元宇宙中，所有的身份必然是要打通的，元宇宙本身是去中心化的，那么身份本身也是需要去中心化的，由用户自己保管。</p>
<p>另外 DID 不仅仅可以用来标识人，还可以用来标识设备、组织等等，可以满足未来更加丰富的场景。 DID 本身很安全，因为在 DID 中，不包括任何具体的用户信息。而且 DID 是可控的，可以任意产生和注销。DID 本身没有特别的存储要求，就是把这些信息直接记录在一张纸上也是有效的。</p>
<h2>3. DID 要怎么实现</h2>
<p>DID 自下而上包括 4 个组成部分。网络协议、分布式账本、DID 协议和具体的应用程序。网络协议层没有太大的变化，还是建立在 TCP/IP 的基础之上。具体的数据一般会存储在区块链和一个去中心化的存储系统中。针对不同的系统，要实现具体的 DID 协议。最后就是 DID 在具体场景中的使用。</p>
<p>整个 DID 系统的分层如下：</p>
<p><img src="0.png" alt=""></p>
<p>在 W3C 的标准中，DID 分成两部分，一部分是基础层，主要提供 DID 的存储和不可以篡改的保证，为上层的应用层提供服务。包括：</p>
<ul>
<li>DID 标识符（identifier）</li>
<li>DID document</li>
</ul>
<p>一部分是应用层，用户并不是直接使用 DID 在来进行验证，而是会使用<strong>可验证声明</strong>（Verifiable Credentials），简称 VC。 VC 的产生、传输和验证都是在应用层进行的。</p>
<h3>3.1 DID 基础层</h3>
<p>DID 标识符其实就是一个字符串，在 W3C 的草案中，DID 参考的是 URN 的标准，格式如下:</p>
<p><img src="1.png" alt=""></p>
<p>开头永远是 did，did method 是实现这个 DID 系统的名称，最后是系统生产的一个字符串。腾讯云基于 DID 标准开发了一个<a href="https://cloud.tencent.com/product/tdid" target="_blank" rel="noopener">分布式身份系统 TDID</a>，那么 TDID 服务产生的 DID标识符格式如下：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">did:tdid:15:0xbd7345b2ff8d1dbf1e330a6c5dcf20c675b6c484</span><br></pre></td></tr></table></figure></p>
<p>DID 对外的字符串实际上会作为一个 key，对应的 value 就是 did document，具体的信息会在 document 中。document 是一个标准的 Json，其中会包括一些用户的公钥、所使用的 DID 协议以及 DID 的服务请求地址、时间戳、签名等信息，下面是一个示例信息：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"@context"</span>: <span class="string">"https://w3id.org/did/v1"</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"did:example:123456789abcdefghi"</span>,</span><br><span class="line">  <span class="attr">"authentication"</span>: [&#123;</span><br><span class="line">    // used to authenticate as did:...fghi</span><br><span class="line">    "id": "did:example:123456789abcdefghi#keys-1",</span><br><span class="line">    "type": "RsaVerificationKey2018",</span><br><span class="line">    "controller": "did:example:123456789abcdefghi",</span><br><span class="line">    "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"</span><br><span class="line">  &#125;],</span><br><span class="line">  "service": [&#123;</span><br><span class="line">    // used to retrieve Verifiable Credentials associated with the DID</span><br><span class="line">    "id":"did:example:123456789abcdefghi#vcs",</span><br><span class="line">    "type": "VerifiableCredentialService",</span><br><span class="line">    "serviceEndpoint": "https://example.com/vc/"</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DID 标识符和 DID document 会被存储在区块链和去中心化存储上。在上面的图中，下面的两层都是为 DID 标识符和 DID document 服务的。</p>
<p>区块链的选用很灵活，可以是公链、联盟链、甚至可以是私有链，都可以用来部署 DID。</p>
<h3>3.2 DID 应用层</h3>
<p>最上面那层，就是可验证层。其中 issuer 是真实拥有用户信息的机构、比如政府、银行、大学等机构，可以颁发 VC。IV （Inspector-Verifier）接收 VC 并进行验证。Holder 是 VC 的拥有者，会向 Issuer 申请并获得 VC，同时这些 VC 会上链存储，Holder 拿到 VC 后就可以放在钱包中，可以多次使用。</p>
<p>在 Issuer 颁发 VC 时，然后会调用底层的 DID 系统，生成 DID 标识符和 DID document，然后将这些信息一起打包在 VC 中给到用户。用户在出示 VC 后，IV 就可以拿着 VC 进行验证。</p>
<p>在这里有一个问题，那么既然 Issuer 可以开具可信的 VC 为什么还需要用到区块链呢？因为在这里 IV 除了验验证 VC 的合法性之外，还需要验证 VC 属于当前持有的用户。在这种情况下，通过用户手上的私钥，可以很轻易的在链上验证用户是否是这个 VC 的持有者。</p>
<h2>4. DID 的隐私保护</h2>
<p>在这里需要注意，用户的具体信息并不会在 document 中存储，而是用链下存储的方式，即使是使用加密或者 hash 的方式也不行。一方面，这些信息会被永久的写到区块链上，如果使用的加密算法被攻破，那么所有的信息都会暴露。如果使用 hash，在多个地方使用后，就会被人推算出相关性，因为 hash 是不变的。个人隐私信息，只有在真正需要的时候通过安全的点对点方式传输。</p>
<p>另外，在不同的场景，最好使用不同的 DID 标识符，一方面是不同场景需要披露的信息不一样。另外使用不同的 DID 也可以避免被人进行关联性分析。尽量使用不同的 DID 标识符，因为单纯的通过  DID 标识符无法判断是否由一个人产生的。</p>
<p>最后，在使用信息的时候，选择性的披露自己的信息，比如在一些场景，只需要披露自己已成年，但是并不需要具体的出生日期。</p>
<p>文 / Rayjun</p>
<p>[1] <a href="https://github.com/WebOfTrustInfo/rwot1-sf/blob/master/final-documents/dpki.pdf" target="_blank" rel="noopener">https://github.com/WebOfTrustInfo/rwot1-sf/blob/master/final-documents/dpki.pdf</a></p>
<p>[2] <a href="https://en.wikipedia.org/wiki/Self-sovereign_identity" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Self-sovereign_identity</a></p>
<p>[3] <a href="https://en.wikipedia.org/wiki/Decentralized_identifier" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Decentralized_identifier</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>与原则一起生活</title>
    <url>/2018/04/21/%E4%B8%8E%E5%8E%9F%E5%88%99%E4%B8%80%E8%B5%B7%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<p>​       在原则这本书入手后，已经看了两遍了。不得不说，高手就是高手，可以把复杂的事情讲的非常简单。在这本书里面，基本可以回答绝大多数人在日常生活和学习中会碰到的问题。只要有时间管理和工作方法等方面的问题，认真读读这本书，基本就能解答大部分的困惑。在这本书中也许找不到适合自己的方法和原则，但是却可以发现自己的问题。这才是最重要的，正确的认识到问题事情就成了一半了。</p>
<p>​      这本书里面作者大量的讲解了自己用于生活和工作的原则。这些原则其实读完之后我已经记不得多少了，因为我觉得对于这本书来说，这个不是最重要的部分。作者的生活和工作环境其实与其他人都是有着很大的不同，所以去生搬硬套这些原则的价值并不是很大，但是却可以学习到作者制定这些原则的原则。我理解到的是<strong>量化</strong>和<strong>生态系统</strong>。</p>
<h4>量化</h4>
<p>​       量化可以说是整本书当中最重要的部分了。因为所以的原则都是量化的体现。作者在书中指定的大量的原则都是基于量化的基础上来执行的。这里所说的量化并不是狭义上的精确到数字，而是对目标的量化。经常会出现的生活体验中，经常会出现没有对结果做量化而带来的问题。比如背单词，背着背着就没有然后了，看一本书，打开看了序言后就没有然后了。这些问题的出现都是因为在做一件事请之前没有对做这件事的结果进行量化。量化目标能帮助对实现的效果进行检验。不去对目标做量化是一种思维的懒惰，付出再多的时间也很难得到一个满意的结果。</p>
<p>​        量化还是一种发现问题的好方法。量化目标之后，就可以对整个过程进行检验，顺利的达到目标，说明做事的方法没有问题。如果没有达到预期的目标，那么说明肯定是中间的某个部分出了问题，就可以把这个问题追根溯源找出来。总的来说，量化一个事情需要做到以下的5步:</p>
<ul>
<li>设定目标：为要做的一件事定一个明确的目标</li>
<li>问题发现：做的过程中发现影响事情推进的问题</li>
<li>问题分析：对这些问题做根本的分析，一定要找出最根本的原因</li>
<li>解决问题规划：对这些问题的解决做出规划，能自己解决的自己解决，自己解决不了的寻求帮助</li>
<li>任务规划：对这些待解决这些问题同样设定目标和解决时限</li>
</ul>
<h4>生态系统</h4>
<p>​       机器是作者另外大篇幅提到的一个点。作者的企业的成功也正是在机器的高效下得以实现。作者对人脑和大自然有着很深的研究，在他的观点里，大自然的每一个生物，每一个细胞也都是一部机器，都在按照某种原则在运转。于是他就依靠制定这些原则将整个公司打造成一部高效运转的机器，目前的情况证明，他的这种做法是非常有用的。对于一个特定的任务，机器总是要比人更少的犯错误。但是最终的决策还是要靠人来做，所以这种人+机器的组合目前来看是非常成功的组合。</p>
<p>​       作者的企业也是按照这种方式去进化的。我这里用到了进化的这个词，没错这就是让我感触最深的一个词。作者的厉害之处在于他将整个企业打造成了一个可以进化的生态系统。这是一个离开了他依然可以高效运转的机器。他将公司的每一个部门都作为整个机器的一部分，也是一个独立的机器，每个机器之间的运转互不干扰。然后在量化这个工具的帮助下，他们可以去发现机器运转过程中存在的问题，有会有专门的机器去消化这些问题，让整个机器的运转更加的高效，从而实现整个系统的进化，这就与大自然中生态系统的进化很类似了。伟大的思想总是同根同源的，这种方式让我想起了近年来非常流行而且在未来也肯定是潮流的软件架构方式-----微服务。作者对软件的行业肯定不是那么的在行，但是他却可以设计出如此高效的原则。</p>
<p>​      生态系统的构建并不是短时间内就可以完成的事情，而是一件需要长期投入的事情。而在构建生态系统时，最重要的工具就是量化。</p>
<p>这是一本任何人都值得好好读的书。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原则</tag>
      </tags>
  </entry>
  <entry>
    <title>NFT 这么火，你知道 ERC721 么</title>
    <url>/2021/09/19/NFT-%E8%BF%99%E4%B9%88%E7%81%AB%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93-ERC721-%E4%B9%88/</url>
    <content><![CDATA[<p>如果对币圈稍微有些关注的人，这几个月一定被 NFT 刷屏了。面对一张张卖出天价的 NFT，绝大多数人都无法理解，其实对于 NFT，贵的不是那张图，而是大家的共识。</p>
<p>这篇文章暂时不讨论 NFT 的价值问题，而是来起底一下 NFT 的技术支撑。</p>
<p>目前绝大多数的 NFT 资产都在以太坊发行，占了主流资产的 90% 以上。目前 NFT 的发行标准最主流的是 ERC721，这已经成为事实上的标准。</p>
<h2>ERC 是什么</h2>
<p>在开始说 ERC721 之前，需要先说明一下 ERC，以太坊还在不断的发展，包括协议和各类标准，就像互联网行业的 RFC 一样，每个人都可以都对以太坊的发展提出自己的意见。每个意见都被称之为 EIP（Ethereum Improvement Proposals），直接在这个 GitHub 仓库（<a href="https://github.com/ethereum/EIPs" target="_blank" rel="noopener">https://github.com/ethereum/EIPs</a>）中提交。</p>
<p>EIP 的完整流程如下：</p>
<ul>
<li>Draft：由作者提交的建议，还在做主要的修改</li>
<li>Review：建议已经基本完成，可以进行 EIP 评审</li>
<li>Last Call：评审完成，这个建议有可能成为最终版</li>
<li>Accepted：这个建议在等待以太坊开发者的实现或者部署</li>
<li>Final：EIP 会成为一个以太坊的标准</li>
</ul>
<p>大多数的 EIP 都会止步于 Review 阶段。</p>
<p>ERC（Ethereum Request for Comment） 用于记录以太坊上的各种开发标准和协议，部分 EIP 会成为 ERC。 ERC 都是 EIP，反之则不对。</p>
<p>ERC 721 也是通过这个流程提出来的。</p>
<p>ERC 721 的全称是非同质化代币标准（Non-Fungible Token Standard）。以太币和在以太坊网络上流通的一些代币称之为同质化代币。这些同质化代币发行的标准是 ERC 20 标准。如果代币不实现这些标准，那么就无法在以太坊网络中流通。</p>
<p>从流通的角度来说，ERC 721 和 ERC 20 的实现都是以太坊网络中的代币。它们最大的区别在于，ERC 721 的每一个代币都是独一无二的，有着自己的属性，相互之间是不等价的。而 ERC 20 的每一枚代币都是相同的，是等价的。</p>
<h2>ERC 721 协议详解</h2>
<p>ERC 721 其实是定义了一系列的接口，如果写过 Java 的人会发现，这个接口的形式与 Java 的非常类似。下面接口定义使用的以太坊的智能合约语言 Solidity：</p>
<p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line">interface ERC721 <span class="comment">/* is ERC165 */</span> &#123;</span><br><span class="line">    </span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);</span><br><span class="line"></span><br><span class="line">    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);</span><br><span class="line"></span><br><span class="line">    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _owner</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">ownerOf</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">safeTransferFrom</span>(<span class="params">address _from, address _to, uint256 _tokenId, bytes data</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">safeTransferFrom</span>(<span class="params">address _from, address _to, uint256 _tokenId</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">transferFrom</span>(<span class="params">address _from, address _to, uint256 _tokenId</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">approve</span>(<span class="params">address _approved, uint256 _tokenId</span>) <span class="title">external</span> <span class="title">payable</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">setApprovalForAll</span>(<span class="params">address _operator, bool _approved</span>) <span class="title">external</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">getApproved</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">isApprovedForAll</span>(<span class="params">address _owner, address _operator</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">ERC165</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">supportsInterface</span>(<span class="params">bytes4 interfaceID</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">ERC721TokenReceiver</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onERC721Received</span>(<span class="params">address _operator, address _from, uint256 _tokenId, bytes _data</span>) <span class="title">external</span> <span class="title">returns</span>(<span class="params">bytes4</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">ERC721Metadata</span> /* <span class="title">is</span> <span class="title">ERC721</span> */ </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">string _name</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">symbol</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">string _symbol</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">tokenURI</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">string</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">ERC721Enumerable</span> /* <span class="title">is</span> <span class="title">ERC721</span> */ </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">tokenByIndex</span>(<span class="params">uint256 _index</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">tokenOfOwnerByIndex</span>(<span class="params">address _owner, uint256 _index</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>balanceOf 方法用来判断一个地址下有多少个 NFT，ownerOf 方法用来判断一个 NFT 是不是属于一个地址。transferFrom 和 safeTransferFrom 都是用于 NFT 的转账，但是 safeTransferFrom 在把  NFT 转到零地址时会报错。零地址就是以太坊中的黑洞，任何转入其中的资产都无法取出。</p>
<p>approve 类的地址就是把自己的 NFT 托管给其他管理，这点要注意，千万随意在陌生的网站上执行力 approve 操作，特别是 setApprovalForAll 方法，否则自己的 NFT 别人就尅随意操控了。</p>
<p>如果要你要发行自己的 NFT，使用 solidity 实现之后，发布到以太坊上，就发行成功了。在 ERC 721 中，推荐把上面的所有接口都实现。</p>
<p>在 ERC 721 中，基本包含了 ERC 20 的所有的接口，非同质化代币虽然是独一无二的，但也需要能够转账等代币的基础特性。</p>
<p>相比于 ERC 20，ERC 721 最大的不同是 有了 <code>ERC721Metadata</code> 这个接口，这个接口可以用来标识每一个非同质化代币的属性，也就是 NFT 的元数据。每个非同质化代币的具体属性都通过 <code>tokenURI</code> 这个方法来返回。我们在 OpenSea 上看到的那些 NFT，都是通过调用这个方法获取 NFT 的详情。</p>
<p>实现 ERC721 时，必须实现 ERC165 协议，这个用来检测当前的合约的是否实现了某个接口，在以太坊中，每一个 interface 都有自己的 interfaceId，比如 ERC165 的是 0x01ffc9a7，ERC 721 的是 0x80ac58cd，ERC721Metadata 的是 0x780e9d63，ERC721Enumerable 的是 0x5b5e139f。</p>
<p>ERC721TokenReceiver 用于在调用 transfer 方法之后的回调，如果传的值对不上，就会导致这次 transfer 失败。</p>
<p>ERC721Enumerable 接口中则实现了 NFT 的一些不变的属性，比如总供应量，通过代币的序号来获取 NFT，列举某个地址下的所有 NFT。</p>
<h2>ERC 721 实例</h2>
<p>一起来看一下  Meebits 的智能合约，合约的地址可以在 <a href="https://www.notion.so/f11d2bfc23c34f18275bbf23bb716bc7" target="_blank" rel="noopener">https://etherscan.io/address/0x7bd29408f11d2bfc23c34f18275bbf23bb716bc7#code</a> 这里看到。这就是以太坊上应用的神奇之处，所有的代码都是公开的。</p>
<p>Meebits 是 Larva Labs 发行的一组 NFT，总数2 万个。</p>
<p>代码的总行数只有 679 行，逻辑都还是比较简单的。比如我们上面说到标识 NFT 元数据的 <code>tokenURI</code> 方法，Meebits 是这样实现的：</p>
<p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenURI</span>(<span class="params">uint256 _tokenId</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">validNFToken</span>(<span class="params">_tokenId</span>) <span class="title">returns</span> (<span class="params">string memory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> string(abi.encodePacked(<span class="string">"https://meebits.larvalabs.com/meebit/"</span>, toString(_tokenId)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上是指向了另外一个地址，我我们在这个 url 后面随机输入一个编号，就可以得到一个 Meebits 的元数据：</p>
<p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://meebits.larvalabs.com/meebit/1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Meebit #1"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"Meebit #1"</span>,</span><br><span class="line">  <span class="string">"image"</span>: <span class="string">"http://meebits.larvalabs.com/meebitimages/characterimage?index\u003d1\u0026type\u003dfull\u0026imageType\u003djpg"</span>,</span><br><span class="line">  <span class="string">"attributes"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"trait_type"</span>: <span class="string">"Type"</span>,</span><br><span class="line">      <span class="string">"value"</span>: <span class="string">"Human"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"trait_type"</span>: <span class="string">"Hair Style"</span>,</span><br><span class="line">      <span class="string">"value"</span>: <span class="string">"Bald"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"trait_type"</span>: <span class="string">"Hat"</span>,</span><br><span class="line">      <span class="string">"value"</span>: <span class="string">"Backwards Cap"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"trait_type"</span>: <span class="string">"Hat Color"</span>,</span><br><span class="line">      <span class="string">"value"</span>: <span class="string">"Gray"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"trait_type"</span>: <span class="string">"Shirt"</span>,</span><br><span class="line">      <span class="string">"value"</span>: <span class="string">"Skull Tee"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"trait_type"</span>: <span class="string">"Overshirt"</span>,</span><br><span class="line">      <span class="string">"value"</span>: <span class="string">"Athletic Jacket"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"trait_type"</span>: <span class="string">"Overshirt Color"</span>,</span><br><span class="line">      <span class="string">"value"</span>: <span class="string">"Red"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"trait_type"</span>: <span class="string">"Pants"</span>,</span><br><span class="line">      <span class="string">"value"</span>: <span class="string">"Cargo Pants"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"trait_type"</span>: <span class="string">"Pants Color"</span>,</span><br><span class="line">      <span class="string">"value"</span>: <span class="string">"Camo"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"trait_type"</span>: <span class="string">"Shoes"</span>,</span><br><span class="line">      <span class="string">"value"</span>: <span class="string">"Workboots"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们重点来看几个上面的没有讲到的地方，上面的 ERC 721 中的方法是我们全都都要实现的，但是只实现上面的那些代码却不够，因为在一个 NFT 项目中，发行出来之后， NFT 是要拿出去售卖的，而不是靠 transfer 来手动转出。meebits 公开售卖的方法如下：</p>
<p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">payable</span> <span class="title">reentrancyGuard</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(publicSale, <span class="string">"Sale not started."</span>);</span><br><span class="line">    <span class="built_in">require</span>(!marketPaused);</span><br><span class="line">    <span class="built_in">require</span>(numSales &lt; SALE_LIMIT, <span class="string">"Sale limit reached."</span>);</span><br><span class="line">    uint salePrice = getPrice();</span><br><span class="line">    <span class="built_in">require</span>(msg.value &gt;= salePrice, <span class="string">"Insufficient funds to purchase."</span>);</span><br><span class="line">    <span class="keyword">if</span> (msg.value &gt; salePrice) &#123;</span><br><span class="line">        msg.sender.transfer(msg.value.sub(salePrice));</span><br><span class="line">    &#125;</span><br><span class="line">    beneficiary.transfer(salePrice);</span><br><span class="line">    numSales++;</span><br><span class="line">    <span class="keyword">return</span> _mint(msg.sender, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个方法中，限制了开售的时间和每次购买的个数，如果还未开售，或者超过了限购次数就会购买失败。当然，如果你账户中的钱不够，也会购买失败。购买收到的钱都会转入到当前的合约账户下。</p>
<p>售卖 NFT 的钱自然不能永远放在合约账户中，而是要提出来。所以还需要一个提款的方法：</p>
<p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">uint amount</span>) <span class="title">external</span> <span class="title">reentrancyGuard</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(amount &lt;= ethBalance[msg.sender]);</span><br><span class="line">    ethBalance[msg.sender] = ethBalance[msg.sender].sub(amount);</span><br><span class="line">    (bool success, ) = msg.sender.call&#123;<span class="attr">value</span>:amount&#125;(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">require</span>(success);</span><br><span class="line">    emit Withdraw(msg.sender, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法也很简单，也许有人会有疑问，这个方法谁都可以调用，那岂不是谁都可以来把钱提走了其实并不是，如果是当前合约之外的账号过来提钱，那么都只能提到 0，因为 ethBalance 数组中并没有其他账号的钱，所以只能是当前合约账号才能把钱提出来，这点设计也很巧妙。</p>
<h2>ERC 721 不是终点</h2>
<p>ERC 721 虽然现在很受欢迎，但满足不了所有的场景。比如在游戏场景中，很多的装备一次可能会发行多个，多达几千种装备类型，如果为每种装备发行一个 NFT，那就要发行几千个合约，这个代价很大，也会对以太坊的资源造成很大的浪费。</p>
<p>ERC 1155 的目标就是解决这个问题，可以在一个合约中定义多种 NFT，也可以为一种 NFT 定义多个数量，后续我们再详细展开 ERC 1155。</p>
<p>文 / Rayjun</p>
<p>[1] <a href="https://eips.ethereum.org/EIPS/eip-20" target="_blank" rel="noopener">https://eips.ethereum.org/EIPS/eip-20</a></p>
<p>[2] <a href="https://eips.ethereum.org/EIPS/eip-721" target="_blank" rel="noopener">https://eips.ethereum.org/EIPS/eip-721</a></p>
<p>[3] <a href="https://eips.ethereum.org/EIPS/eip-1155" target="_blank" rel="noopener">https://eips.ethereum.org/EIPS/eip-1155</a></p>
<p>[4]<a href="https://eips.ethereum.org/EIPS/eip-165" target="_blank" rel="noopener">https://eips.ethereum.org/EIPS/eip-165</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是动态代理</title>
    <url>/2020/10/27/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>在上一篇文章中，详细介绍了 Java 中的反射机制，反射为 Java 提供了运行时修改程序的能力。</p>
<p>与之相对的，Java 中有另外一个技术也经常被提及，<strong>动态代理</strong>。</p>
<p>这个技术在 Java 中同样在很多框架中同样得到了大量的应用。</p>
<p>那么动态代理到底是什么，和反射又有什么关系？</p>
<p>本文基于 OpenJDK11</p>
<h2>1. 代理模式</h2>
<p>在讲动态代理之前，我们需要先了解一下代理模式。</p>
<p>假设现在有一个 RPC 接口，需要统计每个 RPC 接口的调用时间，但是这些统计执行时间的代码于业务逻辑没有关系，这些代码适合独立出来。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用代理模式就是一个比较好的办法，代理模式通常<strong>用于为现有的类添加额外的功能</strong>，而且不用修改现有的代码。</p>
<p>代理模式可以分成<strong>静态代理</strong>和<strong>动态代理</strong>。</p>
<p>需要注意，如果使用动态代理，最好现有的类是基于<strong>接口</strong>来实现的。如果不是基于接口，那么这个类只能实现静态代理，而无法实现<strong>基于反射</strong>的动态代理。</p>
<h2>2. 静态代理实现</h2>
<p>静态代理的实现比较简单，核心就是实现这个接口，然后就可以在这个实现中调用目标对象的方法，并且可以做一些额外的事情。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloStaticProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Hello helloImpl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloStaticProxy</span><span class="params">(Hello helloImpl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloImpl = helloImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        helloImpl.sayHello(name);</span><br><span class="line">        System.out.println(<span class="string">"Invoke time: "</span> + (System.currentTimeMillis() - begin) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码就可以统计出 sayHello 这个 rpc 接口的调用时间。</p>
<p>但是静态代理有一个很大的问题，假设有 n 个 rpc 接口，就需要把上面的逻辑重复实现很多遍。这对于大型系统或者通用框架中肯定是不能接受的。</p>
<p>但是静态代理的优点是性能好，在只有个别类需要被代理的时候，静态代理还是首选。</p>
<h2>3. 动态代理实现</h2>
<p>在 Java 中，动态代理有多种实现。</p>
<p>最直接的一种就是通过反射来实现。代码也不复杂，与上面静态代理不同的地方在于，使用动态代理可以生成任何类的代理。</p>
<p>如果选择使用反射来实现动态代理，那么就要求这个被代理的类是基于接口实现的。</p>
<p>下面代码中 <code>InvocationHandler</code> 和 <code>Proxy</code> 都在 <code>java.lang.reflect</code> 中：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">HelloDynamicProxyHandler handler = <span class="keyword">new</span> HelloDynamicProxyHandler(hello);</span><br><span class="line"><span class="comment">// 生成的动态代理对象</span></span><br><span class="line">Hello helloProxy = (Hello) Proxy.newProxyInstance(HelloImpl.class.getClassLoader(), HelloImpl.class.getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">helloProxy.sayHello(<span class="string">"ray"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloDynamicProxyHandler</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        Object result = method.invoke(target, params);</span><br><span class="line">        System.out.println(<span class="string">"Invoke time: "</span> + (System.currentTimeMillis() - begin) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实这种实现很容易理解，我把上篇文章中利用反射来动态执行方法的代码贴在这里：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用反射动态执行方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">methodInvoke</span><span class="params">(Object o, Method method, Object[] params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(o, params);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与上面动态代理的实现基本一样，这是动态代理最直观，最简单的一种实现方式。</p>
<p>相比于静态代理，动态的性能就要差很多，但是更灵活。</p>
<p>其他的实现就需要引入额外的依赖，比如 cglib 等。cglib 是通过生成被代理类的子类对象来作为动态代理，所有就不要求被代理类是基于接口实现的。</p>
<p>这些具体的实现后续再介绍，这篇文章重点还是放在动态代理本身。</p>
<h2>4. 动态代理的应用</h2>
<p>动态代理在 Java 最常用的场景就是 AOP 编程和解耦。</p>
<p>在 Spring 中 AOP 的实现有两种，反射和 cglib，可以自由选择。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**spring.aop.proxy-target-<span class="class"><span class="keyword">class</span></span>=<span class="keyword">true</span>**</span><br></pre></td></tr></table></figure></p>
<p>在 Java8 以前，选择使用 cglib 更多是因为性能的原因，但是在之后，就没必要了。</p>
<p>除了AOP，动态代理也可以用于解耦，典型的情况就是在 RPC 中，使用动态代理，可以让调用远程的接口和本地方法一样简单。</p>
<p>同时动态代理还可以将很多于业务无关的细节屏蔽，比如权限，统计等等。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从 Java 中的零拷贝到五种IO模型 </title>
    <url>/2020/09/18/%E4%BB%8E-Java-%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%88%B0%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在之前的文章中，我们聊过了 Java 中的零拷贝，零拷贝就是指数据不会在内核空间和用户空间之间相互拷贝。这样就减少了内核态与用户态的切换，自然就很高效。</p>
<p>拷贝文件只是 IO 操作中一个特殊的情况，大多数的 IO 操作还是需要将数据从内核空间移到用户空间，这往往是一个比较耗时的操作。</p>
<p>IO 操作不仅仅指对文件的读写，网络的通信同样也是 IO 操作。</p>
<p>如今很多系统的瓶颈就在于 IO 上，比如经典的 C10K，C10M 问题本质上就是在解决 IO 问题。</p>
<p>这篇文章将介绍经典的 IO 模型的实现原理，以及说明 Java IO 与这几种 IO 模型的关系。</p>
<p>本文讨论的环境为 Linux</p>
<h2>IO 操作是怎么实现的</h2>
<p>IO 操作是一个很复杂的过程，远远不止调用一个函数那么简单，因为每一次的 IO 操作都会涉及到操作系统的内核空间和用户空间的转换，真正执行的 IO 操作实际上是在操作系统的内核空间进行。</p>
<p>这是一个很耗资源的操作。计算机中内存和 CPU 都是非常稀有的资源，应该尽可能提高这些资源的使用效率。</p>
<p>IO 操作经常需要与磁盘就行交互，所以IO 操作相比于 CPU 的速度要慢好几个数量级。利用这两者之间的速度差异，就可以实现不同种类的 IO 方式，也就是俗称的 IO 模型。</p>
<p>当然，这些 IO 操作的都在操作系统层面上实现好了，编程语言可以利用这些能力去实现 IO 相关的 API。</p>
<h2>五种 IO 模型</h2>
<p>在 操作系统中，IO 模型有如下五种：</p>
<p><img src="1.png" alt=""></p>
<p>在上文已经说到，其实 IO 操作就是将数据在用户空间与内核空间进行相互转换，这个过程是通过<code>系统调用</code>来完成的。 IO 技术的发展目标就是如何使用尽可能少的资源来完成数据的传输，这里资源主要就是指 CPU 资源。</p>
<p>无论是文件 IO，还是网络 IO，最后都可以统一为用户空间和内核空间数据的交换。</p>
<h3>BIO</h3>
<p>BIO 是最经典的一种 IO 方式，也是最简单粗暴的方式，在发起 IO 操作之后，当前调用线程就会处在阻塞状态，直到数据传输完成。</p>
<p><img src="2.png" alt=""></p>
<h3>NIO</h3>
<p>NIO 是在 BIO 基础之上的一个改进，NIO 在数据还未准备好的情况下，不会阻塞进程，而是通过轮询的方式，不断的去查询数据时候准备好，当数据可以被读取时，当前线程就会处在阻塞状态，直到数据读取完成。</p>
<p><img src="3.png" alt=""></p>
<p>所以 NIO 中的非阻塞指的是在等待数据的阶段，实际进行数据传输时，还是阻塞的，这点需要注意。</p>
<h3>IO 多路复用</h3>
<p>IO 多路复用是对 NIO 的一个改进，在 NIO 中，需要不断轮询查看数据是否准备好，IO 多路复用的改进是不再主动去查询数据状态是否准备完成，而是等数据准备好的通知，当数据准备完成之后，才会开始传输数据。</p>
<p><img src="4.png" alt=""></p>
<p>与 NIO 一样，在数据的传输阶段，当前线程依然是阻塞的。</p>
<p>在 Linux 系统中，IO 多路复用的方式有多种：</p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<h3>信号驱动 IO</h3>
<p>信号驱动 IO 通过 sigaction 系统调用，向内核发送一个信号，当内核中数据准备好之后，当前线程也会接收到一个信号，在这个过程中，当前线程也是非阻塞的。在接收到信号之后，就可以开始传输数据。</p>
<p><img src="5.png" alt=""></p>
<h3>AIO</h3>
<p>上面的这些 IO 模型虽然有些号称是不阻塞的，那是指在等待数据就绪的过程中是不阻塞的，但是在接收数据的时候，依然还是阻塞的。</p>
<p>AIO 是这些 IO 模型中真正实现完全不阻塞，AIO 在被调用之后直接返回，连接收数据的阶段也是非阻塞的，等到数据接收完成之后，内核才会返回一个通知，也就是说当用户进程接收到通知时，数据已经接收完成。</p>
<p><img src="6.png" alt=""></p>
<p>在 Linux 中提供了 AIO 的实现，但是实际上使用的并不多，更多还是使用独立的异步 IO 库，比如<code>libevent</code>、<code>libev</code>、<code>libuv</code>。</p>
<p><img src="7.png" alt=""></p>
<h2>Java 中 IO 的实现</h2>
<p>Java 中的 IO 也不例外，实际的 IO 是调用了系统的能力来完成，在用户态通过系统调转到内核态，最终实现文件的读写或者通信。</p>
<p>Java 中 IO 就是典型的 BIO，而且 NIO 则不是对应五种 IO 模型中的 NIO，Java 中的 NIO 实际上是使用 IO 多路复用来实现的。</p>
<p>Java 中的 NIO2 也称之为 AIO，正是对应操作系统中的 AIO，当然具体的实现可能是其他的库。</p>
<p>文 / Rayjun</p>
<h2>REF</h2>
<p>[1] Unix 网络编程</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从LeetCode371 理解位运算</title>
    <url>/2019/03/09/%E4%BB%8ELeetCode371-%E7%90%86%E8%A7%A3%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>在日常刷 LeetCode 的过程中，发现了 LeetCode371 这道题。题目的模板代码是这样的:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
看到这里的时候，内心是震惊的，这也能作为 LeetCode 的题，难道我的水平只能和小学生相当？激动两分钟发现问题并没有这么简单，这道题附带了另一个条件，那就是不能使用 <strong>+</strong> 和 <strong>-</strong> 操作符。看到之后更震惊，还有这种操作？</p>
<p>分析了半天，最后想出了<strong>自增</strong>和<strong>自减</strong>的方式来解决了这道题，虽然被 <strong>AC</strong> 了，但是还是觉得不是很顺畅。于是 Google 了一下其他的解法，让我发现了一个更让我震惊的解法。</p>
<h4>LeetCode371 的正确打开方式</h4>
<p>先贴上代码:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (b==<span class="number">0</span>? a: getSum(a^b, (a&amp;b)&lt;&lt;<span class="number">1</span> ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这是一个递归的解法，不过这并不重要。重要的是 <strong>a^b</strong> 和 <strong>(a&amp;b)</strong> 这两个操作。我解决这个问题使用了十几行代码，这种方式只有了一行代码，玄机就在这两个运算上面。</p>
<p>首先 <strong>^</strong> 是异或运算，<strong>a^b</strong> 会让 a 和 b 的二进制进行异或操作，两位相同为 0， 两位不同为 1，也就是说异或运行会将二进制运算中所有的进位都放弃，所以异或也称之为<strong>不进位加法</strong>。</p>
<p><strong>(a&amp;b)&lt;&lt;1</strong> 中 <strong>a&amp;b</strong> 就容易懂了，就是与操作，两位都为 1 结果才为 1，否则都为 0。<strong>&lt;&lt;</strong> 操作叫做左移操作，每左移一位，结果就相当于乘 2，所以 <strong>(a&amp;b)&lt;&lt;1</strong> 相当于 <strong>(a&amp;b) * 2</strong>。分析到这里所以的细节应该都是理解了，但是为什么这样递归到 <strong>b==0</strong> 就能得到两个数相加的结果呢？</p>
<p>拿个具体的例子分析一下 <strong>2+3</strong>，也就是 <strong>010 + 011</strong>，那么使用上面的步骤来 <strong>010 ^ 011</strong> 的结果是 <strong>001</strong>，中间那两个 1 产生的进位被丢弃了。<strong>(010 &amp; 011)</strong> 的结果是 <strong>010</strong>，然后左移一位得到 <strong>100</strong>，发现什么没有， <strong>001 + 100</strong> 的结果是 <strong>101</strong>，就是我们的答案 <strong>5</strong>。但是有个问题呀，这里还是使用了 <strong>+</strong>。</p>
<p>那就继续进行这个过程，这次 a 为 001，b 为 100，001 ^ 100 为 101，(a&amp;b) 的结果为 000，左移一位依然是 0， 那 b 的值等于0，a 的值就是我们所需要的结果了，在这个例子中是 5。</p>
<p>在合适的问题上，使用位运算有意想不到的效果，而且位运算的速度往往要比直接进行计算要快。在 Java 中，支持如下的位运算:</p>
<ul>
<li>&amp; (与操作)</li>
<li>| (或操作)</li>
<li>^ (异或操作)</li>
<li>~ (取反操作)</li>
<li>&lt;&lt; (左移操作)</li>
<li>&gt;&gt; (右移操作)</li>
<li>&gt;&gt;&gt;(逻辑右移操作)</li>
</ul>
<h4>位运算技巧</h4>
<p>位运算有很多的小技巧，我整理了一些：</p>
<ol>
<li><strong>与运算技巧</strong></li>
</ol>
<p>a&amp;(a-1) 去掉 a 的最后一个1。
两个相同的数与运算是本身，其中一个减一后相与就取掉了 a 的最后一个1。
可以用这个技巧判断一个数是不是 2 的 次幂:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a &gt; <span class="number">0</span> &amp;&amp; (a &amp; (a -<span class="number">1</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>判断一个数的奇偶性，结果为 true 则是奇数：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(n &amp; <span class="number">1</span>) == <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li><strong>异或技巧</strong></li>
</ol>
<p>a 异或 b 两次等于 a 本身，看一段代码:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br></pre></td></tr></table></figure>
如果使用异或可以这么处理，不需要中间变量:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a^b;</span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure></p>
<p>还有这个问题，在一个数组 a 中，除了一个单独存在的数之外，其他的数都是两两存在的，找出这个单独的数，循环结束后，result 就是那个单独的数:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line">     result ^= a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异或还可以用于加密，比如对与 <strong>Hello</strong> 对应的 char 的数值是 72、101、108、108、111。每个 char 都与 任意一个数字进行异或操作，比如 12，得到 68、105、96、96、99。这个就是加密后的结果，如果要得到原文，再与 12 <strong>左移做乘法</strong>异或一次就行了。</p>
<p>异或还可以用于判断两个数的符号是不是一样:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(a ^ b) &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>异或还可以把如下的逻辑写成一行代码:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x == a) </span><br><span class="line">    x = b; </span><br><span class="line"><span class="keyword">if</span>(x == b) </span><br><span class="line">    x = a;</span><br></pre></td></tr></table></figure>
简化后:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = a ^b ^x;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li><strong>左移技巧</strong></li>
</ol>
<p>a 乘以 2 的 (n-1) 次方。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a &lt;&lt; n</span><br></pre></td></tr></table></figure></p>
<p>获得 int 的最大值:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(a &lt;&lt; <span class="number">31</span>) -<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>获得 int 的最小值:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a &lt;&lt; <span class="number">31</span></span><br></pre></td></tr></table></figure></p>
<p>4 .<strong>右移技巧</strong></p>
<p>a 除以 2 的 (n-1) 次方。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a &gt;&gt; n</span><br></pre></td></tr></table></figure></p>
<p>求两个数的平均值:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(a + b) &gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<ol start="5">
<li><strong>取反技巧</strong></li>
</ol>
<p>计算 n + 1:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-~n</span><br></pre></td></tr></table></figure>
计算 n - 1:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">~-n</span><br></pre></td></tr></table></figure></p>
<p>计算相反数:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">~n + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<ol start="6">
<li><strong>复合技巧</strong></li>
</ol>
<p>取绝对值:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(n ^ (n &gt;&gt; <span class="number">31</span>)) - (n &gt;&gt; <span class="number">31</span>)</span><br></pre></td></tr></table></figure>
取两个数中的较大值（如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1）：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b &amp; ((a-b) &gt;&gt; <span class="number">31</span>) | a &amp; (~(a-b) &gt;&gt; <span class="number">31</span>)</span><br></pre></td></tr></table></figure>
同样可以取较小值:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a &amp; ((a-b) &gt;&gt; <span class="number">31</span>) | b &amp; (~(a-b) &gt;&gt; <span class="number">31</span>)</span><br></pre></td></tr></table></figure>
(完)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>从技术的角度上来看，什么是区块链</title>
    <url>/2018/11/18/%E4%BB%8E%E6%8A%80%E6%9C%AF%E7%9A%84%E8%A7%92%E5%BA%A6%E4%B8%8A%E6%9D%A5%E7%9C%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<p>当我们开始说到区块链的时候，比特币肯定是绕不过去的一个点。首先是产生了比特币，而后才有了区块链的概念。比特币被发明者中本聪定义为一个<strong>点对点</strong>版本的电子现金系统。这样系统不需要金融机构等第三方机构来保证一笔钱不会被两次消费。这样一来，任意的双方都可以直接进行交易，而不用担心出现会被对方欺诈。所有的交易记录会形成一条<strong>工作证明链</strong>，这条链除非重新生成，否则这条链上的数据就不可能被改变。</p>
<p>在上面对比特币的描述中，出现了两个非常重要的概念，一个是<strong>点对点</strong>，还有就是<strong>工作证明链</strong>，区块链的概念也正是脱胎于此。对于区块链，很难直接下定义，因为这个词里面包含了太多的内容，包括分布式网络、数据库、密码学、工程学、博弈论等等。但是从最直观的理解上来看，它就是一条链，这条链上并不是直接存储了数据，存储的是数据的哈希值。如下图（图片来源：比特币白皮书）：</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_fb9d3a48-67b8-4089-b90c-7dd6b77c9f83.png" alt="比特币"></p>
<p>所以，如果必须要从技术来给区块链下一个定义的话，那就是区块链是基于分布网络的数据库。</p>
<p>但是如果只是从这个角度来说明区块链并不是很准确，如果只是搭建一个分布式的数据库系统，现有的很多的方案都要比区块链更好。区块链真正区别在于<strong>工作证明</strong>这个点上。当然，这个说法来源于比特币，其他的很多区块链系统都不是这个叫法，但是机制也与这个类似。</p>
<p>正是这个工作证明才让区块链得以构建起来。对于区块链来说，最为重要的事情就是让这条链可以不断的延展下去，而整个区块链系统只认那条最长的链。但是区块链在构建最长链的过程当中，需要有人（节点）愿意不断参与。那就需要通过某种方式来给参与的人（节点）报酬，在收益的驱使下让人（节点）不断的参与进来。这种报酬的获取方式是在每个新的区块生成的时候产生，通常把这个报酬称之为 Token，在比特币系统中，这个报酬称之为比特币。因为只有最长的那条链上的才能产生 Token，所以参与人只能围绕这条最长链进行工作，而他们工作的方式就称之为。所有区块链系统的这部分设计实际上已经不是技术领域，实际上这个就属于经济学领域。</p>
<p>所以到这里，我们就知道了，区块链其实就是通过分布式网络的节点参与建设的一条链，这条链上存储了诸多交易（或者其他数据）的哈希值，这些数据的本身这是存储在数据库中的。区块链系统通过不断的产生 Token 来奖励那些参与建设的节点，使得这些节点能够不断的围绕区块链的最长链持续的生成节点。这样，一个区块链系统就生成了。</p>
<p>参考文献:</p>
<p>[1] 比特币白皮书</p>
<p>[2] 精通比特币</p>
<p>[3] 区块链原理设计与应用</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的懂 Java 的 main 方法吗</title>
    <url>/2020/08/30/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82-Java-%E7%9A%84-main-%E6%96%B9%E6%B3%95%E5%90%97/</url>
    <content><![CDATA[<p>在学习 Java 时，HelloWorld 一般都是我们写的第一个 Java 程序，这个程序很简单，只需要一个main 方法，再加上一个打印语句。麻雀虽小，五脏俱全，即使是一个很小的程序，但程序的执行流程与大型的程序基本没有区别。</p>
<p>这篇文章会讨论 Java 程序如何启动，以及其中经历的主要过程。</p>
<p>本文基于 openJDK11</p>
<p>先来看段代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        data.put(<span class="string">"name"</span>, <span class="string">"rayjun"</span>);</span><br><span class="line">        System.out.println(data.get(<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Main1.data.get(<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先执行 Main1.main()，再执行 Main2.main()，程序输出的结果是什么：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Main1.main(): rayjun</span><br><span class="line">Main2.main(): <span class="keyword">null</span></span><br></pre></td></tr></table></figure></p>
<p>上面程序运行的结果应该都在预料之中吧。</p>
<p>然后把代码改成下面这样：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.put(<span class="string">"name"</span>, <span class="string">"rayjun"</span>);</span><br><span class="line">        System.out.println(data.get(<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main1.invoke();</span><br><span class="line">        System.out.println(Main1.data.get(<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这回输出的结果是:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Main1.invoke(): rayjun</span><br><span class="line">Main2.main(): rayjun</span><br></pre></td></tr></table></figure></p>
<p>首先需要明确，main 方法是 Java 程序的入口，main 方法本身有着很严格的定义，不能随意更改。</p>
<p>JVM 启动后会执行 main 方法，就会新建了一个进程，每个进程都会有自己的虚拟机实例。</p>
<p>在第一个例子中，启动了两个 mian 方法，也就是启动了两个进程，那么说明他们运行在不同的虚拟机实例上，那么数据自然就不是共享的，所以在第二个 main 方法中无法获取到第一个 mian 方法中设置的数据。</p>
<p>第二个例子中，两个类在同一个 main 方法中启动，那么就是在同一个进程中，也就是在同一个虚拟机实例上，同一个虚拟机实例上，public 类型的静态变量，在整个进程中都是共享的。</p>
<p>如果代码按照如下的形式再次进行修改：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        invoke();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.put(<span class="string">"name"</span>, <span class="string">"rayjun"</span>);</span><br><span class="line">        System.out.println(data.get(<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main1.main(args);</span><br><span class="line">        System.out.println(Main1.data.get(<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Main1.main(): rayjun</span><br><span class="line">Main2.main(): rayjun</span><br></pre></td></tr></table></figure></p>
<p>从上面的结果可以知道，main 方法其实就是一个普通的方法，可以被其他类调用，所以 main 方法是程序的入口，同时也是一个普通的方法。</p>
<p>那么 main 方法在执行的过程中到底发生了什么？</p>
<p>下面是 Java 代码到执行结束的完成流程：</p>
<p><img src="1.png" alt=""></p>
<h2>程序启动</h2>
<p>Java 有个特性叫编写一次，到处运行，这是因为有虚拟机的存在，我们所编写的所有代码最终都是在虚拟机上运行。</p>
<p>但 JVM 是无法执行 Java 代码的，所以需要使用 <code>javac</code> 将Java 代码编译成<strong>字节码</strong>文件，字节码文件才可以在 JVM 上执行。</p>
<p>字节码文件准备好了之后，就需要启动 JVM 实例，JVM 可以接受各类参数，以便适应不同的执行环节，在初始化 JVM 实例时，需要先检查 JVM 参数，并且校验这些参数是否合法。</p>
<p>参数校验完成之后，就会开始初始化 JVM 的内存空间，我们所熟知的堆、栈、方法区等等。</p>
<p><img src="2.png" alt=""></p>
<p>在执行 main 方法时，发现在方法区找不到 mian 方法所对应的类，于是就会启动类加载的过程。</p>
<p>类在加载完成之后，就会像执行任何的普通方法一样来执行 main 方法，会将 main 方法加载到栈中执行。</p>
<p>JVM 刚开始会对字节码文件解释执行，但是随着 JVM 技术发展，也慢慢出现了 JIT（即时编译）技术，可以将部分字节码或者全部字节码通过编译的的方式来执行。</p>
<p>当字节码被加载，然后就会进入程序的运行状态，我们所熟知的垃圾回收机制就开始运行，程序运行的过程中，不断有对象被创建，也会不断有对象被回收。</p>
<p>如果没有发生内存泄漏的情况，程序会在垃圾回收的支持下持续运行。</p>
<h2>程序运行</h2>
<p>程序开始执行的时候，会创建一些线程。</p>
<p>JVM 在启动的时候会创建一个 <code>VM Thread</code>，这是所有线程的祖先，其他的线程都是由这个线程派生出去的。</p>
<p>在 Java 中，线程分为两种：<strong>普通线程</strong>和<strong>守护线程</strong>。</p>
<p>普通线程就是通常业务逻辑执行的代码，代码执行完成之后，普通线程也就退出了。而守护线程一般运行在后台，比如说响应命令行的操作，守护线程会在普通线程退出之后退出。</p>
<p>在 Java 中，如果要把一个线程编程守护线程，只需要调用 <code>Thread.setDaemon()</code>，判断一个线程是否是守护线程，只需要调用 <code>Thread.isDeamon()</code>。</p>
<p>执行 Java 程序的时候，除了需要为运行的代码创建一个线程之外，还需要创建一个处理后台任务的守护线程。</p>
<p>执行以下代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">      ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">          System.out.println(<span class="string">"Thread id: "</span>+threadInfo.getThreadId() + <span class="string">", thread name: "</span> + threadInfo.getThreadName() + <span class="string">", isDaemon: "</span>+threadInfo.isDaemon());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread id: 1, thread name: **main**, isDaemon: <span class="literal">false</span></span><br><span class="line">Thread id: 2, thread name: **Reference Handler**, isDaemon: <span class="literal">true</span></span><br><span class="line">Thread id: 3, thread name: **Finalizer**, isDaemon: <span class="literal">true</span></span><br><span class="line">Thread id: 4, thread name: **Signal Dispatcher**, isDaemon: <span class="literal">true</span></span><br><span class="line">Thread id: 9, thread name: **Common-Cleaner**, isDaemon: <span class="literal">true</span></span><br><span class="line">Thread id: 10, thread name: **Monitor Ctrl-Break**, isDaemon: <span class="literal">true</span></span><br><span class="line">Thread id: 12, thread name: **Attach Listener**, isDaemon: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码可以发现，只有 main 线程不是守护线程，其他的线程都是<strong>守护线程</strong>。</p>
<ul>
<li>Reference Handler：该线程负责将待回收的对象管理起来，等待回收</li>
<li>Finalizer：该线程负责从 Reference Handler 获取待回收对象，检查该对象是否实现了 finalize 方法，如果实现了该方法而且没有被调用过，就会调用该方法，使对象继续存活</li>
<li>Attach Listener：该线程负责接收外部命令，并且把该命令执行的结果返回给发送者，比如：jps，jmp 等等</li>
<li>Single Dispatcher：Attach Listener 在接收到命令之后，会交给该线程进行分发到不同的模块去处理并获得处理结果</li>
<li>Common-Cleaner：该线程是 JDK9 之后新增的守护线程，用来更高效的处理垃圾回收</li>
<li>Monitor Ctrl-Break：该线程用于应用监测以及用于排查问题</li>
</ul>
<p>只要 JVM 中还有非守护线程存在，JVM 实例就不会退出。</p>
<h2>程序如何退出</h2>
<p>当程序执行完成之后，JVM 也要退出，程序执行完的标志就是非守护线程都退出了。当所有的非守护线程退出之后，守护线程也会退出。</p>
<p>程序在执行完成之后，会调用 <code>System.exit()</code> 方法，然后虚拟机退出，程序彻底结束。</p>
<p>exit 方法接收一个整型的参数，如果传入的值为 0，那么就表示程序是正常退出的，如果是任何非零的值，那么就表示是异常退出。</p>
<p>其实在代码中，非常不推荐调用这个方法，因为这个方法会造成一些意向不到的情况。</p>
<p>看下面这段代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"App invoking"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.exit(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"App existing"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码会输出：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">App invoking</span><br></pre></td></tr></table></figure></p>
<p><code>finally</code> 中的代码并不会执行，这样会出现异常的情况，会破坏程序原本的正常逻辑，所以不要去调用这个方法。</p>
<p>Java 运行程序的整体流程就是上面那些过程，当然省略了不少的细节，这些细节我们再通过后续的文章慢慢补充。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>亲力亲为不等于好管理</title>
    <url>/2016/06/10/%E4%BA%B2%E5%8A%9B%E4%BA%B2%E4%B8%BA%E4%B8%8D%E7%AD%89%E4%BA%8E%E5%A5%BD%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>大的团队生产力不一定强。就像NBA中，有多个巨头的球队不一定是最厉害的。人多的团队不一定比人少的团队更厉害。关键在于团队的运转模式，高效的运转足以带来高效率。</p>
<p>每个人的潜力都是很大的，有着良好运行规则的团队最大化的激发每个人的潜力。激发人的潜力在很大程度上就是需要让每个清晰的认识到自己在团队中的位置和职责。</p>
<p>人都有被需要、想实现自己价值的心理。当一个人发现自己在团队中是可有可无的时候，那么他做事的积极性和创造力是肯定会下降的。</p>
<p>每个人擅长的东西是不一样的，最好的方式不是去帮团队成员搞定一切，这样做一点会打乱团队成员职责的定位，会让他们的积极性收到影响。最好的方式就是明确他们的职责，然后给他们空间让他们去发挥就好。</p>
<p>所以在团队管理中，最好的方式就是去明确一个人在团队中的具体职责以及去给他相应的空间。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>你真的理解 Java 的基础数据类型吗</title>
    <url>/2020/05/06/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3-Java-%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97/</url>
    <content><![CDATA[<p>Java 中的基础数据类型有 8 种，分别是：byte, boolean, short, char int, float, long double。</p>
<p>如果要理解这些基础类型如何存储数据，需要知道两个基础知识：</p>
<ul>
<li>所有<strong>数据</strong>都是使用二进制表示</li>
<li><strong>数值</strong>类型一律使用补码来表示</li>
</ul>
<h2>整数类型</h2>
<p>byte 是存储整数的最小类型，只占 1 个字节，因为还需要表示负数，因此只能保存 -128 ~ 127 范围内的数据。</p>
<p>如果把一个超出范围的数值赋值给 byte 会怎么样？</p>
<p>直接赋值无法编译通过：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">129</span>; <span class="comment">// 编译通不过</span></span><br></pre></td></tr></table></figure></p>
<p>需要通过强转才能编译通过，但得到值不是我们所期望的：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)<span class="number">129</span>; <span class="comment">// -127</span></span><br></pre></td></tr></table></figure></p>
<p>为什么会出现这样的结果呢？</p>
<p>129 使用二进制表示就是 10000001，但因为所有的数值类型都是使用补码来表示，在强制转换之后，第一位会被认为是符号位，表示负数。</p>
<p>负数补码的反码是除符号位以外取反，所以是：11111110。</p>
<p>负数的原码是反码加1，所以是 11111111，也就是 -127。</p>
<p>short，int，long 与 byte 没有太大区别，唯一的区别就在于占据的字节数量不一样。</p>
<ul>
<li>short 占据 2 个字节，表示的范围是： -32768 ~ 32767</li>
<li>int 占据 4 个字节，表示的范围是：-2147483648 ~ 2147483647</li>
<li>long 占据 8 个字节，表示的范围是：-9223372036854775808 ~ 9223372036854775807</li>
</ul>
<h2>浮点数类型</h2>
<p>Java 中的浮点数有 float 和 double 两种，按照 IEEE754 标准来实现，分别占 4 个字节和 8 个字节。</p>
<p>以 float 来说，总共有 32 位：</p>
<p><img src="float.png" alt=""></p>
<p>float 同样也有符号，所以第 1 位是符号位 (s)，后面 8 位是指数位(e)，最后面 23 位表示的是小数位(m)，形式如下：</p>
<p>$$(-1)^s2^eM$$</p>
<p>这是需要注意的是因为是二进制，所以基数是 2，因为指数 e 有 8 位，所以范围是 -128 ~ 127。</p>
<p>比如说有一个浮点数：1001.11，按照上面的形式，如下:</p>
<p>$(-1)^0$ * $2^3$ * $1.00111$</p>
<p>因为浮点数的小数位会因为精度的问题而出现变化，所以不能使用 == 去比较两个浮点数，否则可能出现意想不到的情况。</p>
<p>double 除了位数不一样，其他与 float 一致。</p>
<h2>布尔类型</h2>
<p>boolean 的情况比较特殊，boolean 赋值时只能选择 true 或者 false，无法赋值其他的值。</p>
<p>但是在编译时会将 false 换成 0，将 true 换成非零数。</p>
<h2>字符类型</h2>
<p>由于 Java 使用的是 Unicode，所以作为基本的字符单元，char 使用了 2 个字节的空间，char 实际存储的是该字符在 Unicode 字符集内中的排序位置，即整数。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> b = <span class="string">'a'</span> + <span class="number">1</span>; <span class="comment">// 98</span></span><br></pre></td></tr></table></figure></p>
<p>每个 char 只能存储一个字符，所以存储一些英文字符时会浪费一些空间。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成为另一个字符，而不是像字符串拼接一样</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span> + <span class="string">'b'</span>; <span class="comment">// Ã</span></span><br></pre></td></tr></table></figure></p>
<p>在 Java8 之前，String 使用 char 数组来存储字符串，但是从 Java 9 以后，已经替换成 byte 数组了，因为更加灵活，而且存储的效率也更高。</p>
]]></content>
  </entry>
  <entry>
    <title>从引用聊一聊 Java 垃圾回收</title>
    <url>/2020/05/24/%E4%BB%8E%E5%BC%95%E7%94%A8%E8%81%8A%E4%B8%80%E8%81%8A-Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>对象是 Java 世界的一等公民，所有的对象都是引用类型。除了 8 种基本的数据类型之外，其他的都是对象。</p>
<h2>JVM 和垃圾回收</h2>
<p>在开始讨论引用之前，首先需要了解一下 JVM 和垃圾回收。Java 与 C 语言等不同，C 语言代码经过编译器编译之后，就可以直接在 CPU 上执行，而 Java 不同，Java 语言需要先编译生成字节码文件，再由 JVM 生成可以在 CPU 上运行的代码。</p>
<p>而且 Java 在生成对象时，并不需要手动分配内存，而是由 JVM 自动进行分配，对于不再使用的对象，JVM 会对这些对象占用的内存进行回收，这个过程称之为垃圾回收（Garbage Collection，简称 GC）。</p>
<p>JVM 负责对程序运行时的内存进行管理。为了提升管理效率，JVM 将运行时的内存划分成了不同的区域，总体上的划分如下：</p>
<p><img src="jvm-memory.png" alt=""></p>
<p>每个线程独占一个虚拟机栈，通过程序计数器记录当前代码执行的位置，本地方法栈与虚拟机栈类似。</p>
<p>程序中创建的大多数对象都在堆中分配内存，然后栈中的变量通过引用来指向堆中的对象，所以堆是各个线程共享的一块内存区域。方法区中则存储 Java 的类型信息、常量、静态变量等等（常量，静态变量也有可能会引用对象）。</p>
<p>栈内的变量通过引用来和堆内的对象建立联系，建立联系的方式有两种：使用句柄或者直接指针。</p>
<p>使用句柄方式如下：</p>
<p><img src="handler.png" alt=""></p>
<p>使用直接指针如下：</p>
<p><img src="point.png" alt=""></p>
<p>使用句柄的好处是引用中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的数据，而不会修改引用中的数据。但是直接指针的速度会更快，在主流的 HotSpot 虚拟机中，使用的就是直接指针。</p>
<h2>Java 引用</h2>
<p>Java 中的引用类型总共有四种：强引用，软引用，弱引用，虚引用。</p>
<p>强引用就是最普通的对象引用，每当 new 一个对象的时候，都是生成一个强引用。这种引用对垃圾回收免疫，即使发生 OOM，这种对象也不会被回收。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></p>
<p>软引用的强度相对弱一些，在发生 OOM 之前，JVM 会尝试去回收这些对象，软引用的实现类是 SoftReference。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference srf = <span class="keyword">new</span> SoftReference(o);</span><br></pre></td></tr></table></figure></p>
<p>弱引用就更弱了，如果碰上了垃圾回收，弱引用的对象肯定会被回收，弱引用的实现类是 WeakReference。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference wrf = <span class="keyword">new</span> WeakReference(o);</span><br></pre></td></tr></table></figure></p>
<p>虚引用无法引用对象，实际只是做一些垃圾清理之后的事情, 虚引用的实现类是 PhantomReference。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue rq = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference prf = <span class="keyword">new</span> PhantomReference(o, rq);</span><br></pre></td></tr></table></figure></p>
<p>上面的各种引用都继承了 Reference 类，Reference 类中有一个 get 方法，如果软引用和弱引用所指向的对象没有被回收，那么使用 get 方法就可以获取原对象的引用。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference srf = <span class="keyword">new</span> SoftReference(o);</span><br><span class="line">o = <span class="keyword">null</span>; <span class="comment">// 断开强引用</span></span><br><span class="line">System.out.println(srf.get()); <span class="comment">// java.lang.Object@17579e0f</span></span><br></pre></td></tr></table></figure></p>
<p>对软引用手动触发垃圾回收：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference srf = <span class="keyword">new</span> SoftReference(o);</span><br><span class="line">o = <span class="keyword">null</span>;</span><br><span class="line">System.gc(); <span class="comment">// 手动触发垃圾回收</span></span><br><span class="line">System.out.println(srf.get()); <span class="comment">// java.lang.Object@17579e0f</span></span><br></pre></td></tr></table></figure></p>
<p>由于内存充足，所以软引用指向的对象并没有被回收。对于弱引用来说，情况就不一样：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference wrf = <span class="keyword">new</span> WeakReference(o);</span><br><span class="line">o = <span class="keyword">null</span>; <span class="comment">// 断开强引用</span></span><br><span class="line">System.out.println(wrf.get()); <span class="comment">// java.lang.Object@17579e0f</span></span><br></pre></td></tr></table></figure></p>
<p>对弱引用手动触发垃圾回收：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference wrf = <span class="keyword">new</span> WeakReference(o);</span><br><span class="line">o = <span class="keyword">null</span>;</span><br><span class="line">System.gc(); <span class="comment">// 手动触发垃圾回收</span></span><br><span class="line">System.out.println(wrf.get()); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
<p>由上面的代码可知，弱引用一定会被垃圾回收。软引用和弱引用一个经典的应用场景就是作为缓存使用，这两种引用所指向的对象一定会在发生 OOM 之前被回收，所以不会导致内存泄露问题。</p>
<p>虚引用 PhantomReference 的 get 方法会一直返回 null，所以无法通过虚引用获取到对象。虚引用的意义在于提供了一种在对象被回收之后做某些事情的机制，在这里就需要谈到引用队列。</p>
<p>ReferenceQueue 称之为引用队列。如果我们为一个引用指定一个引用队列，那么这个引用所指向的队列在被垃圾回收后，该引用就会被加入到引用队列中。</p>
<p>我们就可以根据引用队列中的引用来判断某个对象是否被回收，或者直接清除引用队列的引用对象，具体的逻辑要看具体的业务场景。</p>
<h2>引用和对象的可达性</h2>
<p>假设新生成了一个对象：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></p>
<p>这个时候 o 是一个强引用，所以这个对象无法被回收。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">o = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，这个变量就不再指向这个对象了，假设也没有其他类型的引用来指向这个对象，那么这个对象就称之为不可达，就可以被回收了。</p>
<p>Java 中使用可达性分析来判断对象是否要被回收。可达性的出发点是一些被称之为 GC Roots 的根对象，以下的对象可以作为 GC Roots:</p>
<ul>
<li>栈中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>JVM 内部的引用，比如基本数据类型对应的 Class 对象</li>
</ul>
<p>判断一个对象是否存活其实就是通过引用的类型来进行判断，对于弱引用和虚引用来说，基本就可以认为是不可达了，在下次垃圾回收时就会被回收，而对于强引用，毫无疑问，肯定是可达的。</p>
<p>最难处理的就是软引用。软引用在 JVM 中并没有明确把软引用判断为可达还是不可达，而是会根据当前系统的状态进行判断，如果当前系统内存充足，那么该对象就会被判断为可达，如果系统内存不足，那么该对象就会倾向被回收。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 make 还是 new</title>
    <url>/2021/08/30/%E4%BD%BF%E7%94%A8-make-%E8%BF%98%E6%98%AF-new/</url>
    <content><![CDATA[<p>在 Go 中初始化变量的时候，会用到 make 和 new，如果学习过其他的面向对象语言，比如 Java，可能就会对 new 的使用有点迷惑，Go 中的 new 有着完全不同的含义。</p>
<p>make 和 new 都涉及到内存的分配，但使用的场景却打不相同。</p>
<h2>1. make</h2>
<p>make 的使用比较简单，用来初始化内置的数据结构，slice、map 和 channel，使用 make 返回的都是引用类型。对于不同的结构，返回的结果不同。</p>
<p>make 接收的是可变参数，对于不同的类型，使用的参数不同。</p>
<p>初始化 slice 时，至少需要两个参数，一个是 slice 的类型，另一个是 slice 的 cap 和 len，如果 len 和 cap 不同，就需要使用三个参数：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 10</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s)) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s)) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p>
<p>初始化 map 时，只需要一个参数，如果需要预先指定 map 底层存储的大小，那就需要两个参数：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<p>初始化 channel 时，如果不指定第二个参数，那就会创建一个同步的 channel，否则就会创建一个带缓冲的 channel:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>make 只会用来初始化以上三种数据结构</strong>。</p>
<h2>2. new</h2>
<p>new 的使用就会广泛很多，<strong>new 会为传入的类型分配一块内存，初始化该类型的零值，并返回这个内存的地址</strong>。</p>
<p>如果想要声明一个 int 类型的变量，并获取到该变量的指针：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">p := &amp;i   </span><br><span class="line">fmt.Println(*p) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<p>如果使用 new：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(*p) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<p>以上的两种方式是等价的。</p>
<p>除了这些类型，还可以把 new 用在自定的类型上：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := <span class="built_in">new</span>(Person)</span><br><span class="line">p.Name = <span class="string">"ray"</span></span><br><span class="line">p.Age  = <span class="number">18</span></span><br></pre></td></tr></table></figure></p>
<p>这里有一点很特殊的地方，上面说到了使用 make 来初始化三种内置的数据结构，如果使用 new 去创建上面三种类型会发生什么呢？</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(*m == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">s := <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(*s == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">c := <span class="built_in">new</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">fmt.Println(*c == <span class="literal">nil</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>使用 new 创建之后的结构都是 nil，这是因为 slice、map 和  channel 都是引用类型，而引用类型的零值就是 nil，这个结果是符合上面对于 new 的描述。</p>
<p>通常情况下，不应该使用 new 去创建这三种结构，而是使用 make。</p>
<h2>3. 小结</h2>
<p>make 和 new 虽然都用来初始化新变量，但适用的情况却不一样，make <strong>主要用来初始化三种内置的引用类型的数据结构</strong>，而 new 则更通用一些，<strong>主要为一些值类型的变量申请内存</strong>。而且还需要注意一点，make 和 new 都不属于关键，而且内置函数，也就是说，下面的这种代码是合法的：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cal</span><span class="params">(<span class="built_in">make</span>, <span class="built_in">new</span> <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make</span> + <span class="built_in">new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个函数中，就无法使用 make 或者 new 来初始化变量了。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Go modules</title>
    <url>/2021/01/17/%E4%BD%BF%E7%94%A8Go-modules/</url>
    <content><![CDATA[<p>Go 的包管理一直被人诟病，有人提出过解决方法，比如 godep、govendor 等工具，但在 G1.11 版本中，Go 官方很霸道的提出了 Go Module 方案，虽然被人吐槽，但现在已经成为事实上的包管理方案。</p>
<p>Go 官方也通过一系列的博客来介绍 Go Modules，这是系列的第一篇文章。</p>
<p>原文地址：<a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">https://blog.golang.org/using-go-modules</a></p>
<hr>
<h2>简介</h2>
<p>这个系列的文章总共有 5 篇，这是第一篇：</p>
<ul>
<li>使用 Go Modules</li>
<li>迁移到 Go Modules</li>
<li>发布 Go Modules</li>
<li>Go Modules：V2 及后续版本</li>
<li>保持 Modules 的兼容性</li>
</ul>
<p>Go1.11 和 1.12 版本中初步支持了 Modules，Go 的新依赖管理系统使得依赖的版本信息更加清晰以及更容易管理。这篇文章将介绍 Go Modules 的基本使用。</p>
<p>一个 Module 是一系列 <a href="https://golang.org/ref/spec#Packages" target="_blank" rel="noopener">Go 的包</a>组成的文件树，并且在根目录下有一个 go.mod 文件。go.mod 文件中定义了Module 的路径（module path），这也是根目录的包路径（import path），以及依赖需求，这是构建应用所需要的其他 Modules。每个依赖都有一个 <strong>module path</strong> 和**<a href="https://semver.org/" target="_blank" rel="noopener">语义版本号</a>**。</p>
<p>从 Go1.11 开始，只要当前目录或者任何父目录中有 go.mod 文件，就可以使用 module 相关的命令，但这个目录必须要在 $GOPATH/src 之外。（在 $GOPATH/src 目录下，为了保持兼容性，即使 go.mod 文件存在，也只能运行老版本的命令。从<a href="https://golang.org/cmd/go/#hdr-Preliminary_module_support" target="_blank" rel="noopener">命令文档</a>中查看更多细节），从 Go1.13 开始，module 将作为默认的开发模式。</p>
<p>这篇文章介绍了使用 Go modules 来开发时的一系列常见操作：</p>
<ul>
<li>创建 module</li>
<li>添加依赖</li>
<li>更新依赖</li>
<li>为依赖添加主版本号</li>
<li>为依赖更新主版本号</li>
<li>移除无用的依赖</li>
</ul>
<h2>创建 module</h2>
<p>首先来创建一个新的 module。</p>
<p>在 $GOPATH/src 目录之外创建一个新的目录，并进入到这个目录，创建一个新的源文件 <code>hello.go</code>:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, world."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后写一个测试， <code>hello_test.go</code>：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    want := <span class="string">"Hello, world."</span></span><br><span class="line">    <span class="keyword">if</span> got := Hello(); got != want &#123;</span><br><span class="line">        t.Errorf(<span class="string">"Hello() = %q, want %q"</span>, got, want)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，这个目录包含一个 package，但还不是 module，因为这里没有 go.mod 文件。如果我们在 <code>/home/gopher/hello</code>目录下，然后运行 <code>go test</code>，就可以看到：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok  	_/home/gopher/hello	0.020s</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>最后一行展示了测试的情况。因为当前不在 $GOPATH 下，也不在任何模块下，go 命令知道当前目录没有包路径（Import path），就基于当前的目录名称创建了一个假的包路径：_/home/gopher/hello。</p>
<p>接下来在当前的目录中使用 <code>go mod init</code> 来创建一个 module，并且再次运行 go test：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod init example.com/hello</span><br><span class="line">go: creating new go.mod: module example.com/hello</span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	0.020s</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>恭喜，你已经编写并测试了你的第一个 module。</p>
<p>go mod init 命令会创建一个 go.mod 文件：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat go.mod</span><br><span class="line">module example.com/hello</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>go.mod 文件只会出现在 module 的根目录。子目录中包的包路径具有由 module 路径和子目录路径组成。比如现在创建了一个子目录 world，不需要在目录中再次运行 go mod init。这个包会被自动设别为 <code>example.com/hello</code> module 的一部分，包路径是 example.com/hello/world。</p>
<h2>增加依赖</h2>
<p>Go modules 被创造的最主要的动机是改善使用其他开发人员的代码的体验（即增加依赖）。</p>
<p>下面在 hello.go 中导入 rsc.io/quote 并用它来实现 Hello 方法：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"rsc.io/quote"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> quote.Hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在再次运行测试：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test</span><br><span class="line"><span class="keyword">go</span>: finding rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br><span class="line"><span class="keyword">go</span>: downloading rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br><span class="line"><span class="keyword">go</span>: extracting rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br><span class="line"><span class="keyword">go</span>: finding rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span>: finding golang.org/x/text v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170915032832</span><span class="number">-14</span>c0d48ead0c</span><br><span class="line"><span class="keyword">go</span>: downloading rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span>: extracting rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span>: downloading golang.org/x/text v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170915032832</span><span class="number">-14</span>c0d48ead0c</span><br><span class="line"><span class="keyword">go</span>: extracting golang.org/x/text v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170915032832</span><span class="number">-14</span>c0d48ead0c</span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	<span class="number">0.023s</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>go 命令通过 go.mod 中指定的特定依赖模块版本来解析这些导入。当一些导入所属的依赖没有在 go.mod 中定义时，go 命令会自动将这些依赖的最新版本添加到 go.mod 文件中。（Latest 表示最新标记的稳定(非预发布)版本，或者最新标记的预发布版本，或者最新的未标记版本。）在这个例子中，go test 会把 <a href="http://rcs.io/quote" target="_blank" rel="noopener">rcs.io/quote</a> 解析为 rcs.io/quote 模块，版本为 v1.5.2。同时也会下载 rsc.io/quote 的两个依赖：rsc.io/sampler 和 golang.org/x/text。只有直接依赖会被记录到 go.mod 文件中：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat go.mod</span><br><span class="line">module example.com/hello</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require rsc.io/quote v1.5.2</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>再次运行 go test 的不会再次下载依赖，因为 go.mod 现在是最新状态，下载的依赖被缓存在本地（在 $GOPATH/pkg/mod）。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	0.020s</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，虽然 go 命令可以快速、容易的添加依赖，但这是有代价的。你的模块功能的正确性、安全性、和许可证被你引入的那些新依赖决定（Ray注：意思是引入的这些依赖的安全性、程序是否被测试、是否引入了侵权的代码，这些都没法保证），而这只是其中的一小部分问题。更深入的思考，请查看 Russ Cox 的博客，<a href="https://research.swtch.com/deps" target="_blank" rel="noopener">我们的软件依赖问题</a>。</p>
<p>在前面可以看到，直接引入的依赖通常也会引入一些间接的依赖。 <code>go list -m all</code> 可以列出当前模块以及所有的依赖：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go list -m all</span><br><span class="line">example.com/hello</span><br><span class="line">golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">rsc.io/sampler v1.3.0</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>在 go list 的输出中，当前模块，也被称之为主模块会出现在第一行，下面跟着依赖的模块路径。</p>
<p>golang.org/x/text 的版本号 v0.0.0-20170915032832-14c0d48ead0c 叫做 Pseudo-versions，这是go 命令用于未打标记的提交的版本语法。</p>
<p>另外对于 go.mod，go 命令会维护一个 go.sum 文件，其中是所有依赖的特定版本号所生产的一个<a href="https://golang.org/cmd/go/#hdr-Module_downloading_and_verification" target="_blank" rel="noopener">哈希值</a>：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat go.sum</span><br><span class="line">golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZO...</span><br><span class="line">golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:Nq...</span><br><span class="line">rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3...</span><br><span class="line">rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPX...</span><br><span class="line">rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/Q...</span><br><span class="line">rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9...</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>go 命令使用 go.sum 文件确保后续下载这些模块所获得的内容与第一次下载获得的内容相同，确保项目所依赖的模块不会被意外更改，无论是恶意的、偶然的或者其他原因。go.mod 和 go.sum 都应该被纳入版本管理。</p>
<h2>更新依赖</h2>
<p>在 Go 的模块中，版本号使用语义版本来表示。一个语义版本有三个部分：主版本号、次版本号、补丁版本号。比如 v0.1.2，主版本是 0， 次版本是 1，补丁版本号 2。让我们来看一下次版本的更新，下一节，将会介绍主版本号的更新。</p>
<p>从 go list -m all 的输出中，我们看到了 golang.org/x/text 使用了未标记的版本号。我们把它更新到最新的标记版本，更新之后，上面的代码也通过了测试：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get golang.org/x/text</span><br><span class="line">go: finding golang.org/x/text v0.3.0</span><br><span class="line">go: downloading golang.org/x/text v0.3.0</span><br><span class="line">go: extracting golang.org/x/text v0.3.0</span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	0.013s</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>所有的功能正常，再来看一下 go list -m all 的输出和 go.mod 文件：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go list -m all</span><br><span class="line">example.com/hello</span><br><span class="line">golang.org/x/text v0.3.0</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">rsc.io/sampler v1.3.0</span><br><span class="line">$ cat go.mod</span><br><span class="line">module example.com/hello</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    golang.org/x/text v0.3.0 // indirect</span><br><span class="line">    rsc.io/quote v1.5.2</span><br><span class="line">)</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>golang.org/x/text 已经被更新到最新的标记版本（v0.3.0）。go.mod 文件中也被更新到了 0.3.0 版本。 <code>indirect</code> 表示这个依赖不是直接被模块使用，只是间接的被其他的模块依赖。通过 <code>go help modules</code> 可以查看更多的细节。</p>
<p>现在，让我试着用同样的方法来更新 rsc.io/sample 的次版本号，先执行 go get 命令，然后执行 go test 命令：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get rsc.io/sampler</span><br><span class="line">go: finding rsc.io/sampler v1.99.99</span><br><span class="line">go: downloading rsc.io/sampler v1.99.99</span><br><span class="line">go: extracting rsc.io/sampler v1.99.99</span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">--- FAIL: TestHello (0.00s)</span><br><span class="line">    hello_test.go:8: Hello() = <span class="string">"99 bottles of beer on the wall, 99 bottles of beer, ..."</span>, want <span class="string">"Hello, world."</span></span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL	example.com/hello	0.014s</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>错误的信息显示最新版本 rsc.io/sampler 与程序不兼容。来看一下，这个模块所有可用的标记版本：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go list -m -versions rsc.io/sampler</span><br><span class="line">rsc.io/sampler v1.0.0 v1.2.0 v1.2.1 v1.3.0 v1.3.1 v1.99.99</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>上面已经用了 v1.3.0，v1.99.99 看起来不适合。下面来试一下 v1.3.1 版本：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get rsc.io/sampler@v1.3.1</span><br><span class="line">go: finding rsc.io/sampler v1.3.1</span><br><span class="line">go: downloading rsc.io/sampler v1.3.1</span><br><span class="line">go: extracting rsc.io/sampler v1.3.1</span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	0.022s</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>注意要在 go get 中明确指明 @v1.3.1 这个版本号。通常来说，go get 命令都可以接收一个特定的版本号，默认是 @latest，表示之前定义的最新版本。</p>
<h2>依赖添加主版本号</h2>
<p>让我们在包中添加一个新的方法， <code>Proverb</code> 方法返回一个 <a href="https://go-proverbs.github.io/" target="_blank" rel="noopener">Go 的并发谚语</a>，通过 rsc.io/quote/v3 中的<code>quote.Concurrency</code> 方法来提供。首先在 hello.go 中添加一个新方法：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"rsc.io/quote"</span></span><br><span class="line">    quoteV3 <span class="string">"rsc.io/quote/v3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> quote.Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Proverb</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> quoteV3.Concurrency()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后添加一个测试 hello_test.go：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProverb</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    want := <span class="string">"Concurrency is not parallelism."</span></span><br><span class="line">    <span class="keyword">if</span> got := Proverb(); got != want &#123;</span><br><span class="line">        t.Errorf(<span class="string">"Proverb() = %q, want %q"</span>, got, want)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行这个测试：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">go: finding rsc.io/quote/v3 v3.1.0</span><br><span class="line">go: downloading rsc.io/quote/v3 v3.1.0</span><br><span class="line">go: extracting rsc.io/quote/v3 v3.1.0</span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	0.024s</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>现在这个模块中 rsc.io/quote 和 rsc.io/quote/v3 这两个依赖同时存在：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go list -m rsc.io/q...</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">rsc.io/quote/v3 v3.1.0</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>Go 模块每个不同的主版本号（v1，v2 等等）都使用不同的模块路径，从 v2 开始，路径必须以主版本号结尾。在这个例子中，rsc.io/quote 的 v3 版本的路径不再是 rsc.io/quote，而是 rsc.io/quote/v3。这种习惯被称之为<a href="https://research.swtch.com/vgo-import" target="_blank" rel="noopener">语义导入版本</a>，会给不兼容的包（拥有不同的主版本号）不同的名称。相反 rsc.io/quote 的 v1.6.0 必须向后兼容 v1.5.2，所以会重用 rsc.io/quote 这个路径名称。（在之前的版本中，rsc.io/sampler v1.99.99 应该向后兼容 rsc.io/sample v1.3.0，但是因为 bug 或者不正确的客户端存在，模块的这些行为都是有可能发生的。）</p>
<p>go 命令在构建中只允许任何特定的模块存在至多一个主版本，意味着只能每个模块的主版本只能出现一次：一个 rsc.io/quote，一个 rsc.io/qutoe/v2，一个 rsc.io/quote/v3，以此类推。这为模块作者提供了关于单个模块路径可能重复的明确规则：rsc.io/quote v1.5.2 和 rsc.io/quote  v1.6.0 不能同时出现在同一次构建中。同时，允许有不同主版本的模块出现类同一个构建中（因为拥有不同的路径），这也给模块的消费者可以有增量升级主版本的能力。在这个例子中，我们想要调用rsc/quote/v3 v3.1.0 中的 quote.Concurrency 方法，但是这个方法还没有在 rsc.io/quote v1.5.2 中实现。这种增量迁移的能力在大型的程序或者代码库中很重要。</p>
<h2>依赖更新主版本号</h2>
<p>让我们来完成从 rsc.io/quote 到 rsc.io/quote/v3 的迁移。因为主版本好改变，我们认为一些 API 可能已经删除、重名或者做了其他不兼容的修改。阅读文档，我们可以看到 Hello 已经被升级为 HelloV3：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go doc rsc.io/quote/v3</span><br><span class="line">package quote // import <span class="string">"rsc.io/quote/v3"</span></span><br><span class="line"></span><br><span class="line">Package quote collects pithy sayings.</span><br><span class="line"></span><br><span class="line">func Concurrency() string</span><br><span class="line">func GlassV3() string</span><br><span class="line">func GoV3() string</span><br><span class="line">func HelloV3() string</span><br><span class="line">func OptV3() string</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>在 hello.go 中，我们可以把 quote.Hello() 使用 V3.HelloV3() 来替代：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> quoteV3 <span class="string">"rsc.io/quote/v3"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> quoteV3.HelloV3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Proverb</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> quoteV3.Concurrency()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而且，也不再需要重命名导入了，所以可以撤销这个重命名：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"rsc.io/quote/v3"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> quote.HelloV3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Proverb</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> quote.Concurrency()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们重新运行测试，确保这些功能都是正常的：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok      example.com/hello       0.014s</span><br></pre></td></tr></table></figure></p>
<h2>移除无用的依赖</h2>
<p>我们已经在删除了所有用到 rsc.io/quote 的代码，但是这个版本还一直在 go.mod 文件中，通过 go list -m all 命令看到:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go list -m all</span><br><span class="line">example.com/hello</span><br><span class="line">golang.org/x/text v0.3.0</span><br><span class="line">rsc.io/quote v1.5.2</span><br><span class="line">rsc.io/quote/v3 v3.1.0</span><br><span class="line">rsc.io/sampler v1.3.1</span><br><span class="line">$ cat go.mod</span><br><span class="line">module example.com/hello</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    golang.org/x/text v0.3.0 // indirect</span><br><span class="line">    rsc.io/quote v1.5.2</span><br><span class="line">    rsc.io/quote/v3 v3.0.0</span><br><span class="line">    rsc.io/sampler v1.3.1 // indirect</span><br><span class="line">)</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>这是为什么？因为在构建单个包，比如 go build 或者 go test，可以清晰的发现那些依赖是缺失的，需要被添加，但却不能明确哪些依赖可以被安全删除。只有检查模块中所有的包以及这些包所有的可能的构建组合之后，如果这个依赖还是没有被用到，才能删除这个依赖。通常的构建命令不会去做这些检查，也就不能安全的删除依赖。</p>
<p>使用 <code>go mod tidy</code> 则可以清理这些无用的依赖：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">$ go list -m all</span><br><span class="line">example.com/hello</span><br><span class="line">golang.org/x/text v0.3.0</span><br><span class="line">rsc.io/quote/v3 v3.1.0</span><br><span class="line">rsc.io/sampler v1.3.1</span><br><span class="line">$ cat go.mod</span><br><span class="line">module example.com/hello</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    golang.org/x/text v0.3.0 // indirect</span><br><span class="line">    rsc.io/quote/v3 v3.1.0</span><br><span class="line">    rsc.io/sampler v1.3.1 // indirect</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	0.020s</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<h2>小结</h2>
<p>Go modules 是 Go 依赖管理的未来。模块功能可以在所有支持的 Go 版本中使用（包括 Go1.11 和 Go1.12）。</p>
<p>这篇文章中介绍了 Go modules 的这些功能：</p>
<ul>
<li>go mod init 创建一个新的模块，并初始化描述这个模块的 go.mod 文件</li>
<li>go build，go test 和其他包内构建命令添加需要的新依赖到 go.mod 文件中</li>
<li>go list -m all 打印当前模块所有的依赖</li>
<li>go get 改变当前依赖的新版本（或者添加一个新的依赖）</li>
<li>go mod tidy 移除无用的依赖</li>
</ul>
<p>我们鼓励你在本地的开发中在项目中添加 go.mod 和 go.sum，开始使用模块功能。请向我们发送<a href="https://github.com/golang/go/issues/new" target="_blank" rel="noopener">bug 报告</a>和<a href="https://github.com/golang/go/wiki/ExperienceReports" target="_blank" rel="noopener">体验报告</a>，帮助我们改善 Go 的依赖管理功能。</p>
<p>感谢您所有的反馈和帮助改进模块的建议。</p>
<hr>
<p>另外，腾讯云区块链方向在大量招人，包括前端、后端、架构师、产品等诸多岗位，如果感兴趣，请把简历投过来 <a href="mailto:rayjun0412@gmail.com">rayjun0412@gmail.com</a>。</p>
<p>译 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>使用go开发一个API</title>
    <url>/2018/10/06/%E4%BD%BF%E7%94%A8go%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAPI/</url>
    <content><![CDATA[<h4>内容准备</h4>
<ul>
<li>
<p>go1.11</p>
</li>
<li>
<p>govendor</p>
</li>
<li>
<p>gin</p>
</li>
<li>
<p>jwt</p>
</li>
<li>
<p>xorm</p>
</li>
<li>
<p>supervisord</p>
</li>
<li>
<p>nginx</p>
</li>
</ul>
<h4>Govendor</h4>
<p>项目使用 <code>govendor</code> 作为项目的包管理器,项目的代码结构如下:</p>
<ul>
<li>projectname
<ul>
<li>controller</li>
<li>model</li>
<li>vendor
<ul>
<li>vendor.json</li>
<li>...</li>
</ul>
</li>
<li>tests</li>
<li>main.go</li>
</ul>
</li>
</ul>
<p>vendor 目录底下是当前项目说依赖的第三方包存放的地方。其中有一个 <code>vendor.json</code>的文件是用来记录项目包的依赖情况。如果依赖包中的代码不想提交到 <code>git</code> 上，可以忽略掉，在<code>.gitignore</code> 文件内加上:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vendor/* </span><br><span class="line"></span><br><span class="line">!vendor/vendor.json</span><br></pre></td></tr></table></figure></p>
<p>然后在服务器部署的时候只需要执行以下命令就可以拉取依赖代码:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">govendor sync</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>需要注意的是，使用 <code>govendor</code> 所有的代码需要放在 <code>$GOPATH/src/</code> 目录下。</p>
</blockquote>
<h4>gin+jwt+xorm 编写api</h4>
<p>项目的<code>api</code>部分使用<code>gin</code>和<code>jwt</code>以及<code>xrom</code>编写。</p>
<h4>部署</h4>
<p>部署的阶段使用 <code>nginx</code> + <code>supervisord</code> 来完成。将编译完的程序使用 <code>supervisord</code> 管理起来，确保程序不会断线，然后使用 <code>nginx</code> 通过反向代理的方式开放接口，配置方式如下:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123; </span><br><span class="line"></span><br><span class="line">listen 80; </span><br><span class="line"></span><br><span class="line">server_name xxxx; </span><br><span class="line"></span><br><span class="line">return 301 https://$host$request_uri; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">server&#123; </span><br><span class="line"></span><br><span class="line">listen 443; </span><br><span class="line"></span><br><span class="line">server_name xxxx; </span><br><span class="line"></span><br><span class="line">location / &#123; </span><br><span class="line"></span><br><span class="line">proxy_pass http://localhost:8080; </span><br><span class="line"></span><br><span class="line">proxy_buffer_size 64k; </span><br><span class="line"></span><br><span class="line">proxy_buffers 32 32k; </span><br><span class="line"></span><br><span class="line">proxy_busy_buffers_size 128k; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">\#ssl 配置 </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就完成了使用 <code>gin</code> 来完成最小的<code>api</code>的发布。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>关于调度器的一些思考</title>
    <url>/2021/11/06/%E5%85%B3%E4%BA%8E%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>在前面 channel 的文章中，我们也花了很大的篇幅来说调度器，调度器是 Go 高效并发的关键。也是 goroutine 和 channel 工具的背后支撑。这篇文章来看一下 Go 调度器的设计思路。</p>
<h2>1. 为什么需要调度器</h2>
<p>在 Go 中，无法直接使用系统线程，只能使用 goroutine，可以被看做是用户态的线程。相比于操作系统的线程，goroutine 很轻量级，最小的栈空间只需要 2 kb。而且 goroutine 只存在于用户态，所以创建、销毁上下文的切换都会快很多。</p>
<p>goroutine 在被创建之后，不一定可以完整的执行完成，在期间可能会被各种打断，比如 channel 的阻塞，系统调用的阻塞，这些都会打断 goroutine 的执行，为了保证其他的 goroutine 能够顺利的继续执行，就需要有一个机制来协调，在一些 goroutine 被打断执行的时候，能够将系统资源让给其它可以执行的 goroutine。</p>
<p>正因为 goroutine 只在用户态存在，内核感觉不到 goroutine。 线程由操作系统去调度，但没有办法调度 goroutine，所以 Go 必须实现自己的 goroutine 调度器。</p>
<p><img src="0.png" alt=""></p>
<p>Go 语言是为并发而生的，所以调度器需要满足下面这些要求，首先应该只使用少量的系统线程，线程创建和切换的代价太大，如果还需要大量的使用内核线程，那么 gouroutine 就没有存在的的必要。同时要支持高并发，必须同时支持大量的 goroutine 运行，而且 Go 必须可以充分利用现代多核机器的特性，要让所有的 goroutine 均匀分到不同的核心上运行。</p>
<h2>2. 怎样实现调度器</h2>
<p>在实现调度器时，需要解决的一个核心问题就是，<strong>怎么让大量的 goroutine 运行在内核线程上</strong>。</p>
<p>在开始实现之前，需要做一些准备工作，在堆上分配一个先进先出（FIFO）队列，用来存放待运行的 goroutine（调度器的实际实现中，会有多个队列来存放待运行的 goroutine）。</p>
<p>我们以下面的这段代码为例，g0 中需要处理一些图片，启动了一些 goroutine 去处理，在 g1 到 gn 中,图片处理完成之后，需要把图片写入磁盘：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// g0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> images &#123;</span><br><span class="line">        <span class="keyword">go</span> process(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g1...gn</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(i image)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 写入磁盘，这里会发生系统调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么接下来有几种思路：</p>
<p><strong>思路一：所有的 goroutine 运行在一个线程上</strong></p>
<p>很明显，这样是行不通的，这样 goroutine 没办法并行，如果有一个 goroutine 发生了阻塞，那么其他的 goroutine 也只能等着。虽然有多个 CPU 核心，也只会用到其中的一个。</p>
<p><img src="1.png" alt=""></p>
<p><strong>思路二：为每一个 goroutine 维护一个线程</strong></p>
<p>这个方案很明显也是行不通的，创建 goroutine 就是为了不重复去创建线程，这样还不如直接用线程。那就只剩下最后一个思路。</p>
<p><img src="2.png" alt=""></p>
<p><strong>思路三：让 goroutine 运行在固定的几个线程上</strong></p>
<p>在创建一些线程之后，让不同的 goroutine 来重用这些线程。确定这个思路之后，那还剩三个问题需要解决：</p>
<ul>
<li>什么时候创建线程</li>
<li>创建几个线程合适</li>
<li>怎么把 goroutine 分配到线程上运行</li>
</ul>
<p><img src="3.png" alt=""></p>
<p>创建一个线程的代价很大，所以只在需要的时候才创建线程，当一个 goroutine 需要运行，发现所有的 线程都处在忙碌的时候，就需要去创建一个新的线程。</p>
<p>系统线程不能创建过多，如果创建太多，操作系统层，线程在不断的切换，并发自然上不去，也不能创建太少，太少的话，无法充分利用操作系统的多核特性。而且在这里还有一个很关键的地方就是要重用这些内核线程，如果一个内核线程在执行完一个 goroutinr 之后，不会立马去销毁它，而且把它放到一个队列中维护起来，后续如果有其他的 goroutine 进来之后，就是从这个队列中取出一个线程来运行 goroutine。</p>
<p>这里解决了一个大问题，我们只用了很少的线程，让系统实现了并发。但是这里又出现了一个其他的问题，当我们有上万个 goroutine 需要调度的时候，而且每个 goroutine 中任务都比较耗时的时候，系统就会不断的去创建新的线程，这肯定不是我们想看到的，所以要限制线程的创建，一般认为内核的线程数量与 CPU 的核心数量相等是比较好的选择，如果线程的数量已经与核心数量相等，那么就不会再继续创建新的线程了，而是等到有其他的线程空闲下来再去运行新的 goroutine。</p>
<p>到这里，还会有一个问题，按照上面的设计，所有的 goroutine 都放在一个队列中，这样会有让所有的线程同时去访问这个队列，这样就让并发的效率的降低了很多，因为每次线程来取  goroutin 的时候，都需要加锁。</p>
<p><strong>解决这个问题的方法是每个线程都有一个自己的 goroutine 队列</strong>。</p>
<p>到这里，问题都解决了吗？并没有，设想一种情况，有一个线程上的 goroutine 都比较简单，很快就都执行完了，但是另外一个线程上的任务都比较耗时，这样先执行的完的那个线程就空闲下来了。</p>
<p>为了让这个线程不空闲下来，所以它需要去其他的线程上了拿一部分任务过来，<strong>它会随机选一个线程，拿走一半的任务，这个机制被称之为 work steal</strong>，很形象。</p>
<p>但这还没有到完美，还有一个问题。在上面的示例代码中，我们看到有时候 goroutine 可能会做一些非常耗时的操作，比如写入文件到磁盘。而这个线程的队列中还有很多待执行的 goroutine，这个时候，调度器就会把这个被阻塞的线程的运行队列转移到另一个空闲的线程上。<strong>这个机制被称之为 hand off</strong>。</p>
<p>在 hand off 机制中，会有一个特殊的后台线程来帮助创建一个新的线程，并且这里可以突破上面那个线程数不能大于核心数的限制，然后把被阻塞线程的运行队列移过来。</p>
<p>在被 hand off 机制处理后的线程，会从阻塞的状态中回来，这个线程上的 goroutine 不会被放回到线程的队列中，而是会放回到一个全局的队列中。当其他线程没有任务的时候，会来这个全局队列中取任务。</p>
<p>当然实际上调度器在设计的时候，细节上还是会有一些差异，但是整体的思路是这样的。</p>
<h2>3. 小结</h2>
<p>总的来说，调度器的设计有三个关键点：</p>
<ul>
<li>复用线程</li>
<li>限制内核线程的数量</li>
<li>调度策略采用 work steal 和 handoff 机制</li>
</ul>
<p>但是目前的调度器也还是存在一些限制，比如，目前的队列都是 FIFO，没办法实现优先级调度，也没有实现抢占策略，但这些目前已经有改进的提案，等待后续的跟进。</p>
<p>文 / Rayjun</p>
<p>[1] <a href="https://www.youtube.com/watch?v=YHRO5WQGh0k" target="_blank" rel="noopener">https://www.youtube.com/watch?v=YHRO5WQGh0k</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>再见，2020</title>
    <url>/2021/01/03/%E5%86%8D%E8%A7%81%EF%BC%8C2020/</url>
    <content><![CDATA[<p>你好，所有人。</p>
<p>又到了每一年的保留节目，年终总结，以往都是在除夕那天发出来，今年期望 2020 能快点过去，就提前发了。</p>
<p>2020 年戴了一年的口罩，但不管怎么说，这一年终究还是过去了。</p>
<p>工作方面出乎意料的是，在年底我居然换工作了，这个实在是没有想到，我自己也觉得很突然，从决定出去面试到最后拿下 offer，总共花了 10 天时间。</p>
<p>在年初的时候，很多公司在家里办公，我每天从公司给桃子带了两个月的饭，但是到年底的时候，我却已经从小米走了。</p>
<p>最近小米的同事给我寄东西，在系统里面找我的手机号，发现已经完全找不到我的信息了，实在是太迅速了。与父母辈可能会在一家公司待一辈子不同，我想，应该要习惯这种不稳定的常态。</p>
<p>换工作之后，就正式转入区块链这个领域了，我在 2013 年就接触比特币，现在又重新投入到这相关的行业中，不出意外的话，未来若干年都会在这个领域。</p>
<p>今年学英语很努力，但只有阅读能力提升比较明显，现在看英文文档很流利，基本不需要查字典，但是在口语方面还是堪忧，没有使用场景，技能学习起来真的很费劲，当然还是需要继续学。</p>
<p>今年书看的不错，大概看了 30 本左右，虚构和非虚构各占一半，非虚构的书集中在金融和提升认知的上面，非虚构最好的书是 《事实》，虚构的书主要是小说，村上春树的小说占了一大半，推荐《寻羊冒险记》，然后还看完了《银河系搭车客指南》全系列，虽然我觉得没有《三体》和《基地》精彩，但也算是很好的科幻小说。</p>
<p>2021 的看书目标就是要更加系统的阅读，多思考，将看过的书最好是通过文字或者视频的形式输出。</p>
<p>今年也有遗憾，年初的旅游计划一个也没有实现。还好也有些弥补，在 9 月份的时候回了一趟老家，还是家里的小龙虾和螃蟹好吃，然后在十一去了一趟重庆，小面和火锅是真的好吃。</p>
<p>另外，今年对自己的脾气控制的要好一些，不那么急躁，在面对突发情况的时候能够沉得下气，这方面要继续努力。</p>
<p>今年身体情况不错，虽然体检上有些小毛病，但都在可接受的范围内，在新的一年，需要提升一下运动量了（托公司健身房的福），毕竟身体才是革命的本钱。</p>
<p>感情生活依然稳定，两个人一起相互鼓励和成长的感觉很好。</p>
<p>新的一年也不立 flag 了，继续努力工作，提升能力，多思考，多输出，另外就是希望家人和朋友都身体健康，今年过完了，真心觉得好好活着最重要。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>写在25岁</title>
    <url>/2018/04/12/%E5%86%99%E5%9C%A825%E5%B2%81/</url>
    <content><![CDATA[<p>不知不觉中，已经站在了25岁的门槛上了，从自己来到北京也已经到第七年了。而我此时也站在了毕业的门槛上。</p>
<p>今年迈过的这个岁数对我来说有着不一样的意义。在这七年的时间里，有过激动的时刻。也有过难过的时刻。当然还有过犯浑的时刻。这些都已经实实在在的刻在了我的记忆中，我已经没有了修改的权限。</p>
<p>这几年的时间里，我觉得对于我自己来说，最大的成长就是直面现实。以前会在一些问题面前选忽视、刻意看不见、甚至是逃避。总说不要在一个地方跌倒多次，可我已经记不清我在这个地方跌倒过多少次了。总之，总算是明白了，问题，解决就是了。</p>
<p>18的岁的时候，觉得做啥都简单。大多数时候是想把一件事即不花时间又要做的很好。然而，这个其实很差劲的想法又继续折磨了我好多年。18岁的冲动我一辈子都想要，但是这个做法就算了。</p>
<p>短期内有好处的事情做起来总是很爽，长期来说有好处的事做起来总是痛苦。在选择真正的直面现实之前，这个选择不是那么的好做。但是现在，好做多了。</p>
<p>所有的意义都是自己给的，给出的所有意义最终都会回到自己身边。</p>
<p>18 til i die</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2018/04/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>冒泡排序是通过不断的比较相邻的两个元素。如果顺序不对，就将他们交换，直到所有的元素都不再需要交换，就完成了排序。</p>
<h4>算法描述（以升序为例）</h4>
<ol>
<li>比较相邻的两个元素，如果第一个大于第二个，就交换它们；</li>
<li>对每一对相邻元素用1中的方式处理，直到数组的结尾，此时，最大的元素应该在最后边。</li>
<li>对数组再次用1、2的方式遍历，除了最后一个元素。</li>
<li>重复1-3，直到排序完成。</li>
</ol>
<p>算法可以用以下的动图来表示:</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/849589-20171015223238449-2146169197.gif" alt="算法示意图"></p>
<h4>算法代码</h4>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>写在毕业</title>
    <url>/2018/07/10/%E5%86%99%E5%9C%A8%E6%AF%95%E4%B8%9A/</url>
    <content><![CDATA[<p>与工大的七年长跑终于告一段落了。在人生的这个重要的阶段里面，我收获了毕业证和学位证，同时也收获了这段回忆。整体上来说，我对这段经历还算满意，因为在这段经历里面，不是我做出了多么了不起的事情，而是我已经完成了自我的觉醒，我现在有了足够的认证去我自己的未来做规划，去决定我自己应该有一个什么样的未来。这个对我来说是最为重要的一个事情。</p>
<p>在刚上大学的时候，会对大学以后有着很多的期待。期待自己能够做一些不一样、很出彩的事情。知道研究生阶段，我才开始明白，原来最为出彩的事情就是真正的活出一个独一无二的自己。自己的价值所在其实就是自己思考的方式、自己的方法论、自己的价值观。即使在毕业这个时刻的我有很多的缺点，冒险精神的不足、系统思考的能力不足、决断的能力也不足、抓住机会的能力不强、不知道如何适当的拒绝别人，在某些场合表达自己的观点的能力较弱，公开发表演讲的能力也不强。但是我也有不少的优点，我思考问题很全面，做事情很稳，我对新生的事物有着充足的好奇心，在私下场合我有很好的口才。不够完美，但是也还有很大的改进的空间。在毕业的时候回过头一看，好多很基础但是很重要的事情却都没有做好。没有学好英语、没有学好写作，没有将技术的底子打的更牢固一点。缺少实际的目标，比如保研的事情，很多事情做到半途就放弃了，比如参加国创、比如比特币。这些都将成为我自己的债务，总是要还清的。</p>
<p>所有这些没有做好的事情其实都可以归结于一个原因，就是自己的认知不够，对于自己的认知不够，对于这个社会的认知不够，所以才难以在关键的做出正确的选择。这个可能是在本科的时候学到的最重要的事情。在研究生的时候，也犯了重复的错误，但是因为没有听从正确的建议做出了缺乏思考的决定，说到底也还是缺乏认知。但是好在我学到了提升自己认知的最好的方式是读书、独立思考。在本科的时候，虽然也读了不少的书，但是对于读的书缺乏总体的规划和总结，也缺乏自己的思考。在进入研究生之后，这个情况大体上也没有得到很好的解决。但是非虚构的书籍读的更多一些，情况比本科的时候就要好上一些。</p>
<p>大学的时候参加了很多的的比赛，也拿了不少的奖，这些奖很大程度上是对我能力的认可。我参加了不同类型的比赛，有技术上的，有创业类型的，这些比赛帮助我探索了自己的边界，一个人要完全了解自己是一件非常难的事情，但是通过不断的尝试新的事物是一个了解自己的好方法，这样就可以对自己不设限。能够最大意义上的去了解自己。</p>
<p>大学的时候也做了很长时间的学生干部，这些事情帮我初步了解了一个组织的运作方式，了解了个人与组织的共存方式。更重要的是我在当学生干部的过程中体会到了与人沟通的重要性。每个人都是一个孤岛，沟通是我们唯一的桥梁。与人的经常性沟通让我慢慢成为了一个不那么偏激的人，而且看问题的角度也会变的更多样化。没有沟通解决不了的问题，如果有，那肯定是沟通的姿势不对。</p>
<p>大学的时候也交了一些好朋友，能交上好朋友真是让人愉快的事情。在困惑迷茫的时候有个朋友坐下来一块喝个酒真是人生的一大乐事。</p>
<p>毕业这也将是另一个阶段的起点，即使在这个阶段里面，很多的事情做的不完美，有缺憾，但是已经是过去的事情。现在该是打起精神迎接新阶段的时候了。过去的我有一些话要送给新阶段的我：</p>
<ol>
<li>在每个阶段都有着不同的角色，尽快的去熟悉你当前的角色，熟悉它，做好它</li>
<li>在做任何一件事情之前，设定好自己的目标，没有目标的事情做起来都是浪费时间</li>
<li>不要盲目的自信，对于具体的问题，用客观的方法和数据去评估</li>
<li>遇到问题，沟通沟通再沟通</li>
<li>好好读书</li>
<li>好好吃饭</li>
<li>好好健身</li>
<li>好好旅游</li>
</ol>
<p>18 til i die</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>保持模块的兼容性</title>
    <url>/2021/02/18/%E4%BF%9D%E6%8C%81%E6%A8%A1%E5%9D%97%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
    <content><![CDATA[<p>这是 Go Modules 系列的最后一篇文章，前面的四篇文章中介绍了如何使用模块，以及如何更新大版本，最后这篇文章将介绍一下在项目的维护过程中，如何保证项目的兼容性。</p>
<p>原文地址：<a href="https://blog.golang.org/module-compatibility" target="_blank" rel="noopener">https://blog.golang.org/module-compatibility</a></p>
<h2>简介</h2>
<p>这个系列的文章总共有五篇，这是第五篇：</p>
<ul>
<li><a href="http://">使用 Go Modules</a></li>
<li><a href="http://">迁移到 Go Modules</a></li>
<li><a href="http://">发布 Go Modules</a></li>
<li><a href="http://">Go Modules：V2 及后续版本</a></li>
<li><strong>保持 Modules 的兼容性</strong></li>
</ul>
<p>你的模块随着不断的添加新特性，以及重新设计公开接口而不停变化。正如<a href="http://">上一篇</a>文章所讨论的，对 v1+ 模块做出破坏性修改，就必须升级主版本号（或者采用新的模块路径）。</p>
<p>然而，发布一个主版本对用户就不太友好。他们必须找到新的版本，并学习新的 API，然后修改他们的代码。有些用户可能永远也不会更新，这就意味着你也必须永远维护者两个版本的代码。所以最好是对你现在的代码用兼容的方式修改。</p>
<p>在这篇文章中，我们会介绍一些不做破坏性修改的技术。一句话概括就是：增加，不要修改或删除。我们也会讨论如何从一开始就对 API 的兼容性进行设计。</p>
<h2>增加函数</h2>
<p>通常，给方法增加参数就是一种破坏性修改。我们将会讨论一些处理这类变更的方法，但在这之前，先来看一些不合理的修改方式：</p>
<p>当想用一种好的方式来增加新参数时，却很容易添加成可变参数。来扩展下面这个函数：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(name String)</span></span></span><br></pre></td></tr></table></figure></p>
<p>添加一个默认值为 0 的 size 参数，有人可能会用下面的形式：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, size ...<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>当前对这个方法的所有调用都能继续正常工作，但是对 Run 方法其他用法可能就会出问题，比如下面这种：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypkg</span><br><span class="line"><span class="keyword">var</span> runner <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> = <span class="title">yourpkg</span>.<span class="title">Run</span></span></span><br></pre></td></tr></table></figure></p>
<p>原来的 Run 方法不会报错是因为它的类型是 <code>func(string)</code>，但是新 Run 方法的类型是 <code>func(string, ...int)</code>，所以上面的代码会在编译时报错。</p>
<p>保证调用的兼容性并不足以保证向后兼容性。因此，对函数的签名修改了就无法保证向后的兼容性。</p>
<p>所以解决方法是<strong>增加一个方法</strong>，而不是修改一个方法的签名。举个例子，在引入 context 包之后，把 context.Context 作为函数的第一个参数已经成为一个常见的做法。然而，对于已经稳定的 api，不能给已经暴露出去的函数加上 context.Context 参数，因为这样会伤害到所有在使用这个函数的用户。</p>
<p>因此，需要增加新方法。比如 database/sql 包中 Query 方法的签名是（一直都是）：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Query</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>当 context 包被创建之后，Go 的开发团队为 database/sql 包增加了一个新方法：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">QueryContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>为了避免复制代码，老方法调用了新方法：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Query</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.QueryContext(context.Background(), query, args...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过增加新的方法可以用户自己掌握迁移的速度。新增的方法读取方法类似，而且排列在一起，新方法的名称中也包含了 Context，因此 database/sql API 的扩展并没有降低包的可读性。</p>
<p>如果你预计函数在后续可能需要更多参数，可以提前做准备，把可选实参作为函数签名的一部分。最简单的方式是添加一个 struct 参数，比如 crypto/tls.Dial 方法就是这么做的：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(network, addr <span class="keyword">string</span>, config *Config)</span> <span class="params">(*Conn, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>通过 Dial 方法进行 TLS 通信需要 network 和 address 的参数，而其他的很多参数则有一个合理的默认值。如果直接给 config 参数传递 nil，则使用默认值。如果传入了一个 Config 结构体，那些设定了值的字段将覆盖默认值。以后如果要为 TLS 配置一个参数只需要在 Config 结构体中增加一个字段，这个修改是向后兼容的（几乎总是向后兼容的-见下文的<strong>维护结构体的兼容性</strong>）。</p>
<p>有时候添加新函数和可选参数可以把选项构造为方法接收器。下面来看一下 net 包中监听网络地址功能的演变。在 Go1.11 之前，net 包仅仅提供了一个 Listen 函数：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Listener, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>在 Go1.11 中，两个新功能被添加到 net 包的监听功能中：传入一个 context，允许调用者在创连接后而没有绑定之前，通过一个”控制函数”来调整原始连接。如果按照通常的做法，就会产生一个接受context、network、address 和控制函数的新函数。但包的作者没有这么做，而是新增了一个 ListenConfig 结构体，以便在将来添加更多的参数。而且他们没有在报级别添加一个名称很长的函数，而是直接在 ListenConfig 中添加了一个 Listen 方法：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListenConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">    Control <span class="function"><span class="keyword">func</span><span class="params">(network, address <span class="keyword">string</span>, c syscall.RawConn)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(*ListenConfig)</span> <span class="title">Listen</span><span class="params">(ctx context.Context, network, address <span class="keyword">string</span>)</span> <span class="params">(Listener, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>另一种提供提供可选参数的方法是<strong>选项类型</strong>模式，在这种模式中，每个选项都是一个函数，通过函数来修改值的状态。这种方法在 Rob Pike 的 <a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">Self-referential functions and the design of options</a> 文中做了详细的描述。另外一个被广泛使用的例子是 <a href="http://google.golang.org/grpc" target="_blank" rel="noopener">google.golang.org/grpc</a> 包中的 DialOption。</p>
<p>选项类型在函数参数中扮演与结构体选项相同的角色：它们都可以通过一种可扩展的方式来修改行为。选择哪个要看具体的场景。来看一下一下 gRPC 的 DialOption 选项类型的简单用法：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">grpc.Dial(<span class="string">"some-target"</span>,</span><br><span class="line">  grpc.WithAuthority(<span class="string">"some-authority"</span>),</span><br><span class="line">  grpc.WithMaxDelay(time.Second),</span><br><span class="line">  grpc.WithBlock())</span><br></pre></td></tr></table></figure></p>
<p>这也同样可以被实现为一个结构体选项：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">notgrpc.Dial(<span class="string">"some-target"</span>, &amp;notgrpc.Options&#123;</span><br><span class="line">  Authority: <span class="string">"some-authority"</span>,</span><br><span class="line">  MaxDelay:  time.Second,</span><br><span class="line">  Block:     <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>选项类型有一些副作用：它要求在每个调用的选项前写入包名，它们增加了包命名空间的大小。如果同一个选项调用了两次，我们也不清楚会发生怎样的行为。另一方面，接收选项类型的函数需要接收一个有可能总是为 nil 的参数。而且当一个类型的零值有意义时，总是需要为这个选项指定默认值，这样就不太优雅，通常需要一个指针或者一个额外的布尔字段。</p>
<p>为了确保模块的公共 API 在未来的扩展性，这两种方法都是合理的。</p>
<h2>使用接口</h2>
<p>有时候，新特性需要对公开的接口进行更改：例如，需要用新方法扩展接口。但直接把新方法添加到接口是一个有破坏性的修改，那么，我们如何在公开的接口上添加新方法？</p>
<p>基本思想是定义新接口来接收新方法，然后在使用旧接口的地方，动态检查使用的类型是旧类型还是新类型。</p>
<p>让我们用 archive/tar 包的例子来说明这一点。tar.NewReader 接收一个 io.Reader 参数，但随着时间的推移， Go 团队意识到如果可以调用 Seek，从一个文件头调到一下个文件头就会很有效率。但是他们不能给 io.Reader 添加一个 Seek 方法。这回会破坏 io.Reader 的所有实现。</p>
<p>另一个被排除的选择是修改 tar.NewReader 的参数，不接受 io.Reader，而是接收 io.ReadSeeker，因为这样可以同时支持 io.Reader 和 Seek（通过 io.Seeker）。但是，正如之前所讨论的，修改函数签名也是一个破坏性的修改。</p>
<p>所有，他们决定不动 tar.NewReader 的签名，而是在 tar.Reader 中增加了对 io.Seeker 的支持：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tar</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">  r io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(r io.Reader)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Reader&#123;r: r&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> rs, ok := r.r.(io.Seeker); ok &#123;</span><br><span class="line">    <span class="comment">// Use more efficient rs.Seek.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Use less efficient r.r.Read.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(在 <a href="https://github.com/golang/go/blob/60f78765022a59725121d3b800268adffe78bde3/src/archive/tar/reader.go#L837" target="_blank" rel="noopener">reader.go</a> 查看具体的代码。)</p>
<p>当你遇到想要向现有接口添加新方法的情况时，就可以使用这个策略了。首先为新方法创建一个新接口，或者用新方法标识一个现有的接口。接下来，就可以修改需要支持它的函数，为新接口做类型检查，并添加使用它的代码。</p>
<p>这种策略仅仅在旧接口没有新方法时也能工作的情况能使用，这样会限制模块在未来的扩展性。</p>
<p>如果可能的话，最好是完全避免这类问题。比如，在设计和构造函数时，最好是返回具体的类型。与接口不同，使用具体类型可以让你在以后添加新方法二不会影响到用户。这种方式让你的模块在以后扩展起来更容易。</p>
<p>提示：如果你确实需要使用一个接口，但又不想让用户来实现它，你可以添加一个未导出的方法。这可以防止在包外定义的类型在不嵌入的情况下满足接口的要求，从而可以让你在以后添加方法而不会破坏用户的实现。比如，看 <a href="https://github.com/golang/go/blob/83b181c68bf332ac7948f145f33d128377a09c42/src/testing/testing.go#L564-L567" target="_blank" rel="noopener">testing.TB's private() function</a>。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TB <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Errorf(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// A private method to prevent users implementing the</span></span><br><span class="line">    <span class="comment">// interface and so future additions to it will not</span></span><br><span class="line">    <span class="comment">// violate Go 1 compatibility.</span></span><br><span class="line">    private()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Jonathan Amsterdam 的<strong>检测不兼容 API 变化</strong>演讲（<a href="https://www.youtube.com/watch?v=JhdL5AkH-AQ" target="_blank" rel="noopener">视频</a>、<a href="https://github.com/gophercon/2019-talks/blob/master/JonathanAmsterdam-DetectingIncompatibleAPIChanges/slides.pdf" target="_blank" rel="noopener">幻灯片</a>）中也详细探讨了这个主题。</p>
<h2>添加配置方法</h2>
<p>到现在为止，我们已经讨论了什么是破坏性改变，就是在改变类型或者函数时会让用户的代码编译不通过。然而，即使用的代码可以编译通过，行为的变化也会对用户的代码造成破坏性改变。比如，许多用户期望 json.Decoder 会忽略 JSON 中不属于参数结构的字段。在这种情况下，当 Go 团队想要返回一个错误时，他们必须小心。如果没有一个可选的机制，这样做意味着许多依赖这些方法的用户可能会开始接收他们以前没有接收到的错误。</p>
<p>因此，他们并没有去改变所有用户的习惯，而是在 Decoder 结构体中添加了一个配吹方法：Decoder.DisallowUnknownFields。调用这个方法，用户就可以使用新的行为，否则就继续保持老的行为。</p>
<h2>维护结构体的兼容性</h2>
<p>我们在上面看到，对函数签名的任何更改都是破坏性更改。有了结构体，情况就好多了。如果你有一个导出的结构类型，添加一个字段或删除一个未导出的字段，也不会破坏兼容性。在添加字段时，确保它的零值是有意义的，并保留旧的行为，这样即使没有设置这个字段的现有代码也能继续工作。</p>
<p>回想一下上面的例子，net 包的作者在 Go1.11 中添加了 ListenConfig，因为他们认为可能会添加更多的参数，事实证明他们是对的。在 Go1.13 中，添加了 KeepAlive 参数，这个参数可以禁用 KeepAlive 或修改其周期。缺省值 0 将会保留启用 keep-alive 的默认周期的原始行为。</p>
<p>还有一种需要注意的情况，新字段可能会破坏用户代码。如果一个结构中的所有字段类型都是可比较的——这些类型的值可以用 == 和 != 进行比较，并用作map 中的 key —— 那么整个结构类型也是可比较的。在这种情况下，添加一个不可比较类型的新字段将使整个结构类型变得不可比较，这样比较该结构类型值的代码就会出错。</p>
<p>为了保持结构的可比性，不要向结构中添加不可比较性字段。你可以为此编写一个测试，或者使用即将发布的 gorelease 工具来捕获这个问题。</p>
<p>如果从一开始就不想让结构体进行比较，请确保该结构有一个不可比较的字段。它可能已经有了一个非切片、map 或函数类型是可比较的。但如果没有，可以这样添加一个:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">        _ [<span class="number">0</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="title">X</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">        <span class="title">Y</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>func() 类型不可比较，并且长度为零的数组不占用空间。我们可以定义一个类型来阐明我们的意图:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> doNotCompare [<span class="number">0</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">Point</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">        doNotCompare</span><br><span class="line">        X <span class="keyword">int</span></span><br><span class="line">        Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你应该在你的结构中使用doNotCompare吗？如果你已经定义了要作为指针使用的结构体——也就是说，它有指针方法，可能还有一个返回指针的 NewXXX 构造函数，那么添加一个doNotCompare字段可能是多余的。指针类型的用户明白，该类型的每个值都是不同的：如果他们想比较两个值，就应该比较指针。</p>
<p>如果你想定义一个直接作为值使用的结构体，就像我们的例子，那么你通常希望它具有可比性。在不常见的情况下，你有一个值结构，但不想让它有可比性，就可以添加一个 doNotCompare 字段，这样可以自由地更改结构，而影响比较性。缺点这类型不能用作 map 的 key。</p>
<h2>小结</h2>
<p>在从头开始规划 API 时，请仔细考虑 API 对于未来新更改的可扩展性。当你确实需要添加新特性时，请记住这条规则：添加、不更改或删除，记住异常、接口、函数参数和返回值不能以向后兼容的方式添加。</p>
<p>如果你需要大幅度改变一个API，或者随着更多特性的添加，一个 API 开始被使用的越来越少，那么可能是时候推出一个新的主版本了。但在大多数情况下，进行向后兼容的更改很容易，并且可以避免给用户造成痛苦。</p>
<p>译 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>关于零知识证明</title>
    <url>/2022/11/29/%E5%85%B3%E4%BA%8E%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<ol>
<li></li>
</ol>
<p>理解零知识证明其实不难，假设现在你有两个球，一个红色，一个绿色，这两个球除了颜色不同之外没有其他任何的区别。</p>
<p>然后你跟你的红色色盲的朋友说这两个球的颜色是不同的，但是他不信，现在你需要用一种方式来证明这两个球的颜色不一样，但是又不能直接告诉他，即使直接告诉他，他也不信。所以有一个这样的方式来解决这个问题。</p>
<p>首先色盲朋友将两个球都放到背后，可以随意调换球的位置，然后随机拿出一个球，然后说跟上次拿出来的颜色是不是一致（第一次除外）。</p>
<p>假如这两个球是完全一样的，那么你第二次能猜中的比例就是 50%，第三次是 25 %，在这样进行了 20 次之后，你能全部猜中的概率就已经很低了，这个时候，色盲朋友就可以相信这两个球的颜色是真的不同不同了，而且最后他也分辨不出来到底哪个球是红色哪个球是绿色。</p>
<p>上面的实验虽然简单，但是却满足了零知识证明的三大要素：</p>
<ul>
<li>完备性（Completeness）：证明者能够向验证者证明命题是真的，上面这个例子中，你是证明者，色盲朋友是验证者</li>
<li>可靠性（Soundness）：如果命题是假的，那么验证者就无法证明命题是真的，在上面的例子中，如果两个球的颜色一样，只要进行足够的实验次数，那么你肯定会出错</li>
<li>零知识（Zero-knowledge）：在实验的过程，验证者不会获取到任何额外的知识，色盲朋友最后还是无法分辨两个球的颜色</li>
</ul>
<p>所以上面的实验就是一次零知识证明，这个证明过程是一个数学过程，需要额外的计算量，而且为了保证最后的结果是可信的，计算量还不能太少。为了保证性能不受影响，计算量也不能太大，所以零知识证明的结果是性能和可靠性的平衡。</p>
<p>从这个角度上来说，零知识证明的结果在概率上并不是 100% 可信的。</p>
<ol start="2">
<li></li>
</ol>
<p>上面这整个过程其实是一个交互的过程，证明者和交互者需要持续的交换信息，在正式的使用环境中，这种方式效率太低。</p>
<p>而非交互的过程其实就是相当于把这个交互的过程缩短，因为频繁交互带来的通信成本很高，非交互零知识就是指信息只交换一次。</p>
<p>那么怎么理解这个非交互过程呢，还看上面的例子，在上面的例子中，色盲朋友一口气列出了很多个球，组合，然后你每次看到之后，把答案写下来，但是并不是发出去，而是等到结束后，再以一次性把结果传递给色盲朋友。</p>
<p>实际的过程会比这个复杂一点，要经过很多数学的计算。大体的原理就是证明者和验证者约定一种规则，验证者按照这种规则来提供数据，然后验证者则验证这些数据是否符合约定的规则，因为如果证明者提供的数据不正确，那么计算出来的结果就会对不上。</p>
<p>通过这种非交互式的验证，那么验证者和证明者可以不用一直在线，现在能实际大规模使用的零知识证明基本都是非交互式的。</p>
<p>ZK-SNARK 和 ZK-STARK 就是两种使用最广泛的非交互式零知识证明算法。</p>
<ol start="3">
<li></li>
</ol>
<p>这两个算法之间最大的区别在于 ZK-SNARK 依赖椭圆曲线算法，需要设置一个初始的密钥，而 ZK-STARK 不依赖椭圆曲线算法，只需要依赖哈希算法，也就不需要那个初始的密钥。</p>
<p>对不同大小的数据输入，ZK-STARK 产出的结果变化不大，但是在小数据的结果上大于 ZK-SNARK 。</p>
<p>另外 ZK-SNARK 验证结果耗费的时间随着数据的增长而线性增长，ZK-STARK 验证所需要的时间基本和数据的大小没有关系，处理大数据集更有效率，开销基本不变。</p>
<p>所以在处理小数据集的时候，ZK-SNARK 效率更高，处理大数据集的时候，ZK-STARK 效率更高。</p>
<ol start="4">
<li></li>
</ol>
<p>目前 ZK 方案最典型的领域是匿名支付，区块链本身无法真正保证隐私，通过一些追踪手段，很容易将地址和现实生活中的人联系起来。ZK 已经在 ZCash、Tornado Cash 等项目中使用，在这些项目中，通过 ZK 将一些关键的信息进行隐藏，从而不泄露交易双方的信息。特别是 Tornado Cash，因为太火爆，成为洗钱圣地，甚至被拉入了黑名单。</p>
<p>在目前以太坊的各种扩容方案中，ZK 是一个很重要的方向，ZK-rollup 是目前最被看到的方案。在这个方案中，链下的交易数据被 ZK 打包好上传到以太坊上，数据可以被立马验证，效率比其他的方案要更有效率，目前被作为主要的扩容方案在发展。</p>
<p>在其他场景，比如身份认证，也可以通过 ZK 技术来保护隐私信息，这样既可以证明身份，又不用泄漏隐私信息。</p>
<ol start="4">
<li></li>
</ol>
<p>当然 ZK 算法并不完美，也有缺点：</p>
<ul>
<li>ZK 算法可以使用硬件来加速，而生成零知识证明的硬件很贵，最后这些成本都会被平摊到用户头上</li>
<li>验证证明的开销（ZK-rollup 中的每次 ZK-SNARK 需要支付 50 万 gas，ZK-STARK 则更高）</li>
<li>信任假设（在 ZK-SNARK 中， CRS 是一次性生成的，然后会重复使用，如果 CRS 泄漏，会对安全性造成很大的威胁，ZK-STARKS 则没有这样的问题）</li>
<li>量子计算的威胁（对 ZK-SNARK 有威胁，ZK-STARK 目前来看对这个攻击是免疫的）</li>
</ul>
<p>参考链接</p>
<p>[1] <a href="https://ethereum.org/en/zero-knowledge-proofs/" target="_blank" rel="noopener">https://ethereum.org/en/zero-knowledge-proofs/</a></p>
<p>[2] <a href="https://en.wikipedia.org/wiki/Zero-knowledge_proof" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Zero-knowledge_proof</a></p>
<p>[3] <a href="https://dl.acm.org/doi/pdf/10.1145/62212.62222" target="_blank" rel="noopener">https://dl.acm.org/doi/pdf/10.1145/62212.62222</a></p>
<p>[4] <a href="https://learnblockchain.cn/article/347" target="_blank" rel="noopener">https://learnblockchain.cn/article/347</a></p>
<p>[5] <a href="https://vitalik.ca/general/2017/11/09/starks_part_1.html" target="_blank" rel="noopener">https://vitalik.ca/general/2017/11/09/starks_part_1.html</a></p>
<p>[6] <a href="https://vitalik.ca/general/2017/11/22/starks_part_2.html" target="_blank" rel="noopener">https://vitalik.ca/general/2017/11/22/starks_part_2.html</a></p>
<p>[7] <a href="https://vitalik.ca/general/2018/07/21/starks_part_3.html" target="_blank" rel="noopener">https://vitalik.ca/general/2018/07/21/starks_part_3.html</a></p>
<p>[8] <a href="https://learnblockchain.cn/article/269" target="_blank" rel="noopener">https://learnblockchain.cn/article/269</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链是什么</title>
    <url>/2021/11/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>区块链是什么？很多人为之迷惑，因为从来没有一个技术的争议性有这么大，集财富、骗局、新科技等等话题于一身。</p>
<p>但是实际上，这是一种过度包装。之前看到过一个段子，用来形容这个情况再适合不过了：”他们说区块链不会骗人，但是他们会拿区块链骗人“。很多人也是因为不懂区块链所以被骗的。但区块链其实根本就不复杂，无论是从技术上还是概念上。</p>
<p>这篇文章会从科普的角度来说一下区块链运作的细节。主要以比特币网络为主，后面也会聊一下联盟链的一些情况。区块链中的新名词比较多，我会尽可能的说的通俗易懂一点。</p>
<h2>1. <strong>区块链是什么</strong></h2>
<p>区块链脱胎于比特币，用来存储比特币中产生的交易数据，区块链有两个特点：</p>
<ul>
<li>数据写入到区块之后就<strong>很难</strong>（注意这里，是很难，不是不能）被篡改，通常被称之为不可篡改</li>
<li>去中心化，没有人可以真正掌控整个系统</li>
</ul>
<h3>1.1 区块链的结构</h3>
<p>区块链技术本身并不复杂，学过编程的人都对链表这个数据结构很清楚，某种程度上区块链其实就是这样的一个链表。</p>
<p><img src="0.jpeg" alt=""></p>
<p>区块链就是由这样的诸多区块构成的，这里需要注意的是，<strong>箭头的方向是不能反的</strong>，都是新产生的区块指向前一个区块，然后每个区块中都会存储一些数据。</p>
<p>那这些区块是怎么连接起来的呢？</p>
<p>这就要说到区块链中很重要的一个部分，<strong>哈希函数</strong>。这是数学或者计算机中的一个概念。它的特点是，它可以对一段数据做特定的操作，输出一段固定长度的字符串，这个字符串称之为哈希值，但是你无法（很难）根据输出推算出来输入是什么，但是你可以很快的根据输入来验证哈希值是否正确。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h = hash(<span class="string">"I got 100 bitcoins"</span>) <span class="comment">//16df768dash</span></span><br></pre></td></tr></table></figure></p>
<p>而且对于哈希函数来说，只要传入的数据有一点不一样，那么产生的哈希值就会天差地别。</p>
<p>对于哈希函数，你只需要知道它可以干什么就可以了。在下面讲挖矿的时候还会用到哈希函数。</p>
<p>区块就是利用这个特点，算出它前面那个区块的哈希值，并把这个哈希值放到自己的区块中。也就是是说每一个区块都记录了自己前一个区块的哈希值。并通过这种方式连接起来。如果这个链中任何一个区块的数据被篡改，这个区块的哈希值就会产生变化，那么这个区块之后的其他区块就无法连上这个区块。</p>
<p>这是真的牵一发而动全身，这也是区块链不可篡改这个特性在技术上的实现。</p>
<h3>1.2 区块链网络</h3>
<p><strong>但我们日常所讨论的区块链实际是区块链网络</strong>。</p>
<p>区块链网络是去中心化的，也就是常说的分布式。比特币网络可以说是去中心化最彻底的软件系统。这个网络是完全放开的，任何人都可以下载一个比特币软件接入到网络中，成为网络中的一个节点。</p>
<p>在区块链网络中，每个网络节点都会维护上面的那个链状的结构。节点之间会相互同步数据，最终每个节点所维护的数据是一模一样的。</p>
<p><img src="1.jpeg" alt=""></p>
<p>任何一个人都可以接入到比特币网络中，把所有的区块链数据同步到自己本地。换句话说，比特币网络对所有人都是公开透明的。</p>
<p><img src="3.png" alt=""></p>
<p>在接入区块网络的时候，我们需要生成自己的账户。<strong>账户实际上是通过非对称加密生成的一堆公私钥对</strong>。其中，公钥是可以对外暴露的，<strong>公钥再做一些转换就成了地址</strong>。这个地址就是我们通常所说的钱包地址。</p>
<p>在区块链中，钱包这个词出现的频率也非常的高。但这个钱包与我们通常所认知的钱包是完全不同的。不同于支付宝或者任何一款银行 APP。</p>
<p>钱包实际上就是由一个地址及一个公私钥组成，掌握了私钥就掌握了这个钱包。</p>
<h3>1.3 区块是怎么生成的</h3>
<p>区块中包含的都是交易。交易在比特币网络中很简单，其实就是转账，你把你的比特币转移到任意一个地址中就是一笔交易。</p>
<p>但每个区块中能够包含的区块是有限的。所以一次性可以打包的交易数量也是有限的。这个时候就要让矿工来决定把哪些交易打包进区块了。刚开始了解区块链的人一定听说过矿工。这个词很容易让人混淆，但又很贴切。</p>
<p>矿工在这里就会开始争夺<strong>记账权</strong>。记账权就是打包下一个区块的权利。如果获得了记账权，就可以获得这个区块生成后的比特币奖励。这也是促使大量矿工加入比特币网络的原因。争夺这个记账权的过程也被称之为共识过程。</p>
<p>那么怎么争夺记账权呢？其实就是来做题。谁先找到答案，记账权就给谁。</p>
<p>在上面说到的哈希函数是起到作用了。这道题是这样的，找出一个字符串，使它的哈希值是 0x00000......。</p>
<p>这里 0 的个数是可以调整的，比特币网络中的<strong>难度调整</strong>其实就是调整 0 的个数。在上面我们说过根据哈希值去倒推原始的数据是非常困难的，基本可以等同于无法完成。所以唯一的方式就是<strong>暴力破解</strong>。</p>
<p>就是去尝试各种不同的字符串，直到找到一个符合条件的答案为止。找到这个答案之后，这个节点就会把结果同步给其他的节点，根据哈希函数的特性，其他的节点很轻松就验证出来这个答案是不是正确的。这个过程也被称之为 PoW（Proof of Work） 共识机制，<strong>Pow 是一种分布式一致性性的共识算法</strong>。</p>
<p>在产生新区块的过程中，需要进行大量的运算，而且随着比特币越来越值钱，那么加入的矿工也就越来越多，就会导致这道题的难度会越来越大。需要的计算量也就越来越大。耗费的电量也越来越多，这也是比特币最受人诟病的地方。</p>
<p>分布式一致性的算法还有 Paxos/Raft/PBFT 等等，为什么一定要使用 PoW 这么消耗能源的算法呢？因为 Paxos/ Raft 等算法对环境有着严格的要求：</p>
<ul>
<li>首先它需要 Leader 选举，这在区块链网络中是不可能的</li>
<li>而且它会假设所有的节点都是可信的，而实际上，在开放的网络中，没有节点是可信的</li>
<li>区块链网络中节点数量非常多，这些算法无法处理这么大的网络</li>
</ul>
<p>公链上的区块链网络就是这么形成的。在一个无信任的网络环境中，通过哈希和 PoW 共识算法就构建起来一条可信的区块链。</p>
<h2>2. 联盟链有什么不同</h2>
<p>还有除了比特币、以太坊这些公链之外，也还有一种联盟链的网络，这种网络是有准入门槛的，国内现在做的所有区块链应用都是基于联盟链的。</p>
<p>联盟链与公链最大的不同在于它的网络是准入制的，得到许可之后才能加入，所以联盟链中所有的节点都是可信的，而且节点的数量也会控制在一定范围内，外部的节点无法随意加入。</p>
<p><img src="4.png" alt=""></p>
<p>在这样的网络环境中，自然不需要 PoW 这种算法，使用常规的分布式一致性算法即可，甚至有的联盟直接不需要共识算法。</p>
<p>联盟链中暂时不能出现币，这样其实就把区块链网络中最重要的部分砍掉了。公链之所以能够运转起来，关键是内部的形成了一个完整的经济系统，什么时候联盟链可以把这部分补足了。那么联盟链的春天就到了。</p>
<h2>3. <strong>区块链技术有价值吗</strong></h2>
<p>比特币火起来之后，有人就从中提取出来了一个部件，取名为区块链。然后又有人拿着这个，然后对所有人说，这，就是未来。但实际上，区块链只是一种技术，而且这种技术本身没有任何革命性的地方，区块链所用到的技术在很早之前就有了。它将现有的一些技术组合在一起，得到了一个新的概念。</p>
<p>拿比特币来说，区块链只是它用来存储交易的数据结构。重要的是比特币网络中汇集了诸多人的共识，这才是比特币真正的价值，就是说比特币的这些数据本身没有价值，是那些承认这些数据有价值的人早就了比特币的价值。</p>
<p>区块链技术本身没有价值，为什么那么多学习、抄袭比特币的各种币都无法追赶比特币，这是因为比特币中最有价值的不是区块链，而是共识。</p>
<p>搭建一个区块链网络的成本低的可怜。用自己的笔记本电脑，一小时就可以搭建一个区块链网络，对于做区块链来说，用的什么链根本不重要，重要的是这条链有多少人承认。</p>
<p>但这并不是说区块链技术一文不值。区块链的不（几乎）可篡改性让这种结构天然就适合作为价值存储的载体。我们当前的移动互联网让信息传递的成本几乎为零。但是价值的传输还是有很大的问题。而区块链有望来解决这个问题。</p>
<h2>4. 小结</h2>
<p>区块链技术本身是中立的，各种骗局给区块链带来了坏名声。但就像所有的新生事物一样，在刚开始总是坎坷的。区块链技术目前也还在不断的发展中，也有不少场景的问题有望使用区块链来解决。在曲折中不断上升，区块链这条路还有很长的路要走。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>发布 Go Modules</title>
    <url>/2021/01/31/%E5%8F%91%E5%B8%83-Go-Modules/</url>
    <content><![CDATA[<p>每当完成一个 Go Modules 之后，如果想让更多的人使用你的代码，就需要把这个模块发布出去，这篇文章说明了如何发布一个新的模块。</p>
<p>原文地址：<a href="https://blog.golang.org/publishing-go-modules" target="_blank" rel="noopener">https://blog.golang.org/publishing-go-modules</a></p>
<hr>
<h2>简介</h2>
<p>这个系列的文章总共有五篇，这是第三篇：</p>
<ul>
<li><a href="https://rayjun.cn/2021/01/17/%E4%BD%BF%E7%94%A8Go-modules/" target="_blank" rel="noopener">使用 Go Modules</a></li>
<li><a href="https://rayjun.cn/2021/01/23/%E8%BF%81%E7%A7%BB%E5%88%B0Go-modules/" target="_blank" rel="noopener">迁移到 Go Modules</a></li>
<li><strong>发布 Go Modules</strong></li>
<li>Go Modules：V2 及后续版本</li>
<li>保持 Modules 的兼容性</li>
</ul>
<p>这篇文章讨论如何编写和发布模块，让其他模块可以使用它们。</p>
<p>请注意：这篇文章只覆盖到 v1 版本的开发。如果你对 v2 版本感兴趣，请看 <a href="https://blog.golang.org/v2-go-modules" target="_blank" rel="noopener">Go Modules: v2 及后续版本</a>。</p>
<p>这篇文章中使用 git 版本管理为例子。Mercurial、Bazaar 等其他的版本管理工具也是支持的。</p>
<h2>创建项目</h2>
<p>在这篇文章中，你需要用一个已经存在的项目作为例子。在这里，继续使用<a href="https://rayjun.cn/2021/01/17/%E4%BD%BF%E7%94%A8Go-modules/" target="_blank" rel="noopener">第一篇文章</a>的代码来演示：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat go.mod</span><br><span class="line">module example.com/hello</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require rsc.io/quote/v3 v3.1.0</span><br><span class="line"></span><br><span class="line">$ cat go.sum</span><br><span class="line">golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8=</span><br><span class="line">golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=</span><br><span class="line">rsc.io/quote/v3 v3.1.0 h1:9JKUTTIUgS6kzR9mK1YuGKv6Nl+DijDNIc0ghT58FaY=</span><br><span class="line">rsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=</span><br><span class="line">rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=</span><br><span class="line">rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=</span><br><span class="line"></span><br><span class="line">$ cat hello.go</span><br><span class="line">package hello</span><br><span class="line"></span><br><span class="line">import <span class="string">"rsc.io/quote/v3"</span></span><br><span class="line"></span><br><span class="line">func Hello() string &#123;</span><br><span class="line">    <span class="built_in">return</span> quote.HelloV3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Proverb() string &#123;</span><br><span class="line">    <span class="built_in">return</span> quote.Concurrency()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ cat hello_test.go</span><br><span class="line">package hello</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestHello(t *testing.T) &#123;</span><br><span class="line">    want := <span class="string">"Hello, world."</span></span><br><span class="line">    <span class="keyword">if</span> got := Hello(); got != want &#123;</span><br><span class="line">        t.Errorf(<span class="string">"Hello() = %q, want %q"</span>, got, want)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestProverb(t *testing.T) &#123;</span><br><span class="line">    want := <span class="string">"Concurrency is not parallelism."</span></span><br><span class="line">    <span class="keyword">if</span> got := Proverb(); got != want &#123;</span><br><span class="line">        t.Errorf(<span class="string">"Proverb() = %q, want %q"</span>, got, want)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>接下来，创建一个新的 git 仓库并添加一个初始的提交。如果你要发布自己的项目，记得添加一个 LICENSE 文件。切换到包含 go.mod 文件的目录，创建一个仓库：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add LICENSE go.mod go.sum hello.go hello_test.go</span><br><span class="line">$ git commit -m <span class="string">"hello: initial commit"</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<h2>语义化版本和模块</h2>
<p>每模块都在 go.mod 文件中有一个<a href="https://semver.org/" target="_blank" rel="noopener">语义版本</a>，这是用于构建模块的依赖的最小版本。</p>
<p>一个语义版本号的格式都是 vMAJOR.MINOR.PATCH：</p>
<ul>
<li>当对模块的公共 API 进行向后不兼容的更改时，才增加主版本。只有在必要的时候才这样做。</li>
<li>当对API进行向后兼容更改时，如更改依赖项或添加新函数、方法、结构字段或类型，则增加次版本。</li>
<li>在做了不影响模块的公共 API 或依赖项（如修复bug）的小更改后增加补丁版本。</li>
</ul>
<p>你可以通过附加连字符和点分隔的标识符来指定预发布版本（例如，v1.0.1-alpha或v2.2.2-beta.2）。go 命令优先使用普通版本而不是预发布版本，所以如果你的模块已经存在普通版本，用户如果要使用预发布版本，必须明确指定版本号（例如，去获取example.com/hello@v1.0.1-alpha）。</p>
<p>v0 主版本和预发布版本不保证向后兼容。它们允许你对 API 进行优化，不需要向用户做出稳定版本承诺。然而，v1 主版本和其他版本需要在该主版本内向后兼容。</p>
<p>在 go.mod 中引用的版本可能是在存储库中标记的显式发布（例如，v1.5.2），也可能是基于特定提交的 <a href="https://golang.org/cmd/go/#hdr-Pseudo_versions" target="_blank" rel="noopener">pseudo-version</a>（例如，v0.0.0-20170915032832-14c0d48ead0c）。pseudo-version 是一种特殊类型的预发布版本。当用户需要依赖一个没有发布任何语义版本标记的项目，或者针对一个还没有打标记的提交进行开发时，伪版本是有用的。但用户不应该假定 pseudo-version 提供了一个稳定的或经过良好测试的 API。用显式的版本号标记模块，向用户表明特定的版本已经经过了充分的测试，可以使用了。</p>
<p>一旦你开始用版本号标记你的仓库，在后续模块的开发中，就应该继续标记新版本。当用户请求模块的新版本（使用 go get -u 或 go get example.com/hello）时，go命令将选择可用的最大语义版本，即使该版本已经存在好几年了，并且主分支后面有很多变化。继续标记新版本将使你的用户能够获得持续的改进。</p>
<p>不要从你的仓库中删除版本标签。如果你发现了一个版本的 bug 或安全问题，那么就发布一个新版本。如果人们依赖于你已经删除的版本，那么他们的构建可能会失败。类似地，一旦你发布了一个版本，不要更改或覆盖它。<a href="https://blog.golang.org/module-mirror-launch" target="_blank" rel="noopener">模块镜像和校验和数据库</a>存储模块的版本和签名加密散列，以确保给定版本的构建在一段时间内是不变的。</p>
<h2>v0：初始，不稳定版本</h2>
<p>让我们用 v0 语义版本标记这个模块。v0 版本不做任何稳定性保证，所以几乎所有的项目都应该从v0 开始，以完善公共 API。</p>
<p>标记一个新版本有如下步骤：</p>
<ol>
<li>运行 go mod tidy，删除可能不再使用的依赖项</li>
<li>运行 go test ./..，最后再保证所有的功能都是正常的</li>
<li>使用 git tag 命令标记一个新的版本</li>
<li>推送标记到远程仓库</li>
</ol>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">$ go <span class="built_in">test</span> ./...</span><br><span class="line">ok      example.com/hello       0.015s</span><br><span class="line">$ git add go.mod go.sum hello.go hello_test.go</span><br><span class="line">$ git commit -m <span class="string">"hello: changes for v0.1.0"</span></span><br><span class="line">$ git tag v0.1.0</span><br><span class="line">$ git push origin v0.1.0</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>现在其他项目可以依赖于 example.com/hello 的 v0.1.0 版本。对于你自己的模块，可以运行 go list -m example.com/hello@v0.1.0 来确认最新可用版本（该示例模块不存在，因此没有可用的版本）。如果你没有立即看到最新版本，并且正在使用 Go 模块代理（自 Go 1.13 以来的默认设置），可以在几分钟内再次尝试，给代理一点时间来加载新版本。</p>
<p>如果向公共 API 添加内容，对 v0 版本的模块进行破坏性更改，或者升级某个依赖项的次版本，则为下一个发行版增加次要版本。例如，v0.1.0 之后的下一个版本将是 v0.2.0。</p>
<p>如果修复了现有版本中的bug，则增加补丁版本。例如，v0.1.0之后的下一个版本将是v0.1.1。</p>
<h2>v1：第一个稳定版本</h2>
<p>一旦你确定你的模块 API 已经稳定了，你就可以发布 v1.0.0 了。v1 主版本告诉用户，不会对模块的API 进行不兼容的更改。他们可以升级到新的 v1 次要版本和补丁版本，他们的代码应该不会出错。函数和方法签名不会改变，导出的类型不会被删除等等。如果 API 发生了更改，它们将向后兼容(例如，向结构添加新字段)，并将包含在新的次版本中。如果修复了错误（例如，安全修复），它们将包含在补丁版本中（或者作为次版本的一部分）。</p>
<p>有时，保持向后兼容性会导致 API 不优雅。但没关系，一个不完美的 API 总比破坏用户现有的代码要好。</p>
<p>标准库的 strings 包就是一个以 API 一致性为代价来维护向后兼容性的典型例子。</p>
<ul>
<li>Split 函数将字符串分割成由分隔符分隔的子字符串，并返回一个由这些分隔符分割的子字符串 slice</li>
<li>SplitN 函数可以用来控制要返回的子字符串的数量</li>
</ul>
<p>但是，Replace 函数从一开始就要确定需要替换的字符串数量（与 Split 函数不同）。</p>
<p>因为有 Split 函数和 SplitN 函数，你会期望也有 Replace 函数和 ReplaceN 函数。我们无法在不做破坏性修改的情况下修改 Replace 函数。在 Go 1.12中，我们添加了一个新函数，ReplaceAll。因为 Split 和 Replace 的行为不同，结果产生的 API 有点奇怪，但这种不一致性比破坏性更改要好。</p>
<p>假设你现在对 example.com/hello 的 API 很满意，并且希望发布 v1 作为第一个稳定版本。</p>
<p>给 v1 加标签的过程和给 v0 版本加标签的过程是一样的：运行go mod tidy 和 go test ./.. ，标记版本，并将标记推送到远程仓库：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">$ go <span class="built_in">test</span> ./...</span><br><span class="line">ok      example.com/hello       0.015s</span><br><span class="line">$ git add go.mod go.sum hello.go hello_test.go</span><br><span class="line">$ git commit -m <span class="string">"hello: changes for v1.0.0"</span></span><br><span class="line">$ git tag v1.0.0</span><br><span class="line">$ git push origin v1.0.0</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>到现在， example.com/hello 的 v1 版本的 API 已经文档了。这就向每个人传达了我们的 API 是稳定的，他们应该会用的很舒服。</p>
<h2>结论</h2>
<p>本文介绍了用语义版本标记模块的过程以及何时发布 v1 版本。下面的一篇文章将涵盖如何维护和发布 v2 及后续版本的模块。</p>
<p>请向我们发送<a href="https://github.com/golang/go/issues/new" target="_blank" rel="noopener">bug 报告</a>和<a href="https://github.com/golang/go/wiki/ExperienceReports" target="_blank" rel="noopener">体验报告</a>，帮助我们改善 Go 的依赖管理功能。</p>
<p>感谢你所有的反馈和帮助改进模块的建议。</p>
<hr>
<p>另外，腾讯云区块链方向在大量招人，包括前端、后端、架构师、产品等诸多岗位，如果感兴趣，请把简历投过来 <a href="mailto:rayjun0412@gmail.com">rayjun0412@gmail.com</a>。</p>
<p>译 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链中的链到底怎么形成的</title>
    <url>/2018/11/25/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E9%93%BE%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E5%BD%A2%E6%88%90%E7%9A%84/</url>
    <content><![CDATA[<p>对于区块链这个词大多数人应该听的耳朵都快起茧了，但是区块链这条链到底是什么呢？知道的人应该就不多了，这篇文章会深入的介绍区块链中的链到底是由什么构成的。这篇文章会以比特币的结构为例来分析区块链的结构。</p>
<p>区块链在运行的过程中，会不断的对用户提交的交易数据进行打包，只有那些被打包的数据才能真正算是区块链的一部分。而这个打包的过程，就是构建链的过程。就比特币来说，链的结构如图所示:</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_039d02cb-fd09-40cc-840b-5f783ed63517.png" alt=""></p>
<p>如果我们把图中的元素都搞清楚了，那么区块链的结构我们自然也就弄清楚了。首先区块链是一条链，这条链与数据结构的单向列表的结构非常类似。其中，这条链中的每一个节点都是一个区块的区块头，而每个区块头中都包含了三个非常重要的元素，一个是父区块的哈希值，第二个数据就是随机数题（难度、时间戳、nonce），最后一个就是 Merkle 树的树根。</p>
<p><strong>区块的连接方式</strong>：首先所有区块的连接方式都是通过在当前的区块头中记录父区块的哈希值，在区块链中，每个区块的哈希值是独一无二的，所以每个区块通过链接父区块的哈希来构建成一块链。</p>
<p><strong>区块的形成方式</strong>：不同的区块链形成区块的形式是不一样的，在比特币中，是通过计算一个随机数的值来进行的，计算的过程就是挖矿的过程。不同的区块链的有不同的实现，但是目标都是一样的，就是通过竞争来确定区块的归属权。</p>
<p><strong>区块的数据</strong>：在比特币中，一个区块的所有交易数据都是通过 Merkle 树来存储的。而在区块头中只存储 Merkle 树的树根，其他的数据都挂载这个树根上。</p>
<p>说到这里区块链的大体的结构差不多也可以弄清楚了。但是在实际的操作中是有很多问题存在的，比如区块链中由一个原则就是最长链原则，也就是说，只有最长的那条链上的区块才是有价值的，其他分叉的链都是无效的。那么这个问题在区块链中是如何解决的呢？</p>
<p>在区块链形成的过程中，一个区块是可以同时成为多个区块的父区块的，但是这只是暂时的。这种情况称之为分叉，然后区块的产生可以继续在这几条分叉的链上继续进行，当其中的一个区块率先得到六次确认后，那么其他所有的分叉就会失效。而其他区块链上的区块被称之为过时块，那些过时块的交易数据会被打散，然后等待被重新被打包进交易。这样就确保链能够不断的产生。</p>
<p>参考文献:</p>
<p>[1] 精通比特币</p>
<p>[2]比特币白皮书</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>写给 Go 初学者的指北</title>
    <url>/2021/02/27/%E5%86%99%E7%BB%99-Go-%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<p>在云计算时代，Go 是首选的编程语言，很多云的基础设施都是由  Go 来写的，更别说还有 Docker 和 kubernetes 这样的大杀器。对于后端工程师来说，这是最值得学习的技能。</p>
<p>这篇文章适合有一定基础的人，因为 Go 不适合编程初学者，对于编程的初学者还是建议从 Python 这种语言开始。</p>
<p>如果有一定的编程基础，再来学习 go 就会轻松不少，特别是有 C 语言基础，学习 Go 语言就会快很多。</p>
<p>Go 的语法很少，关键词也很简洁，但是对于长期写 Java 这种面向对象语言的人来说，需要抛弃 Java 中对于面向对象的固有想法，Go 在面向对象编程上给出了不一样的方案，没有类的概念，接口与 Java 中的也完全不一样。对于熟悉了 Java 的人来说，需要适应一段时间。</p>
<p>这篇文章不会涉及 Go 的具体教程，可以认为这是一份路径图，是我认为快速上手 Go 语言比较好的方式。</p>
<p>在看下面的内容之前，我会默认你已经掌握了一门开发语言，并且做过一些 Web 开发，熟悉 Git 的基本用法。</p>
<h2>1. 入门</h2>
<h3>1.1 基础入门</h3>
<p><strong>环境配置</strong></p>
<p>写代码之前，需要先安装 Go，Go 支持 Linux、macOS、Windows 等平台，可以在这里<a href="https://golang.org/dl/" target="_blank" rel="noopener">下载</a>安装包。</p>
<p>macOS 和 Windows 都提供了二进制安装包，Linux 则需要使用源码安装（在 Ubuntu，centos 这些发行版上也可以通过命令直接安装，但一般无法安装最新版本的 Go）。</p>
<p>在写代码之前，需要了解一下 Go 中的两个重要概念：GOROOT、GOPATH。GOROOT 比较好理解，就是 Go 的安装目录，可以理解为 Java 中的 JAVA_HOME。</p>
<p>GOPATH 通常会是 <code>~/go</code> 目录，在这个目录底下，通常有三个子目录：bin、pkg、src。bin 目录放的是可执行命令，pkg 目录下是编译时生成的一些中间件文件，src 则是存放源码的地方。</p>
<p>在 Go Modules（下面会说到）出现之前，Go 的依赖库和源码都需要放在 GOPATH 的 src，否则会出现找不到依赖的情况。Go Modules 出现之后，Go 的依赖管理问题基本解决了大半，就不用把源码放在 GOPATH 中，GOPATH 基本只用来存放依赖。</p>
<p><strong>基础语法</strong></p>
<p>Go 的官网提供了一个入门的教程 <a href="https://tour.golang.org/welcome/1" target="_blank" rel="noopener">A Tour of Go</a>，这里面基本覆盖到了 Go 的全部语法。可以直接在<a href="https://tour.golang.org/welcome/1" target="_blank" rel="noopener">网页</a>上访问，也可以把这个应用下载到本地：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get golang.org/x/tour</span><br></pre></td></tr></table></figure></p>
<p>然后就可以在命令行输入（需要配置 GOPATH ）:</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tour</span><br></pre></td></tr></table></figure></p>
<p>这样就可以打开一个本地的网页，加载的速度就会快很多，毕竟 Go 的官网在境外，直接访问的还是有点慢。</p>
<p>类似的教程还有一个 <a href="https://gobyexample.com/" target="_blank" rel="noopener">Go By Example</a>，这两个教程可以选择一个学习。</p>
<p>在把上面的练习做完了之后，就可以开始看 《Go 程序设计语言》，这本书可以说是 Go 最好的入门教材，虽然在内容上有一定的滞后，但整体上依然非常值得看。</p>
<p><strong>常用命令工具</strong></p>
<p>Go 命令（go cli command）非常重要，Go 整个开发的生命周期都需要使用这些工具。</p>
<p>Go 命令的基本用法如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go &lt;<span class="built_in">command</span>&gt; [arguments]</span><br></pre></td></tr></table></figure></p>
<p>在 初学阶段，下面几个命令必须掌握：</p>
<ul>
<li>go run：编译并运行 Go 程序</li>
<li>go build：编译并打包 Go 程序</li>
<li>go get：安装依赖</li>
<li>go test：运行测试</li>
</ul>
<p>在你开始使用 Go 开发程序之后，会频繁的用到上面的命令。如果要查看完整的命令，在命令行输入：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">help</span></span><br></pre></td></tr></table></figure></p>
<p>这些内容都看完之后，对于 go 基本语法和常用工具应该是比较熟练了，为了能够尽快使用上手 Go 的开发，接下来应该要学习一些常用的组件和框架。</p>
<h3>1.2 常用框架</h3>
<p>如果要开发一个应用，基本都会涉及到 Web API 的开发，会使用 MySQL 和 Redis。下面就介绍一下 Go 语言中如何快速上手这些框架。</p>
<p><strong>Web 框架</strong></p>
<p>Go 中常用的 web 框架 有很多，我推荐 <a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">gin</a>，这个框架简单易学，而且性能也很不错。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure></p>
<p>可以快速创建一个基于 http 的 API 服务：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">**<span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/ping"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")</span></span><br><span class="line">&#125;**</span><br></pre></td></tr></table></figure></p>
<p><strong>MySQL 框架</strong></p>
<p>在 Go 语言中，database/sql 包中定义了数据库操作的所有接口，但没有提供具体的实现。因为数据库的种类很多，这种只定义接口的屏蔽了数据库库的具体实现，便于我们更换和升级。</p>
<p>所以在连接数据库的时候，需要自行选择数据库驱动，推荐那些完全实现了 database/sql 的驱动，这样利于代码的后续维护和升级。</p>
<p>在这里以 MySQL 数据库为例，常用的驱动是  <a href="https://github.com/go-sql-driver" target="_blank" rel="noopener">go-sql-driver</a>/<a href="https://github.com/go-sql-driver/mysql" target="_blank" rel="noopener">mysql</a>，这个驱动完全实现了 database/sql 接口。</p>
<p>安装很方便：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get -u github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure></p>
<p>然后就可以使用 database/sql 的接口来操作数据库：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"database/sql"</span></span><br><span class="line">	_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"user:password@/dbname"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用原生的 MySQL 接口来写代码会产生很多的冗余代码，如果想让代码更加整洁一点，ORM 框架就是必须的了，那就需要学习一下 <a href="https://github.com/go-gorm/gorm" target="_blank" rel="noopener">gorm</a> 框架。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u gorm.io/gorm</span><br></pre></td></tr></table></figure></p>
<p><strong>Redis 框架</strong></p>
<p>在 Go 中使用 Redis 就需要使用 <a href="https://github.com/go-redis/redis" target="_blank" rel="noopener">go-redis/redis</a> 组件了。安装同样很简单：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/<span class="keyword">go</span>-redis/redis/v8</span><br></pre></td></tr></table></figure></p>
<p>除了这个组件之外，另一个 <a href="https://github.com/gomodule/redigo" target="_blank" rel="noopener">redigo</a> 使用的人也挺多的，可以自行探索一下。</p>
<p>学完这些，就可以使用 Go 来日常的开发了。</p>
<h2>2. 进阶</h2>
<p>在学完上面的基础之后，就需要学习一些进阶的内容。</p>
<p><strong>Go Modules</strong></p>
<p>在学习上面的框架时，可能你还是在 GOPATH 写代码。从 Go1.11 之后，Go 推出了 Go Modules 作为官方的依赖管理工具。</p>
<p>这个工具必须要学会，依赖管理一直是 Go 语言的短板，经历了多个非官方的解决方案之后，官方出手，推出了这个工具。学习的最好资料是 Go Blog 上的文章：<a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">https://blog.golang.org/using-go-modules</a>。如果英文的看起来不方便，这里有我翻译的<a href="https://rayjun.cn/2021/01/17/%E4%BD%BF%E7%94%A8Go-modules/" target="_blank" rel="noopener">版本</a>。</p>
<p>用了 Go Modules 之后，依赖管理会方便很多，也不用在 GOPATH 下开发了。</p>
<p><strong>Go Blog</strong></p>
<p>学习 Go 语言，Go blog 绝对是很重要的资料。官方推出的工具和特性，都会在第一时间有 blog 发布，看这些资料就能明白这些特性和工具的推出背景，就不会理解上的偏差。</p>
<p>比如你在 Go blog 中可以学习到<a href="https://blog.golang.org/declaration-syntax" target="_blank" rel="noopener">为什么 Go 的声明语法是这样的</a>。</p>
<p>Go 语言特性的更新都会在 Go blog 上说明，所以关注 Go blog 是跟进 Go 特性的好机会。毕竟现在 Go 语言还在不断的发展，会有很多特性在不断的更新。</p>
<p>E<strong>ffective go</strong></p>
<p>除了 Go blog 之外，Go 官方还有 <a href="https://golang.org/doc/effective_go#examples" target="_blank" rel="noopener">Effective go</a> 这份必看文档。</p>
<p>这份文档可以看做是 Go 的避坑指南，其中指出了 Go 语言容易出错的地方，可以帮助我们写出更干净，结构更优美的代码，文档不长，非常值得阅读。</p>
<h2>3. 其他资源</h2>
<p>如今学习编程，Github 是无法忽略的一个资源库。下面的这些 Github 仓库中有大量的资源可以学习。</p>
<ul>
<li>avelino/awesome-go：Go 的轮子库也在逐渐完善，Github 上的<a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">这个仓库</a>收集了 Go 的诸多库，要造轮子之前，记得先到这里来找一找</li>
<li>Alikhll/golang-developer-roadmap：这里还有一份 Go 开发者的<a href="https://github.com/Alikhll/golang-developer-roadmap" target="_blank" rel="noopener">路线图</a></li>
<li>talkgo/read：这个仓库有很多的 <a href="https://github.com/talkgo/read" target="_blank" rel="noopener">Go 的教程</a>，是中文版的，但里面的信息需要甄别一下，有些已经过时了</li>
<li>go/wiki：go 项目的<a href="https://github.com/golang/go/wiki" target="_blank" rel="noopener">wiki</a>，这里有很多技术文档，和大牛的博客，如果后续想深入研究 Go，可以从这里下手</li>
</ul>
<h2>4. 开发工具</h2>
<p>GoLand 也是由 JetBrains 出品的工具，这个工具需要付费。如果不想在这上面花钱，可以使用 VsCode，VsCode 上的插件很多，而且安装方便。</p>
<p>如果自己愿意折腾，可以试试 Vim，Vim 配合 <a href="https://github.com/fatih/vim-go" target="_blank" rel="noopener">vim-go</a> 插件，体验也还不错，就是安装的过程中可能会踩一些坑。</p>
<p>对于开发电脑的选择，我推荐 Mac，做开发，Mac 还是非常适合的，现在互联网公司的开发机标配就是 Mac，如果觉得新的 Mac 的价格比较贵，可以选择二手，或者官网的翻新机。如果不考虑便携性，可以选择 Mac mini，性价比贼高。</p>
<p>在最近发布的 Go1.16 版本中，Go 已经开始支持 ARM 的架构，所以即使是 M1 芯片的 Mac，也可以用来做 Go 的开发（但这个要谨慎，可能会有其他的坑）。</p>
<h2>5. 小结</h2>
<p>当你把上面的内容都过了一遍时，你应该和我现在一样，算是入门了 Go 语言，Go 是一门非常有潜力的语言，云计算时代的首选，非常值得学习。</p>
<p>后续我也会持续的更新这篇文章，以及更新这个系列的文档，如果有什么建议，欢迎告诉我。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>后端技能基础</title>
    <url>/2017/12/10/%E5%90%8E%E7%AB%AF%E6%8A%80%E8%83%BD%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3>后端攻城狮系列</h3>
<p>最近在工作之余，经常回想在之前这么多年的工作中到底沉淀了什么东西，于是出现了想将之前的一些经验总结起来的想法。
在之前的那些时间里，做的最多的工作就是后端的开发工作，虽然有些工作做的并不是很深，但是多少在技术上有了一个整体的了解，最近也是想在通过写这一系列的文章。将过去的经验总结下来，顺便梳理一下自己的思路，一个礼拜会写一篇。总体来说会按照以下的思路来写。</p>
<h4>文章的系列结构</h4>
<h5>计算机基础</h5>
<p>作为一个写代码的攻城狮，计算机的基础不会那是肯定不行的，所以首先会有一个系列的文章来介绍计算机的一些基础的知识。</p>
<ul>
<li><strong>编程语言</strong> 编程语言是攻城狮工作的基础，这里会推荐一个编程的资源及相关的学习方法</li>
<li><strong>操作系统</strong> 代码写了之后，总是需要一个平台来跑起来的，所以操作系统肯定是不能不知道的</li>
<li><strong>计算机网络</strong> 如果不能与其他的计算机互联，这些代码写了又有什么用</li>
<li><strong>算法</strong> 代码中的精髓所在，所以必须得要好好钻研了</li>
<li><strong>计算机组成</strong> 为了让写出的代码跑起来的效率更高一点，所以了解一些CPU的运行原理还是非常有必要的</li>
</ul>
<h5>软件工程</h5>
<p>一个人写一堆代码然后拿出去卖的时代已经结束了，所以让代码在软件工程这个领域里面工作也是非常有必要的事情了。</p>
<ul>
<li><strong>软件工程的基础概念</strong> 首先肯定是需要了解一些软件工程的前世今生的，要不然岂不是空中造阁楼。</li>
<li><strong>建模</strong> 为了清晰的将整个软件抽象出来，首先对系统进行建模是一件非常有必要的事情。</li>
<li><strong>文档</strong> 代码写出来之后，就不再是你一个人的事情了，如果让其他人理解并继续你的工作，那文档就是少不了的了</li>
<li><strong>协作</strong> 一般来说，代码开始写了之后，是需要与其他人进行协作的了，那么协作工具的熟练掌握肯定是免不了的了。</li>
</ul>
<h5>应用基础</h5>
<p>前面讲了那么多的基础，那么现在最重要的事情来了，我们掌握那些基础，最终是为了做出非常棒的软件，那么在真的去开发软件之前，我们还需要做什么。</p>
<ul>
<li><strong>架构</strong> 架构来源于实践，一个再小的软件也会有自己的结构，如何在架构上去快速的积累呢</li>
<li><strong>开发工具</strong> 这些都是吃饭的家伙，怎能不好好对待</li>
<li><strong>日志</strong> 如何做好日志的管理还真是一门技术活</li>
<li><strong>api设计</strong> 做出来的系统好不好使，靠的就是这个了</li>
<li><strong>产品设计</strong> 作为一只血统纯正的攻城狮需要懂产品吗，那必须的呀，要不你怎么和产品经理沟通</li>
<li><strong>项目管理</strong> 混久了总归是要做老大的，不懂一些管理的事情，怎么管理好小弟</li>
</ul>
<p>上面的这些就是这一系列的所有文章，在写的过程中，这些肯定是有修改的。也希望自己会在这一系列中完成成长。</p>
]]></content>
      <categories>
        <category>后端系列</category>
      </categories>
      <tags>
        <tag>backend</tag>
      </tags>
  </entry>
  <entry>
    <title>可伸缩系统架构简介</title>
    <url>/2020/08/23/%E5%8F%AF%E4%BC%B8%E7%BC%A9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>很少有计算机或者软件开发的教程来教学可伸缩系统的构建方式。相反，只有在工作中经历过一款快速成长的产品所带来的痛苦，或者与经历过这样痛苦的人一起工作，才能慢慢学习系统架构。</p>
<p>在这篇文章中，我尝试将我在雅虎和 Digg 工作时所积累的一些构建伸缩性架构的经验和教训记录下来。</p>
<p>我将文章示意图所用的颜色做如下约定：</p>
<ul>
<li>绿色：代表从外部客户端发来的外部请求（从浏览器发出的 HTTP 请求，等等）</li>
<li>蓝色：表示你的代码所运行的容器（Django 应用运行在 mod_wsgi，Python 脚本监听 RabbitMQ 等等）</li>
<li>红色：表示基础设施（MySQL，Redis，RabbitMQ 等等）</li>
</ul>
<h2>负载均衡</h2>
<p>一个理想的系统可以通过增加硬件来实现扩容。在这样一个系统中，如果在一台机器的基础上增加一台，那么系统的容量就增加了一倍。如果在三台机器的基础上增加一台，那么系统的容量就增加了 33%，这种特性称之为<strong>水平可伸缩性</strong>。</p>
<p>从坏的方面来考虑，一个理想的系统不会因为下线了一台服务器而使服务中断，当一台服务器下线时，整个系统减少的容量应该等于添加这台服务器时所提升的容量，这种特性称之为<strong>冗余</strong>。</p>
<p>系统的水平伸缩性和冗余通常都是通过<strong>负载均衡</strong>来获得。</p>
<blockquote>
<p>这篇文章不会讨论<strong>垂直可伸缩性</strong>，因为在大型系统中，一般不会使用这种方式。从长期来看，给系统扩容，添加机器会比在单台机器上添加资源更便宜，而且从另一方面来说，冗余和垂直可伸缩性也是冲突的。</p>
</blockquote>
<p><img src="1.png" alt=""></p>
<p>负载均衡是<strong>通过一些算法和系统当前的状态来将请求分散到多个资源的过程</strong>。算法一般有随机算法，round-robin 算法，根据服务器容量的加权随机算法等等，状态则是指可处理请求，无法响应，错误率升高等等。</p>
<p>负载需要在用户请求和 Web 服务器之间进行平衡，但也必须在每个阶段进行平衡，以实现系统的完全可伸缩性和冗余。一个中等大小的系统可以在三个层面平衡负载：</p>
<ul>
<li>用户到 Web 服务器</li>
<li>Web 服务器到内部平台层</li>
<li>内部平台层到数据库</li>
</ul>
<p>下面是实现负载均衡的一些方法：</p>
<h3>智能客户端</h3>
<p>为数据库（或者缓存，服务等等）客户端添加负载均衡的功能对开发者来说是一个比较有吸引力的解决方案。是因为这是一个最简单的方案吗？并不是。是因为这个方案的健壮性好吗？也不是。是因为这个方案容易被重用吗？更不是。</p>
<blockquote>
<p>开发人员倾向于智能客户端，因为他们是开发人员，所以他们习惯于编写软件来解决他们的问题，而客户端就是软件。</p>
</blockquote>
<p>那么到底什么是智能客户端，总的来说就是客户端中维护一个服务器地址的连接池并根据服务器的情况进行负载，检测下线的服务器并且避免给这些服务器发送请求，并且能够连接重新上线的服务器和新上线的服务器，为了实现这些功能则需要大量的配置。</p>
<p><strong>客户端中设置一个的主机列表，负载均衡将会使用这个主机列表来实现，好处是这对开发人员来说很简单，坏处是更新很麻烦。</strong></p>
<h3>硬件负载均衡器</h3>
<p>硬件负载均衡器价格最昂贵，但性能也是最好的（比如 Citrix NetScaler）。虽然它们可以解决大多数的问题，但价格也确实是非常的贵，并且需要做大量的配置。</p>
<p>因此，即使是拥有大量预算的大型公司，也会尽量避免使用专用硬件来满足所有系统的负载均衡需求，而是仅仅在用户请求进入到系统的时候使用，进入到系统网络之后，就会使用其他的机制（智能客户端或者下面将要讨论的混合方法）来实现负载均衡。</p>
<p><strong>一般大公司在用，性能很好，但是价格比较贵，而且使用也很复杂。</strong></p>
<h3>软件负载均衡器</h3>
<p>如果你既不想经历维护智能客户端的痛苦，也不想花那么多钱去买专门的硬件设备，还有其他的选择：软件负载均衡器。</p>
<p>HAProxy 就是一个很好的例子。它运行在本地机器上，并且和每一个需要进行负载均衡的服务绑定端口。举例来说，你现在的应用访问地址是 <code>localhost:9000</code>，数据库的读库访问地址是 <code>localhost:9001</code>， 数据库的写库访问地址是 <code>localhost:9002</code>。HAProxy 会对需要负载的机器进行监控检查，根据用户的配置来下线机器或者添加机器，也会对这个池子中所有可用的机器进行负载均衡。</p>
<blockquote>
<p>PS: 现在使用 Nginx 来做负载均衡也很好</p>
</blockquote>
<p>对于大多数系统，可以先从软件负载做起，如果有必要，再使用智能客户端和硬件负载均衡。</p>
<p><strong>这是最推荐的方式，软件可以用来做负载均衡，健康检测等功能</strong></p>
<h2>缓存</h2>
<p>负载均衡可以帮助你通过添加机器来帮助服务实现水平扩展，但是，缓存使你能够更好地利用现有的资源，并使无法实现的产品需求变得可行（提高了资源的访问速度）。</p>
<p>可以被缓存的内容有：提前计算好的结果（比如：前一天每个域名的访问数据），提前生成的索引（比如：基于用户的历史点击而生成的推荐故事），需要频繁访问数据（比如：使用 Memcache 而不是 PostgreSQL）。</p>
<p>实际上，在系统的早期阶段，缓存比负载均衡更加重要，提前制定好缓存策略可以在后续的开发中节省时间。它还可以确保你不会优化无法通过你的缓存机制复制的访问模式或在添加缓存后性能变得不重要的访问模式（我发现对许多经过高度优化的 Cassandra 应用程序干净地添加缓存是一个挑战，无法将数据库的缓存策略应用于你的访问模式，因为 Cassandra 与缓存之间的数据模型通常不一致）。</p>
<h3>应用缓存 VS 数据库缓存</h3>
<p>缓存的方式主要有两种：<strong>应用缓存</strong>和<strong>数据库缓存</strong>（大多数系统都重度依赖这两种缓存方式）。</p>
<p><img src="2.png" alt=""></p>
<p>应用程序缓存需要在代码中编写缓存的逻辑，通常会先检查缓存中有没有值，如果没有，就回去数据库中获取并写入到缓存中（如果你使用的是<code>最近最少使用缓存算法</code>，那么值就很容易获取到），典型的代码如下（这是一个 Read-Through 缓存，如果缓存中没有值，就会去数据库中获取数据，然后再保存到缓存中）：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = <span class="string">"user.%s"</span> % user_id</span><br><span class="line">user_blob = memcache.get(key)</span><br><span class="line"><span class="keyword">if</span> user_blob <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    user = mysql.query(<span class="string">"SELECT * FROM users WHERE user_id=\"%s\""</span>, user_id)</span><br><span class="line">    <span class="keyword">if</span> user:</span><br><span class="line">        memcache.set(key, json.dumps(user))</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> json.loads(user_blob)</span><br></pre></td></tr></table></figure></p>
<p>数据库缓存用的也很广泛。</p>
<p><img src="3.png" alt=""></p>
<p>只要使用数据库，就可以通过默认配置获得一定程度的缓存和性能。初始化的配置会优化通常的场景，针对你的系统做出针对性的配置之后就会极大的提升性能。</p>
<p>使用数据库缓存的最大好处是系统的代码不用做任何改动就可以提升性能，而且一个优秀的 DBA 也可以在不改动代码的情况下来提升程序的性能（我的同事 Rob Coli 最近花了一些时间优化 Cassandra 行缓存的配置，图表显示系统 I/O 负载急剧下降并且请求延迟也大大缩短了）。</p>
<p><strong>数据库缓存简单有效，而且不用开发人员做额外的工作，而应用缓存则需要开发人员自己实现</strong></p>
<h3>内存缓存</h3>
<p>对于系统而言，最有效的缓存是将整个数据集存储在内存中，Memcached 和 Redis 都是使用内存缓存来实现的（Redis 可以将数据持久化到硬盘上）。这是因为访问内存要比访问硬盘快几个数量级。</p>
<p>但是内存空间肯定要比硬盘少的多，所以要通过一定的策略让内存中只保留热点数据。使用最广泛的就是<code>最近最少使用策略（LRU）</code>，Memcache 使用的就是这个策略（Redis 2.2 之后的版本也可以配置这个策略）。LRU 策略会淘汰那些访问较少的数据而保留那些经常被访问的数据，这在大多数情况下都是最合适的缓存策略。</p>
<p><strong>性能最好，但是内存太贵了</strong></p>
<h3>内容分发网络（CDN）</h3>
<p>内容分发网络是一种特别的缓存（用人觉得 CDN 不是缓存，但我认为是），用来加速有大量静态媒体资源的站点。</p>
<p><img src="4.png" alt=""></p>
<p>CDN 为你的应用服务器（用来处理动态资源而不是静态资源）分担静态资源的访问压力，并且提供局域地理位置的分发方式。总的来说，站点的静态资源访问的速度将会更快，服务器的压力将会更小（但是会产生额外费用的压力）。</p>
<p>使用 CDN 后，请求会先去你的 CDN 上获取静态媒体资源，如果这些资源已经在 CDN 上，就会直接返回（HTTP 的头部用于配置 CDN 如何缓存给定内容）。如果 CDN 上找不到资源，CDN 就会去服务器上获取资源，然后缓存在本地，并且将内容提供给请求方（在这个配置中，CDN 充当 Read-Through 缓存）。</p>
<p>如果目前网站的规模还没有大到需要使用 CDN，在过渡期，可以使用 Nginx 这类的轻量级 HTTP 服务器使用单独的域名（比如：ststic.example.com）来将静态资源的访问进行分离，并在以后将 DNS 从服务器切换到 CDN。</p>
<p><strong>把静态资源从应用服务器上迁移到专门的内容分发缓存上，减轻应用服务器的压力</strong></p>
<h3>缓存失效</h3>
<p>尽管缓存很有用，但是也必须要保证缓存与数据源（比如：数据库）中数据的一致性，避免程序中出现奇怪行为的风险。</p>
<p>可以通过<strong>缓存失效</strong>来解决这个问题。</p>
<p>如果你要处理的是单个数据中心，直接使用缓存就可以，但是如果有多个代码路径会写入数据库和缓存，就很容易引起错误（特别是不把缓存策略考虑清楚就开始写代码）。通常的解决办法是在值变化后，就把改变后的值写入到缓存中（这种方式叫做 Write-Through 缓存）或者直接删除缓存中的值，然后通过 Read-Through 读取缓存时将值写入到缓存中（使用哪种方式取决于应用的细节，但是通常我更喜欢使用 Write-Through，这样可以避免瞬间给后端数据库造成过大的压力）。</p>
<p>在一些模糊查询的场景，失效策略变得更具有挑战性（比如在 SLOR 这样的全文搜索引擎上添加应用级缓存），或者对未知数量的元素进行修改（比如：删除一个礼拜前创建的所有对象）。</p>
<p>在这些情况下，你必须考虑完全使用数据库缓存，给缓存的数据设置过期时间或者重写应用的逻辑以避免这些问题（比如：不要使用 <code>DELETE FROM a WHERE...</code> 来进行删除，而要检索所有符合条件的项，使相应的缓存行失效，然后后通过主键显式删除这些行）。</p>
<p><strong>缓存很有用，但是你必须让缓存安全的失效</strong></p>
<h2>离线处理</h2>
<p>随着系统越来越复杂，总是需要去处理那些无法直接在线上处理的任务，因为直接在线上处理会造成不可接受的延迟（比如：想在社交图谱上查看用户的传播操作）或者是这些任务需要被周期性处理（比如：想要每日的分析汇总）。</p>
<h3>消息队列</h3>
<p>对于那些实时处理会很慢的请求，最容易的解决方法就是创建一个<code>消息队列</code>（比如使用 RabbitMQ）。消息队列允许你快速将消息发布到队列中，然后让其他的消费者进程异步进行处理。</p>
<p>离线消息队列处理请求和 Web 应用实时处理请求的划分取决于你向用户暴露的接口。通常你需要：</p>
<ol>
<li>在消费者中几乎什么都不用做（只要设定一个任务）并且通过用户这个任务将会离线处理，接口将会使用轮询机制来检查任务是否完成。</li>
<li>或者实时完成大部分工作，在用户看起来任务已经完成，然后实际把剩下的工作留到后续处理（比如你在 Twitter 或者 Facebook 上发布消息后，你自己的时间线会很快更新，但你的关注者的时间线会稍后更新，因为不可能实时的更新你所有关注者的时间线）</li>
</ol>
<p><img src="5.png" alt=""></p>
<p>消息队列还有一个好处，就是可以使用单独的机器来离线处理消息而不用加大当前 Web 服务器的压力。这可以使你将资源聚焦投入到影响性能和吞吐量的瓶颈，提高资源的使用率。</p>
<h3>周期性的定时任务</h3>
<p>几乎所有的大系统都需要执行定时任务，但是依然没有出现被广泛接受，可以支持大型系统定时任务的解决方案。同时，你可能依然对 cron 感到困惑，但是你可以使用 cronJob 来向消费者发布消息，cron 机器仅仅负责调度就可以，不用处理这些消息。</p>
<p>有谁知道解决这个问题的公认工具？我见过许多自己开发的系统，但是没有找到干净并且可以重用的系统。当然，你可以配置一台机器使用 Puppet 来存储 cronJob，这很容易恢复那些丢失的定时任务，虽然还是需要手动恢复，但还可以接受。</p>
<h3>MapReduce</h3>
<p>如果你的大系统需要处理大量的数据，可能就需要 MapReduce 的支持，会用到 Hadoop，Hive 和 HBase 等技术。</p>
<p><img src="6.png" alt=""></p>
<p>使用 MapReduce 可以使处理大量数据或者耗时操作所需的时间控制在合理的范围内。你可以使用 MapReduce 来计算社交关系中的推荐好友，或者生成分析报告。</p>
<p>对于小系统，可以避免使用 SQL 数据库上的临时查询，一旦数据量增长到需要搭建从服务器来对数据库进行分片，以支持这些查询，那么种种方式就很难扩展（到那时，你就会用专门处理大量数据的系统，而不是继续在数据库中挣扎）。</p>
<h2>平台层</h2>
<p>许多应用在刚开始的时候都是使用一个 Web 服务器直连数据库的结构。这种方式对大多数应用是够用了，但总有一些正当的理由来添加一个平台层，比如平台层可以让 Web 应用和数据库解耦，Web 应用连接平台层，平台层连接数据库。</p>
<p><img src="7.png" alt=""></p>
<p>首先，分离 Web 应用和平台层可以让你分别对两部分进行扩展。如果你需要添加一个新的 API，直接在平台层添加服务器就行，而不需要为 Web 应用层添加不必要的容量。（通常，对有专门用途的服务器进行优化可以带来很大的性能提升，比如数据库通常有比较高的 I/O 负载，如果给数据库服务器配置固态硬盘，就能很好的改善性能，但是对于 Web 应用服务器来说，升级 CPU 是一个更好的选择）</p>
<p>然后，添加一个平台层有利于在多个产品（Web 应用，API，IPhone App 等等）之间复用基础设施，而不用写很多重复的代码。</p>
<p>最后，平台层还有被低估的一个方面是可以使组织结构扩展变的很容易。最好的情况是，平台层公开了与产品无关的清晰接口，从而屏蔽了实现的细节。如果实现的好，可以让多个团队利用平台的能力进行应用开发，也允许其他的团队来扩展、优化平台层。</p>
<p><img src="8.png" alt=""></p>
<p>我本来打算在处理多个数据中心方面进行适度的详细介绍，但是这个主题内容太大，可以写成一篇单独的文章，因此我只提了一下缓存失效和数据复制/一致性的问题。</p>
<p>我在这篇文章中做了一些有争议的陈述，希望亲爱的读者可以提出不同的意见，以便我们都能从中学到一些东西。 感谢阅读！</p>
<hr>
<p>这是一篇<a href="https://lethain.com/introduction-to-architecting-systems-for-scale/" target="_blank" rel="noopener">译文</a>。这篇文章详尽的介绍了构建一个可扩展
系统需要做的一些事情，甚至提到了中台的一些概念（2011 年）。Will Larson 之前在雅虎和 Digg 工作过，参与过大型可伸缩性系统的建设。</p>
<p>(完)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行搜索神器fzf</title>
    <url>/2020/12/12/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%90%9C%E7%B4%A2%E7%A5%9E%E5%99%A8fzf/</url>
    <content><![CDATA[<p>在日常工作中，命令行搜索是一个必不可少的功能，虽然 find 命令也挺强大，但是在模糊匹配做的就不是很好。</p>
<p>而 fzf 刚好解决了这个问题，fzf 是对目前 Linux 系统搜索的一个补充，而且这个搜索工具是可以交互式搜索的，就是可以实时根据输入的参数不同，展示不同的搜索结果。</p>
<p>本文基于 macOS Big Sur 11.0.1</p>
<h2>1. 安装</h2>
<p>fzf 目前支持 macOS，Linux 和 Windows，可以通过直接下载安装包安装，也可以通过包管理器进行安装。</p>
<p>重点说一下通过包管理器来安装。</p>
<h3>macOS</h3>
<p>在 macOS 上，可以通过 Homebrew 进行安装:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install fzf <span class="comment"># 安装 fzf</span></span><br><span class="line">brew update <span class="comment"># 更新 fzf</span></span><br></pre></td></tr></table></figure></p>
<p>或者通过 MacPorts 进行安装:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port install fzf <span class="comment"># 安装 fzf</span></span><br><span class="line">port upgrade fzf <span class="comment"># 更新 fzf</span></span><br></pre></td></tr></table></figure></p>
<h3>Linux</h3>
<p>在 Linux 系统上，使用相应的包管理器进行安装就可以，比如在 Ubuntu 上：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install fzf <span class="comment"># 安装 fzf</span></span><br></pre></td></tr></table></figure></p>
<h3>Windows</h3>
<p>在 Windows 上，可以使用 Chocolatey 或者 Scoop 包管理器进行安装：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">choco install fzf</span><br><span class="line">scoop install fzf</span><br></pre></td></tr></table></figure></p>
<h3>Git</h3>
<p>fzf 还可以直接下载源码进行安装:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/junegunn/fzf.git ~/.fzf</span><br><span class="line">~/.fzf/install</span><br></pre></td></tr></table></figure></p>
<h2>2. 使用</h2>
<p>在安装完成之后，可以直接在命令行进行使用，使用的方式很简单，打开一个命令行，在任意一个目录下输入 <code>fzf</code> 或者使用快捷键 CTRL-T，就可以进入到 fzf 的交互式搜索。</p>
<p><img src="1.png" alt=""></p>
<p>该目录下，包括子目录的所有文件都可以被搜索，而且可以随意的输入关键字，关键字可以被拆分，分别匹配。</p>
<p>fzf 不但可以独立使用，还是以通过管道与其他的命令进行配合使用。</p>
<p>比如结合 find：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find *.go ./ | fzf</span><br></pre></td></tr></table></figure></p>
<p>比如结合 cat：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat demo.go | fzf</span><br></pre></td></tr></table></figure></p>
<p>基本上，上面的功能就足够使用了，但 fzf 还有更能更强大的地方，比如在命令行搜索文件时，只能看见文件名称。</p>
<p>fzf 可以让你在命令行就对这些文件进行预览，很简单，使用下面的命令的就可以了：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fzf --preview <span class="string">'cat &#123;&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>这个命令表示使用 cat 来作为预览时打开文件的工具，效果如下：</p>
<p><img src="2.png" alt=""></p>
<p>另外，可以使用 CTRL-J 和 CTRL-K 上下翻动文件，右侧就可以出现文件内容的预览。</p>
<p>使用 CTRL-C 可以退出交互界面。</p>
<p>上面的内容基本就够用了，但 fzf 还有一些高阶的用法，比如对查询界面进行定制，使用更复杂的查询语句，对于这些，可以直接查看文档。</p>
<p>文 / Rayjun</p>
<h2>REF</h2>
<p>[1] <a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">https://github.com/junegunn/fzf</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>在WSL中使用 emacs</title>
    <url>/2018/10/10/%E5%9C%A8WSL%E4%B8%AD%E4%BD%BF%E7%94%A8emacs/</url>
    <content><![CDATA[<p><code>WSL</code> 是一个为在 <code>Windows 10</code> 上能够原生运行 Linux 二进制可执行文件（ELF格式）的兼容层。通俗点说就是可以直接在 Win10 上使用 linux。</p>
<p>在使用了一段时间的钟vscode之后，我还是决定将主力编辑器从vscode上迁回到emacs上。</p>
<p>其实vscode是一个很优秀的编辑器，当然是对于那些没有深度使用过emacs/vim的人来说。</p>
<p>其实emacs和vim不是互相排斥的，emacs加上vim可以发挥出更大的威力，emacs虽然年代久远，但是更新的频率并不是很低，大概能保持一年一个大版本的更新。</p>
<p>emacs/vim依然值得投资。</p>
<p>之前在windows使用emacs很费劲，要额外的安装一大堆东西，而且使用的体验也很一般。但是自从wsl出来之后，情况就开始有很大的改观了。</p>
<p>在wsl网络和端口与windows是共享的，这也就意味着可以直接在wsl中开发项目，然后在windows调试。windows就没有再被吐槽的点了。还有一个终端，wsl-terminal提供了不输linux终端的体验。</p>
<p>在wsl-terminal中打开emacs的体验如下，简直就与直接打开emacs没有任何区别。所有在图形化的emacs能使用的功能一样可以在这种终端模式下使用。</p>
<p>emacs确实有着不小的上手难度，所以在一开始的时候，可以考虑直接使用大神的配置，不推荐直接自己去配置插件。我在一开始使用的时候，花了很多的时间去自己配置插件，但是最后配置出来的效果不好。</p>
<p>比如有开箱即用的 spacemacs，但是我觉得这个配置有点臃肿，打开的速度也有点慢，给人一种油腻的感觉。</p>
<p>我现在使用的配置是从 陈斌（redguardtoo）fork 来的，加上了我自己需要的配置。陈斌的配置是我用过的诸多配置里最好的一个，插件很丰富，启动速度也还可以，而且没有spacemacs那么花哨，那么油腻的感觉，而且对自定义也比较友好。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>如何从Fastjson迁移到Gson</title>
    <url>/2020/03/06/%E5%A6%82%E4%BD%95%E4%BB%8EFastjson%E8%BF%81%E7%A7%BB%E5%88%B0Gson/</url>
    <content><![CDATA[<p>JSON 库在在日常的开发中使用很普遍，序列化数据，服务之间交换数据。</p>
<p>常用的 JSON 库很多，比如阿里巴巴的 Fastjson，谷歌的 Gson，以及 Jackjson。</p>
<p>由于 Fastjson 漏洞问题，所以准备使用 Gson 来替代 FastJson。虽然 Fastjson 号称是最快的 JSON 工具，但其实 Gson 和 Jackson 等工具与它的差距很小了，相比与追求这一点性能的提升，系统的安全更重要。</p>
<p>而且个人觉得 Gson 的文档比 fastjson 要更好一些（文档时程序员的必修课）。</p>
<p>本文就来说明一下，如何从 Fastjson 平滑的迁移到 Gson，尽量不说废话，使用代码来说明问题</p>
<blockquote>
<p>注：本文代码使用 Fastjson-1.2.60，Gson-2.8.6</p>
</blockquote>
<p>使用 Fastjson时， 最主要的功能如下：</p>
<ul>
<li>将对象转成 JSON</li>
<li>将 JSON 转成对象</li>
<li>解析 JSON 字符串</li>
<li>处理 JSON 数组</li>
<li>处理 泛型对象</li>
</ul>
<p>下面分别来看看 Gson 中如何实现这些。示例代码中使用的两个类如下(省略了 get 和 set 方法)：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">long</span> id, String name, String gender, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassRoom</span><span class="params">(<span class="keyword">long</span> id, String className, List&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">        <span class="keyword">this</span>.students = students;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3>对象和 JSON 的互相转换</h3>
<p><strong>对象转 JSON</strong></p>
<p>fastjson:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"小明"</span>, <span class="string">"男"</span>, <span class="number">12</span>);</span><br><span class="line">String studentJson = JSON.toJSONString(s1);</span><br></pre></td></tr></table></figure></p>
<p>gson:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"小明"</span>, <span class="string">"男"</span>, <span class="number">12</span>);</span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">String studentJson = gson.toJson(s1);</span><br></pre></td></tr></table></figure></p>
<p><strong>JSON 转对象</strong></p>
<p>fastjson:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String json = <span class="string">"&#123;\"age\":12,\"gender\":\"男\",\"id\":1,\"name\":\"小明\"&#125;"</span>;</span><br><span class="line">Student student = JSON.parseObject(json, Student.class);</span><br></pre></td></tr></table></figure></p>
<p>gson:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> String json = <span class="string">"&#123;\"age\":12,\"gender\":\"男\",\"id\":1,\"name\":\"小明\"&#125;"</span>;</span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">Student student = gson.fromJson(json, Student.class);</span><br></pre></td></tr></table></figure></p>
<p>上面处理的时简单的对象，对于有嵌套的对象，处理起来同样简单：</p>
<p>fastjson:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"小明"</span>, <span class="string">"男"</span>, <span class="number">12</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"小芳"</span>, <span class="string">"女"</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; students = Arrays.asList(s1, s2);</span><br><span class="line">ClassRoom classRoom = <span class="keyword">new</span> ClassRoom(<span class="number">1</span>, <span class="string">"六年级一班"</span>, students);</span><br><span class="line"></span><br><span class="line">String classRoomJson = JSON.toJSONString(classRoom); <span class="comment">// 将嵌套对象转成 JSON</span></span><br><span class="line">ClassRoom classRoom = JSON.parseObject(json, ClassRoom.class); <span class="comment">// 将 JSON 转成嵌套的对象</span></span><br></pre></td></tr></table></figure></p>
<p>gson:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"小明"</span>, <span class="string">"男"</span>, <span class="number">12</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"小芳"</span>, <span class="string">"女"</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; students = Arrays.asList(s1, s2);</span><br><span class="line">ClassRoom classRoom = <span class="keyword">new</span> ClassRoom(<span class="number">1</span>, <span class="string">"六年级一班"</span>, students);</span><br><span class="line"></span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">String classRoomJson = gson.toJson(classRoom); <span class="comment">// 将嵌套对象转成 JSON</span></span><br><span class="line">ClassRoom classRoom = gson.fromJson(json, ClassRoom.class); <span class="comment">// 将 JSON 转成嵌套对象</span></span><br></pre></td></tr></table></figure></p>
<h3>JSON 字符串解析</h3>
<p>上面的例子演示的是 JSON 和对象之间的相互转化，如果在有些情况下，JSON 没有对应的 Java 类型，这个时候该怎么处理：</p>
<p>fastjson:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String json = <span class="string">"&#123;\"age\":18, \"grade\": \"六年级\", \"name\": \"小明\", \"score\": 99&#125;"</span>;</span><br><span class="line">JSONObject jsonObject = JSON.parseObject(json);</span><br><span class="line"></span><br><span class="line">jsonObject.getString(<span class="string">"name"</span>);  <span class="comment">// 小明</span></span><br><span class="line">jsonObject.getInteger(<span class="string">"score"</span>); <span class="comment">// 99</span></span><br></pre></td></tr></table></figure></p>
<p>gson:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String json = <span class="string">"&#123;\"age\":18, \"grade\": \"六年级\", \"name\": \"小明\", \"score\": 99&#125;"</span>;</span><br><span class="line"></span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">JsonObject jsonObject = gson.fromJson(json, JsonObject.class);</span><br><span class="line">jsonObject.get(<span class="string">"name"</span>).getAsString(); <span class="comment">// 小明</span></span><br><span class="line">jsonObject.get(<span class="string">"score"</span>).getAsInt(); <span class="comment">// 99</span></span><br></pre></td></tr></table></figure></p>
<h3>JSON 数组处理</h3>
<p>对于更复杂一点的情况，json是一个数组，但没关系，处理起来同样简单：</p>
<p>fastjson:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String json = <span class="string">"[&#123;\"age\":18, \"grade\": \"六年级\", \"name\": \"小明\", \"score\": 99&#125;,&#123;\"age\":18, \"grade\": \"六年级\", \"name\": \"小芳\", \"score\": 100&#125;]"</span>;</span><br><span class="line"></span><br><span class="line">JSONArray jsonArray = JSON.parseArray(json);</span><br><span class="line"></span><br><span class="line">jsonArray.getJSONObject(<span class="number">0</span>).getString(<span class="string">"name"</span>); <span class="comment">// 小明</span></span><br><span class="line">jsonArray.getJSONObject(<span class="number">1</span>).getString(<span class="string">"name"</span>); <span class="comment">// 小芳</span></span><br></pre></td></tr></table></figure></p>
<p>gson:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String json = <span class="string">"[&#123;\"age\":18, \"grade\": \"六年级\", \"name\": \"小明\", \"score\": 99&#125;,&#123;\"age\":18, \"grade\": \"六年级\", \"name\": \"小芳\", \"score\": 100&#125;]"</span>;</span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">JsonArray jsonArray = gson.fromJson(json, JsonArray.class);</span><br><span class="line">   jsonArray.get(<span class="number">0</span>).getAsJsonObject().get(<span class="string">"name"</span>).getAsString(); <span class="comment">// 小明</span></span><br><span class="line">jsonArray.get(<span class="number">1</span>).getAsJsonObject().get(<span class="string">"name"</span>).getAsString(); <span class="comment">// 小芳</span></span><br></pre></td></tr></table></figure></p>
<h3>泛型对象处理</h3>
<p>泛型对象在日常开发中用的也挺多的，比如 List 和 Map，这两个类库也都提供了相应的方法：</p>
<p>fastjson:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"小明"</span>, <span class="string">"男"</span>, <span class="number">12</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"小芳"</span>, <span class="string">"女"</span>, <span class="number">12</span>);</span><br><span class="line">List&lt;Student&gt; students = Arrays.asList(s1,s2);</span><br><span class="line"></span><br><span class="line">String json = JSON.toJSONString(students);</span><br><span class="line"></span><br><span class="line">Type type = <span class="keyword">new</span> TypeReference&lt;List&lt;Student&gt;&gt;()&#123;&#125;.getType(); <span class="comment">// 在这里需要获取完整的泛型类型</span></span><br><span class="line">students = JSON.parseObject(json, type);</span><br></pre></td></tr></table></figure></p>
<p>gson:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"小明"</span>, <span class="string">"男"</span>, <span class="number">12</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"小芳"</span>, <span class="string">"女"</span>, <span class="number">12</span>);</span><br><span class="line">List&lt;Student&gt; students = Arrays.asList(s1,s2);</span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">Type type = <span class="keyword">new</span> TypeToken&lt;List&lt;Student&gt;&gt;() &#123;&#125;.getType(); <span class="comment">// 获取泛型类型</span></span><br><span class="line"></span><br><span class="line">String json = gson.toJson(students);</span><br><span class="line">students = gson.fromJson(json, type);</span><br></pre></td></tr></table></figure></p>
<p>通过上面的对比发现，其实两个框架都提供了相似的功能，方法名称上会有一些细微的差别。</p>
<p>Gson 基本上可以覆盖到 Fastjson 中的功能，虽然 Fastjson 在性能上要强于 Gson，但是在大多数情况下，只要处理的对象不大，性能的差别也不会很大。</p>
<p>而且需要说一下，Fastjson 真的需要把文档好好整理一下了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何为自己准备选择一个开源协议</title>
    <url>/2018/08/19/%E5%A6%82%E4%BD%95%E4%B8%BA%E8%87%AA%E5%B7%B1%E5%87%86%E5%A4%87%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>开源推动了软件的发展，对于这个结论，至今应该不会有人再有意见了。但是最近最好的开源社区卖身给了曾经最反对开源的组织--微软。em….好像有一种奇怪的感觉，但是好在如今微软对开源的态度已经和以往截然不同了，希望微软能在这一点上继续坚持下去，好好推动开源软件的发展。</p>
<p>说到开源，好像一直就有一些误解。很多人认为开源就是免费，其实这两者是有本质的差别的。因为如果开源就等于免费，那开源这件事基本上是没有办法继续下去了。比如 A 发布了一个开源的软件，非常好用，然后 B 将这个开源软件的源码修改之后就不再开源，并且将这些软件拿去卖钱，这样一来，A 不干了，说我采用的是 GPL 开源协议，B 这样干是违法的。B 如果对于开源协议不了解，就会一脸懵逼，说好的开源呢？其实这里 B 对于开源就有很深的误解了。</p>
<p>对于一份代码来说，会涉及到很多的内容，比如说代码的协议和版权信息，代码的商标，代码造成犯罪的责任承担等等,大体上可以分成以下的：</p>
<ul>
<li>a 协议和版本信息：在代码中保留作者提供的协议和版权信息</li>
<li>b 声明变更：在代码中声明对原来代码的重大修改和变更</li>
<li>c 公开源码：源码必须公开</li>
<li>d 商业使用：代码用于商业活动</li>
<li>e 责任承担：代码的作者承担代码使用后造成的后果</li>
<li>f 商标使用：可以使用作者的姓名、作品的 LOGO或者商标</li>
<li>g 附加协议：在原来的协议的基础上增加新的附加协议</li>
</ul>
<p>下面是常见的六种开源协议上对这些规则的限定：</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>要求</th>
<th>允许</th>
<th>禁止</th>
</tr>
</thead>
<tbody>
<tr>
<td>Apache</td>
<td>a b</td>
<td>d g</td>
<td>e f</td>
</tr>
<tr>
<td>GPL</td>
<td>a b c</td>
<td>d</td>
<td>e g</td>
</tr>
<tr>
<td>MIT</td>
<td>a</td>
<td>d</td>
<td>e</td>
</tr>
<tr>
<td>BSD</td>
<td>a</td>
<td>d g</td>
<td>e</td>
</tr>
<tr>
<td>LGPL</td>
<td>a c</td>
<td>d g</td>
<td>e</td>
</tr>
<tr>
<td>Mozilla</td>
<td>a c</td>
<td>d g</td>
<td>e f</td>
</tr>
</tbody>
</table>
<p>当然，看完这些之后，你是不是还是一头雾水，当然了，一下子要记住这么多晦涩的东西确实不是一件简单的事情，那么还有一个更简单的方法来帮助你选择，下面这张图是阮一峰大神从国外汉化过来的，可以说是很清晰了：</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201105/free_software_licenses.png" alt=""></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Apache CXF 快速实现一个 WebService</title>
    <url>/2020/05/31/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Apache-CXF-%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-WebService/</url>
    <content><![CDATA[<p>在单体架构向分布式架构演进的过程中，跨进程的通信成为刚需，如果直接利用 Socket 进行通信，那么就会使得编程变得很复杂。</p>
<p>在 1984 年，Bruce Jay Nelson 提出了<a href="https://dl.acm.org/doi/pdf/10.1145/2080.357392" target="_blank" rel="noopener">跨进程通信</a>的标准，也就是我们通常说的 RPC(Remote Procedure Call)。后面所有的所有的 RPC 框架都是通过这个标准来设计的。</p>
<p>RPC 的理念其实很简单，当客户端想发起一个调用时，实际上是通过本地调用方的 Stub（可以理解为接口），这个 Stub 将要客户端需要执行的方法和参数通过约定的协议进行编码，然后通过网络传输到服务端，服务端接收到这些信息之后执行真正的方法，得到结果后再通过网络传输给客户端。</p>
<h2>Web Services 简介</h2>
<p><a href="https://www.w3.org/2002/ws/Activity" target="_blank" rel="noopener">Web Services</a> 属于 RPC 的一种。Web Services 使用 <a href="https://www.w3.org/TR/soap/" target="_blank" rel="noopener">SOAP</a> 作为传输协议，使用 <a href="https://www.w3.org/TR/wsdl20/" target="_blank" rel="noopener">WSDL</a> 作为服务的描述语言，使用 UDDI 作为服务注册发现（虽然没有发展起来）。</p>
<p>虽然 Web Services 的相关协议在 2007 年之后基本就没再更新，但是在一些银行等金融机构，Web Services 还在被大量使用。</p>
<p>WebService 的框架很多，比如 Axis2，XFire，CXF 等等。</p>
<p>Apache Cxf 是其中最优秀，最具有生命力的一个，而且 CXF 框架不仅仅是一个 Web Services 框架，甚至可以通过 CXF 来实现 RESTful 风格的服务。</p>
<h2>CXF 实现一个简单的 Web Services</h2>
<p>使用 CXF 实现 Web Services 非常简单。</p>
<p>一个完整的 Web Services 服务分为服务器端和服务端，先来看服务器端的代码实现。</p>
<p>首先创建一个 Maven 项目，在 pom.xml 中引入如下的依赖：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.4.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.4.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.4.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后就可以开始写代码了，首先需要定义一个可以暴露出去的 API 接口：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CxfDemoService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>@WebService</code> 注解表明这是一个对外的接口。然后需要实现具体的业务逻辑：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CxfDemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">CxfDemoService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就像实现一个普通的类一样，没有任何特殊的地方。然后创建一个服务：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CxfDemoServiceImpl implementor = <span class="keyword">new</span> CxfDemoServiceImpl();</span><br><span class="line">JaxWsServerFactoryBean svrFactory = <span class="keyword">new</span> JaxWsServerFactoryBean();</span><br><span class="line">svrFactory.setServiceClass(CxfDemoService.class);</span><br><span class="line">svrFactory.setAddress(<span class="string">"http://localhost:9000/cxfDemoService"</span>);</span><br><span class="line">svrFactory.setServiceBean(implementor);</span><br><span class="line">svrFactory.create();</span><br></pre></td></tr></table></figure></p>
<p>代码也很简单，我们把服务的地址设置为 <code>http://localhost:9000/cxfDemoService</code>，只要端口号不冲突，这个地址可以根据需要定义。服务端的代码就这些了，只需要把这段代码放到一个 main 方法中，启动就可以。</p>
<p>上面我们说到 Web Servces 使用 WSDL 来作为服务描述语言，这个怎么理解呢？写好的服务是要提供给其他人调用的，那么别人需要知道这个接口需要什么参数，返回的结果是什么，这个时候，只需要访问 <code>http://localhost:9000/cxfDemoService?wsdl</code>，在服务地址的后面加上 ?wsdl 就可以，返回的结果如下：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;wsdl:definitions xmlns:xsd=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> xmlns:wsdl=<span class="string">"http://schemas.xmlsoap.org/wsdl/"</span> xmlns:tns=<span class="string">"http://cxf.rayjun.cn/"</span> xmlns:soap=<span class="string">"http://schemas.xmlsoap.org/wsdl/soap/"</span> xmlns:ns1=<span class="string">"http://schemas.xmlsoap.org/soap/http"</span> name=<span class="string">"CxfDemoServiceService"</span> targetNamespace=<span class="string">"http://cxf.rayjun.cn/"</span>&gt;</span><br><span class="line">    &lt;wsdl:types&gt;</span><br><span class="line">        &lt;xs:schema xmlns:xs=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> xmlns:tns=<span class="string">"http://cxf.rayjun.cn/"</span> elementFormDefault=<span class="string">"unqualified"</span> targetNamespace=<span class="string">"http://cxf.rayjun.cn/"</span> version=<span class="string">"1.0"</span>&gt;</span><br><span class="line">            &lt;xs:element name=<span class="string">"hello"</span> type=<span class="string">"tns:hello"</span>/&gt;</span><br><span class="line">            &lt;xs:element name=<span class="string">"helloResponse"</span> type=<span class="string">"tns:helloResponse"</span>/&gt;</span><br><span class="line">            &lt;xs:complexType name=<span class="string">"hello"</span>&gt;</span><br><span class="line">                &lt;xs:sequence&gt;</span><br><span class="line">                    &lt;xs:element minOccurs=<span class="string">"0"</span> name=<span class="string">"arg0"</span> type=<span class="string">"xs:string"</span>/&gt;</span><br><span class="line">                &lt;/xs:sequence&gt;</span><br><span class="line">            &lt;/xs:complexType&gt;</span><br><span class="line">            &lt;xs:complexType name=<span class="string">"helloResponse"</span>&gt;</span><br><span class="line">                &lt;xs:sequence&gt;</span><br><span class="line">                    &lt;xs:element minOccurs=<span class="string">"0"</span> name=<span class="string">"return"</span> type=<span class="string">"xs:string"</span>/&gt;</span><br><span class="line">                &lt;/xs:sequence&gt;</span><br><span class="line">            &lt;/xs:complexType&gt;</span><br><span class="line">        &lt;/xs:schema&gt;</span><br><span class="line">    &lt;/wsdl:types&gt;</span><br><span class="line">    &lt;wsdl:message name=<span class="string">"helloResponse"</span>&gt;</span><br><span class="line">        &lt;wsdl:part element="tns:helloResponse" name="parameters"&gt; &lt;/wsdl:part&gt;</span><br><span class="line">    &lt;/wsdl:message&gt;</span><br><span class="line">    &lt;wsdl:message name=<span class="string">"hello"</span>&gt;</span><br><span class="line">        &lt;wsdl:part element="tns:hello" name="parameters"&gt; &lt;/wsdl:part&gt;</span><br><span class="line">    &lt;/wsdl:message&gt;</span><br><span class="line">    &lt;wsdl:portType name=<span class="string">"CxfDemoService"</span>&gt;</span><br><span class="line">        &lt;wsdl:operation name=<span class="string">"hello"</span>&gt;</span><br><span class="line">            &lt;wsdl:input message="tns:hello" name="hello"&gt; &lt;/wsdl:input&gt;</span><br><span class="line">            &lt;wsdl:output message="tns:helloResponse" name="helloResponse"&gt; &lt;/wsdl:output&gt;</span><br><span class="line">        &lt;/wsdl:operation&gt;</span><br><span class="line">    &lt;/wsdl:portType&gt;</span><br><span class="line">    &lt;wsdl:binding name=<span class="string">"CxfDemoServiceServiceSoapBinding"</span> type=<span class="string">"tns:CxfDemoService"</span>&gt;</span><br><span class="line">        &lt;soap:binding style=<span class="string">"document"</span> transport=<span class="string">"http://schemas.xmlsoap.org/soap/http"</span>/&gt;</span><br><span class="line">        &lt;wsdl:operation name=<span class="string">"hello"</span>&gt;</span><br><span class="line">            &lt;soap:operation soapAction=<span class="string">""</span> style=<span class="string">"document"</span>/&gt;</span><br><span class="line">            &lt;wsdl:input name=<span class="string">"hello"</span>&gt;</span><br><span class="line">                &lt;soap:body use=<span class="string">"literal"</span>/&gt;</span><br><span class="line">            &lt;/wsdl:input&gt;</span><br><span class="line">            &lt;wsdl:output name=<span class="string">"helloResponse"</span>&gt;</span><br><span class="line">                &lt;soap:body use=<span class="string">"literal"</span>/&gt;</span><br><span class="line">            &lt;/wsdl:output&gt;</span><br><span class="line">        &lt;/wsdl:operation&gt;</span><br><span class="line">    &lt;/wsdl:binding&gt;</span><br><span class="line">    &lt;wsdl:service name=<span class="string">"CxfDemoServiceService"</span>&gt;</span><br><span class="line">        &lt;wsdl:port binding=<span class="string">"tns:CxfDemoServiceServiceSoapBinding"</span> name=<span class="string">"CxfDemoServicePort"</span>&gt;</span><br><span class="line">            &lt;soap:address location=<span class="string">"http://localhost:9000/cxfDemoService"</span>/&gt;</span><br><span class="line">        &lt;/wsdl:port&gt;</span><br><span class="line">    &lt;/wsdl:service&gt;</span><br><span class="line">&lt;/wsdl:definitions&gt;</span><br></pre></td></tr></table></figure></p>
<p>返回的结果是一个 xml 文档，这个就是通过 WSDL 来描述服务的全部信息，可以从这个文档中找到调用这个服务所需要的参数及返回的结果等详细信息。</p>
<p>到这里为止，服务端的代码就写好了，那么接下来就需要写客户端的代码，客户端的代码也很简单：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JaxWsProxyFactoryBean factory = <span class="keyword">new</span> JaxWsProxyFactoryBean();</span><br><span class="line">factory.setServiceClass(CxfDemoService.class);</span><br><span class="line">factory.setAddress(<span class="string">"http://localhost:8080/CxfDemoService"</span>);</span><br><span class="line">CxfDemoService client = (CxfDemoService) factory.create();</span><br><span class="line">String reply = client.hello(<span class="string">"Rayjun"</span>);</span><br><span class="line">System.out.println(<span class="string">"Server : "</span> + reply); <span class="comment">// Server: hello rayjun</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码简单粗暴，如果直接这样进行开发，代码很容易就会变得难以维护，使用 Spring 来组织代码则可以很轻易的解决这个问题。</p>
<h2>CXF 与 Spring 集成</h2>
<p>CXF 可以与 Spring 无缝连接，只需要引入下面的 Spring 依赖：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后创建Spring容器的配置文件：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:jaxws=<span class="string">"http://cxf.apache.org/jaxws"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">" http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span><br><span class="line"><span class="string">       http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;<span class="keyword">import</span> resource=<span class="string">"classpath:META-INF/cxf/cxf.xml"</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">import</span> resource=<span class="string">"classpath:META-INF/cxf/cxf-servlet.xml"</span>/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;jaxws:endpoint id=<span class="string">"rmsEngineService"</span> implementor=<span class="string">"cn.rayjun.cxf.CxfDemoServiceImpl"</span> address=<span class="string">"/CxfDemoService"</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
在配置文件中直接使用 CXF 默认的配置文件，并且使用 <code>jaxws</code> 来定义服务的接口。JAX-WS 是 J2EE 中对 Web Services 的实现，JAX-RS 同样也是 J2EE WEB Services 的一部分，是 RESTful 风格的 API，在这里我们使用的是 JAX-WS。</p>
<p>并将配置文件加入到 web.xml 中：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE web-app PUBLIC</span><br><span class="line"> <span class="string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"> <span class="string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span><br><span class="line"></span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">CXFServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">class</span>&gt;<span class="title">org</span>.<span class="title">apache</span>.<span class="title">cxf</span>.<span class="title">transport</span>.<span class="title">servlet</span>.<span class="title">CXFServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;2&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">CXFServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">web</span>-<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后就可以将程序打包放到 web 容器中，如果为了测试方便，也可以直接使用 maven 的 jetty 插件直接运行项目，jetty 插件配置如下：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;9.4.29.v20200521&lt;/version&gt;</span><br><span class="line">  &lt;configuration&gt;</span><br><span class="line">    &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;</span><br><span class="line">    &lt;war&gt;$&#123;project.basedir&#125;/target/cxfdemo.war&lt;/war&gt;</span><br><span class="line">    &lt;webApp&gt;</span><br><span class="line">      &lt;contextPath&gt;/&lt;/contextPath&gt;</span><br><span class="line">    &lt;/webApp&gt;</span><br><span class="line">    &lt;httpConnector&gt;</span><br><span class="line">      &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">    &lt;/httpConnector&gt;</span><br><span class="line">  &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后使用 <code>mvn jetty:run-war</code>，服务端就运行起来了，客户端的代码不需要变，就可以很轻松的访问服务了。</p>
<p>到这里，利用 CXF 就把服务的脚手架搭建起来了，就可以根据自己的需要加上其他的配置或者开始业务逻辑的开发。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅的理解HBase和BigTable</title>
    <url>/2020/06/14/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%90%86%E8%A7%A3HBase%E5%92%8CBigTable/</url>
    <content><![CDATA[<p>学习 HBase 最难的地方在于要让你的脑子真正理解它是什么。</p>
<blockquote>
<p>HBase：Google BigTable 的开源实现</p>
</blockquote>
<p>我们经常会把关系型数据库（RDBMS，比如 MySQL）和 HBase 搞混，因为在这两个系统中都包含 table 和 base（HBase，Database）。</p>
<p>这篇文章的目标是从概念上来说清楚 HBase 这个分布式的数据存储系统。读完后，你应该可以很清楚的知道什么情况下 HBase 更好，什么情况下传统的关系型数据库更好。</p>
<h2>关于一些术语</h2>
<p>幸运的是，<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf" target="_blank" rel="noopener">Google 的 BigTable论文</a>清楚的解释了 BigTable 到底是什么。下面是论文中数据模型章节的第一句话：</p>
<p><strong>BigTable 是一个稀疏的、分布式的、可持久化的多维有序 map。</strong></p>
<blockquote>
<p>在这个节骨眼上，我想给读者一个机会，让他们在读到最后一行字时，能够收集到他们脑壳里的活动信息（这可能是个笑话，但我没懂^v^）。</p>
</blockquote>
<p>论文中，继续解释如下：</p>
<p><strong>map 通过 rowKey，columnKey 和时间戳进行索引，map 中的每个值都是一个连续的字节数组。</strong></p>
<blockquote>
<p>注：rowKey 是记录的主键，唯一标识一行记录</p>
</blockquote>
<p>在 <a href="https://hadoop.apache.org/" target="_blank" rel="noopener">Hadoop</a> 的官方文档中，也对 HBase 的架构做了说明：</p>
<p><strong>HBase 使用了与 BigTable 非常类似的数据模型。用户存储数据行到特定的表中。一个数据行有一个可排序的 rowKey 和数量不定的列。这个表是稀疏的，只要用户愿意，这个表不同行可以有完全不同的列。</strong></p>
<p>这些话看起来相当费解，让人摸不着头脑，但如果你把这些话拆成一个个词，意思就慢慢变的清晰了。我将按照以下的顺序来讨论这些词：map，持久化，分布式，有序的，多维的，稀疏。</p>
<p>我发现循序渐进地建立一个思维框架要比一次性勾画一个完整的系统更加容易。</p>
<h2>map</h2>
<p>从根本来上来，HBase/BigTable 是一个 map。map 在不同的编程语言中有不同的叫法，比如 PHP 中的 array，Python 的 dictionary，Ruby 中的 Hash，或者 JavaScript 中的 Object。</p>
<p>维基百科上对于 map 的定义是：map 是一个抽象的数据类型，包含了一组 key 和一组 value，每个 key 关联一个 value。</p>
<p>如果用 JavaScript 的对象来表示 map，这里有一个简单的例子，其中所有的 value 都是字符串：</p>
<p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"zzzzz"</span> : <span class="string">"woot"</span>,</span><br><span class="line">  <span class="attr">"xyz"</span> : <span class="string">"hello"</span>,</span><br><span class="line">  <span class="attr">"aaaab"</span> : <span class="string">"world"</span>,</span><br><span class="line">  <span class="attr">"1"</span> : <span class="string">"x"</span>,</span><br><span class="line">  <span class="attr">"aaaaa"</span> : <span class="string">"y"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>持久化的</h2>
<p>持久化的意思仅仅是指你放进这个特殊 map 的数据会在你的程序执行完成之后被保存下来。它和其他的持久化存储系统中持久化的概念没有任何区别，比如存一个文件到一个文件系统。我们继续...</p>
<h2>分布式的</h2>
<p>HBase 和 BigTable 都建立在分布式文件系统上，所以底层文件可以被分散存储到不同的机器上。</p>
<p>HBase 可以存储到 HDFS（Hadoop's Distributed File System）上，也可以存储到 亚马逊的 S3（Simple Storage Service）上，而 BigTable 使用的是 GFS（Google File System）。</p>
<p>同一份数据会被复制存储到多个节点上，类似于 RAID（独立冗余磁盘阵列，利用冗余存储的数据使损坏数据得以恢复，从而保护数据不丢失）系统中数据在磁盘上的复制存储到多块磁盘的方式。</p>
<p>在这篇文章中，我们不关心具体使用哪种分布式文件系统。重要的是，要理解这个文件系统是分布式的，即使集群中某个节点出现故障，也可以保证数据的完整性和安全性。</p>
<h2>有序的</h2>
<p>和其他大多数 map 的实现不同，HBase 和 BigTable 的键值对的顺序严格按照字母顺序来排列。所以 rowKey 为 &quot;aaaaa&quot; 的下一条记录的 rowKey 就是 &quot;aaaab&quot;，并且会离 “zzzz” 非常远。</p>
<p>继续看上面的那个 JSON 例子，排行序之后是下面这样的：</p>
<p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"1"</span> : <span class="string">"x"</span>,</span><br><span class="line">  <span class="attr">"aaaaa"</span> : <span class="string">"y"</span>,</span><br><span class="line">  <span class="attr">"aaaab"</span> : <span class="string">"world"</span>,</span><br><span class="line">  <span class="attr">"xyz"</span> : <span class="string">"hello"</span>,</span><br><span class="line">  <span class="attr">"zzzzz"</span> : <span class="string">"woot"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为这个系统是分布式的，而且会越来越大，因此排序这个特性非常重要。这样就会把 rowKey 相近的记录放在一起，在某些情况下，如果你必须要扫描表（通常不推荐），那就能保证你需要获取的记录都在一块。</p>
<p>那么如何选择 rowKey 就非常重要。比如说，一个表的 rowKey 就是域名。一个比较好的方式就是将域名进行反转来作为 rowKey（使用 “com.jimbojw.www”，而不要使用 “www.jimbojw.com”），这样，同一个域名下的记录就可以存储在相邻的位置。</p>
<p>继续上面的域名例子，rowKey 为 “mail.jimbojw.com” 行应该与 “www.jimbojw.com” 行更近，而不是 “mail.xyz.com”，如果不把域名反转存储，就会发生这种情况。</p>
<p>需要注意的是，在 HBase / BigTable 中，有序并不意味着值是有序的。除了 rowKey 以外，没有任内容会被排序，在这点上和普通 map 的实现一致。</p>
<h2>多维的</h2>
<p>到目前为止，我们还没有提过任何关于<strong>列</strong>的概念，而是将<strong>表</strong>在概念上当做常规的 map。我是故意这么做的。列和表、base 等词一样，都带有传统关系型数据库多年的情感包袱。</p>
<p>然而，我发现把 HBase 理解为一个多维的 map 会容易很多，map 的 map。给上面的 JSON 再加上一列：</p>
<p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"1"</span> : &#123;</span><br><span class="line">    <span class="attr">"A"</span> : <span class="string">"x"</span>,</span><br><span class="line">    <span class="attr">"B"</span> : <span class="string">"z"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aaaaa"</span> : &#123;</span><br><span class="line">    <span class="attr">"A"</span> : <span class="string">"y"</span>,</span><br><span class="line">    <span class="attr">"B"</span> : <span class="string">"w"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aaaab"</span> : &#123;</span><br><span class="line">    <span class="attr">"A"</span> : <span class="string">"world"</span>,</span><br><span class="line">    <span class="attr">"B"</span> : <span class="string">"ocean"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"xyz"</span> : &#123;</span><br><span class="line">    <span class="attr">"A"</span> : <span class="string">"hello"</span>,</span><br><span class="line">    <span class="attr">"B"</span> : <span class="string">"there"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"zzzzz"</span> : &#123;</span><br><span class="line">    <span class="attr">"A"</span> : <span class="string">"woot"</span>,</span><br><span class="line">    <span class="attr">"B"</span> : <span class="string">"1337"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中你可以看到每个 key 都指向了另一个 map，其中包含着 A 和 B 两个 key。在这里，我们将最上面那层键值对称为<strong>行</strong>。并且在 HBase / BigTable 的术语表中，A 和 B 的映射称之为<strong>列族</strong>。</p>
<p>一个表的列族在表创建的时候就会被创建好，而且后续修改很困难，添加一个新列族的开销同样也很大，所以在创建表的时候应当将后续会用到的所有列族创建好。</p>
<p>好在一个列族可以有任意数量的列。称之为为列限定符（qualifier）或者标签（label）。</p>
<p>下面是我们上面 JSON 例子的子集，这次加入了 qualifier 的维度：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "aaaaa" : &#123;</span><br><span class="line">    "A" : &#123;</span><br><span class="line">      "foo" : "y",</span><br><span class="line">      "bar" : "d"</span><br><span class="line">    &#125;,</span><br><span class="line">    "B" : &#123;</span><br><span class="line">      "" : "w"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "aaaab" : &#123;</span><br><span class="line">    "A" : &#123;</span><br><span class="line">      "foo" : "world",</span><br><span class="line">      "bar" : "domination"</span><br><span class="line">    &#125;,</span><br><span class="line">    "B" : &#123;</span><br><span class="line">      "" : "ocean"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意在上面的两行数据中，A 列族有两列：foo 和 bar，B 列族只有一列，而且 qualifier 是一个空字符串。</p>
<p>当访问 HBase / BigTable 中的数据时，你需要提供完整的列名：<code>&lt;family&gt;:&lt;qualifier&gt;</code>。举个例子，上面总共有三列，分别是：<code>A:foo</code>，<code>A:bar</code> 和 <code>B:</code>。</p>
<p>列族虽然基本固定不变，但是列不是，来看下面的例子：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "zzzzz" : &#123;</span><br><span class="line">    "A" : &#123;</span><br><span class="line">      "catch_phrase" : "woot",</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>zzzzz</code> 行有一个列 A:catch_phrase。因为每一行可以有任意数量的列，所以没有内置方法可以从所有行中的所有列中查询出一个列表。为了获取到那些信息，你需要做全表扫描。但是你可以查询所有的列族，因为它们是不变的（基本不变）。</p>
<p>HBase / BigTable 中最后的一个维度是时间。所有数据默认通过时间戳（1970年以来的秒数）来表示版本，或者你也可以指定一个其他的整数。客户端在插入数据的时候可以指定这个时间戳。</p>
<p>在最新的例子中，我们使用任意的整数来作为版本标识：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "aaaaa" : &#123;</span><br><span class="line">    "A" : &#123;</span><br><span class="line">      "foo" : &#123;</span><br><span class="line">        15 : "y",</span><br><span class="line">        4 : "m"</span><br><span class="line">      &#125;,</span><br><span class="line">      "bar" : &#123;</span><br><span class="line">        15 : "d",</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "B" : &#123;</span><br><span class="line">      "" : &#123;</span><br><span class="line">        6 : "w"</span><br><span class="line">        3 : "o"</span><br><span class="line">        1 : "w"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个列族可以自己指定一个 cell 中的数据可以保留多少个版本（cell 由 rowKey 和列进行标识）。在大多数情况下，应用会直接访问一个 cell 中的数据，而不会指定一个时间戳（版本），HBase / BigTable 会直接返回最近版本（时间戳最大的那个）的数据，因为它是按照时间倒序来存储数据的。</p>
<p>如果应用在请求数据的时候指定了一个时间戳，那么 HBase 就会返回时间戳小于或者等于指定时间戳的一个 cell 中的数据。</p>
<p>如果查询上面例子中的 HBase 表，查询 <code>aaaaa A:foo</code>，就会返回 y，如果带时间戳查询 <code>aaaaa A:foo 10</code>，就会返回 m，如果查询 <code>aaaaa A:foo 2</code>，就会返回 null。</p>
<h2>稀疏的</h2>
<p>最后的一个关键词是<strong>稀疏的</strong>。就如上面所说的，一个给定的行在每个列族中可以有任意数量的列，0 或者任意大。行之间可以存在间隙，这也是另一种稀疏。</p>
<p>如果你一直跟着本文在 map 的基础上来理解 HBase / BigTable，而没有与关系型数据库（RDBMS）的概念混淆，这样就很好了。</p>
<h2>就这些了</h2>
<p>我希望上面说的那些可以帮助你在概念上理解 HBase 的数据模型是什么样的。</p>
<p>像往常一样，我期待你们的想法、评论和建议。</p>
<p>译 / Rayjun</p>
<p>原文地址：https://dzone.com/articles/understanding-HBase-and-bigtab</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做一个区块链浏览器</title>
    <url>/2021/12/19/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<p>对于区块链，所有的数据都是开放的，但不是每个人都能写代码去查看链上的交易，大多数人会通过一个公开的窗口来查看数据。这个公开的窗口就是区块链浏览器。</p>
<p>区块链上的数据会持续增加，对于数据的持久化和查询是浏览器的关键。本文会说明一种区块链浏览器的设计思路。</p>
<h2>1. 系统设计</h2>
<p>当一笔交易上链之后，就会存储到链上的账本中，但是账本中的数据无法直接展示。所以需要对这些账本数据进行解析，并存储，然后再从不同的维度去做对数据进行展示。系统本身并不会很复杂，整体的设计如下：</p>
<p><img src="0.png" alt=""></p>
<p>整个系统做的事情就是将区块链上的数据拉取下来，放到数据库中，然后通过一个 API 服务</p>
<p>在系统中有两个部分很重要，一个是区块的解析器，一个是拉取区块的部分。</p>
<h3>1.1 存储选型</h3>
<p>数据存储的选型很重要，使用 MySQL 存储会带来一些问题，字段扩展困难，存储扩展不方便。除了存储之外，这些数据还需要能够支持多维度的搜索，这点 MySQL 显然也无法满足。</p>
<p>区块链通常使用 kv 数据库做存储，通常是 LevelDB、CauchDB、TiKV 等等，但是这类的数据库，对于搜索的支持比较差。而对于浏览器来说，搜索则是一个最重要的部分。</p>
<p>在这样的情况下， ElasticSearch 是一个很好的选择，ES 支持本身支持大量数据的存储，而且可以支持水平扩展。实时的搜索也能够满足前端数据展示的需要。</p>
<h3>1.2 解析器的设计</h3>
<p>区块链就是一个链状的结构，所有的区块通过计算前一个区块的 hash 连接在一起：</p>
<p><img src="1.png" alt=""></p>
<p>每一个区块中则会打包一系列的交易：</p>
<p><img src="2.png" alt=""></p>
<p>在解析区块的时候，需要不断的将区块层层打开，直到将里面的每一笔交易都解析出来。然后按照不同的分类存储进 ES 中。看起来是一个挺复杂的过程，可以通过设计成单个接口来完成。</p>
<h3>1.3 安全的考虑</h3>
<p>因为浏览器是一个开放的系统，所有人都可以来访问，那么对于系统的安全就需要特别重视，避免有人对系统进行攻击。在这里需要防护的类型有两种：</p>
<ul>
<li>DDOS 攻击</li>
<li>怕有人通过爬虫来爬取系统中的数据</li>
</ul>
<p>在网关层，可以部署一些防火墙，在 API 层，可以使用了 IP 的限制策略，比如限制同一个 IP 在一段时间内的最大访问次数。最大程度上保持浏览器的稳定运行。</p>
<h2>2. 遇到的问题</h2>
<p>完成上面的设计并实现之后，其实已经可以使用了。但发现在实际的使用过程中，还是会出现一些问题。</p>
<h3>2.1 如何处理存量数据</h3>
<p>在拉取区块链的数据时，区块中可能已经存在了很多数据，如果使用单线程去拉取数据，可能会需要很长的时间。既然单个线程拉取区块的速度不够快，那就换成多个线程，于是换成了如下的模式：</p>
<p><img src="3.png" alt=""></p>
<p>这样一来，拉取的速度就快了很多，但是如果链上的数据很多，这种方式还是不太够，</p>
<p>但到这里，其实就没办法再通过增加线程来加快拉取的速度。因为在解析区块的时候，是通过新起一个线程去解析，如果区块拉取的太快，会导致解析的线程数量急剧增加，最后导致程序崩溃。</p>
<p>所以要通过其他的方式来提升拉取速度。</p>
<p>既然单个实例无法继续提升性能，那就通过多个实例来提升，但是这样会引入新的问题，就是怎么在多个实例之间去同步状态。</p>
<p>分析一下就可以发现，很多的中间数据在区块爬取的过程中器是无需统计，比如每分钟产生的区块数和每分钟产生的交易数。其实只需要在多个实例之间去同步区块的高度，让不同的区块去拉取不同的高度。</p>
<p>这里为了减少系统的额外依赖，最后决定使用 MySQL 的悲观锁来同步区块高度，为了减少加锁的频率，降低获取锁的次吃。在同步高度的时候，会一次性去取一批高度，比如获取了 10 个高度，直接把 MySQL 中的高度更新 10。</p>
<p>因为每个实例中本身就有多个线程在拉取数据，避免每个线程在拉取的时候都来获取一个高度。就通过在实例中线程的数量来获取区块高度，比如线程的数量是 10，那就直接在 MySQL 中抢占 10 个高度，然后同时去拉取。</p>
<p><img src="4.png" alt=""></p>
<p>这样处理之后，拉取区块速度就大大提升了。拉取线上 5 千万的存量数据大概只需要 5 天左右的时间，这样是完全可以接受的。</p>
<p>存量数据拉取完成之后，就可以恢复到单实例，多线程的拉取模式，这样更能节省资源。</p>
<h3>2.2 区块处理失败</h3>
<p>在拉取区块的过程中，有可能会有各种原因导致区块拉取失败。这个时候需要对处理失败的区块重新处理。</p>
<p>在这里的设计中，通过一种比较简单的方式进行处理，把处理的失败的区块放到一个失败中，然后会有一个线程去监听这个失败队列，从其中获取高度重新处理。</p>
<h2>3. 读写分离</h2>
<p>但是到目前为止，这个浏览器还称不上完美。现在区块的解析和拉取区块是绑定在一起的，es 写入的错误也会导致整个的区块拉取失败。不得不通过重试的方式来完成拉取。这样会影响整体的拉取速度。</p>
<p>随着区块链的业务越来越多，产生区块的速度也越来越快。当前的的这种拉取的方式有可能无法跟上区块的拉取速度。所以需要引入消息队列来让区块和区块的解析两部分功能彻底解耦，就像下面这样。</p>
<p><img src="5.png" alt=""></p>
<p>这样将区块的拉取和解析互相不阻塞，系统也会更加稳定。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 Go 服务中做链路追踪</title>
    <url>/2021/08/30/%E5%A6%82%E4%BD%95%E5%9C%A8-Go-%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%81%9A%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<p>使用 Go 语言开发微服务的时候，需要追踪每一个请求的访问链路，这块在 Go 中目前没有很好的解决方案。</p>
<p>在 Java 中解决这个问题比较简单，可以使用 MDC，在一个进程内共享一个请求的 RequestId。</p>
<p>在 Go 中实现链路追踪有两种思路：一种是在项目中使用一个全局的 map， key 是 goroutine 的唯一 Id，value 是 RequestId，另一种思路可以使用 context.Context 来实现。</p>
<p>下面的代码基于 gin 框架来实现。</p>
<h2>1. 使用全局 map 来实现</h2>
<p>使用 map 方案需要在全局维护一个 map，在一个请求进来的时候，会为每一个请求生成 RequestId，然后在每次在打印日志的时候，从这个 Map 中通过 goid 获取到 RequestId，打印到日志中。</p>
<p>代码的实现很简单：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> requestIdMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">string</span>) <span class="comment">// 全局的 Map</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.Use(Logger()) <span class="comment">// 使用中间件</span></span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		Info(<span class="string">"main goroutine"</span>) <span class="comment">// 打印日志</span></span><br><span class="line"></span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"index"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logger</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		requestIdMap[goid.Get()] = uuid.New().String() <span class="comment">// 在日志中间件中为每个请求设定</span></span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Info</span><span class="params">(msg <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	nowStr := now.Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%s [%s] %s\n"</span>, nowStr, requestIdMap[goid.Get()], msg) <span class="comment">// 打印日志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的实现很简单，但是问题也很多。</p>
<p>第一个问题就是，在 Go 程序中，一次请求可能会涉及到多个 goroutine，用这种方式很难在多个 gotoutine 之间传递 RequestId。</p>
<p>在下面的代码中，如果新启动了一个 goroutine，就会导致日志中获取不到 RequestId：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.Use(Logger())</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		Info(<span class="string">"main goroutine"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  <span class="comment">// 这里新启动了一个一个 goroutine</span></span><br><span class="line">			Info(<span class="string">"goroutine1"</span>)</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"index"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取 goroutine id 也不是一种常规的做法，一般要通过 hack 的方式来获取，这种做法已经不推荐了。而且这个全局的 map 为了并发安全，在实际的使用中，可以还需要用到锁，在高并发的情况下必然会影响性能。</p>
<p>在每个请求结束的时候，还需要手动的把 requestId 从 map 中删除，否则就会造成内存泄漏。</p>
<p>总的来说，使用 map 这种方式来实现并不是很好。</p>
<h2>2. 使用 Context 来实现</h2>
<p>在上面的代码中，我们使用一个 hack 的方式去获取 goroutine id，这种方式早就不推荐使用，更推荐使用 Context，关于 Context 内容，可以去看我之前的文章，在这里就不多说了。</p>
<p>在传递 RequestId 的场景中，同样也可以使用 Context 来实现，使用 Context 好处很明显，Context 生命周期与请求相同，不需要手动销毁。而且Context 是每个请求独享的，也不用担心并发安全的问题，Context 还可以在 goroutine 之间传递。</p>
<p>使用 Context 实现的代码如下：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.Use(Logger())</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">		ctx, _ := c.Get(<span class="string">"ctx"</span>)</span><br><span class="line"></span><br><span class="line">		Info(ctx.(context.Context) , <span class="string">"main goroutine"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			Info(ctx.(context.Context), <span class="string">"goroutine1"</span>)</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"index"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logger</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		valueCtx := context.WithValue(c.Request.Context(), <span class="string">"RequestId"</span>, uuid.New().String())</span><br><span class="line">		c.Set(<span class="string">"ctx"</span>, valueCtx)</span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Info</span><span class="params">(ctx context.Context, msg <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	nowStr := now.Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%s [%s] %s\n"</span>, nowStr, ctx.Value(<span class="string">"RequestId"</span>), msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样在一个请求中，所有的 gotroutine 都可以获取到同一个 RequestId，而且不用担心内存泄漏和并发安全。</p>
<p>但是使用 Context 也有个问题就是需要每次传递 Context，很多人还不习惯使用这种方式。其实 Go 官方早就推荐使用 Context了，通常会把 Context 作为函数的第一个参数。如果函数使用结构体作为参数，也可以直接把 Context 作为结构体的一个字段。</p>
<p>Context 除了使用可以同来传递 RequestId 之外，还可以用来控制 goroutine 的生命周期，这些内容在之前的 Context 文章中详细说明了，感兴趣的可以去看看。</p>
<h2>3. 小结</h2>
<p>获取 goroutine id 这种方式应该被抛弃，而是应该使用 Context, Go 官方也早就推荐使用这种方式，在上文中，我们使用 Context 来传递 RequestId，除此之外还可以用来传递单个请求范围的值，比如认证的 token 之类的，应该习惯在代码中使用 Context。</p>
<p>[1] <a href="https://blog.golang.org/context" target="_blank" rel="noopener">https://blog.golang.org/context</a></p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个Hadoop集群</title>
    <url>/2020/06/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAHadoop%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>在学习大数据系统时，搭建一个 Hadoop 是基本的操作，很多大数据上层的应用都依赖 HDFS，本文介绍一种搭建 Hadoop 集群的方法。</p>
<p>所需软件及环境如下：</p>
<ul>
<li>本地服务器集群</li>
<li>openjdk1.8</li>
<li>hadoop-2.9.2</li>
</ul>
<p>在之前我写过一篇搭建本地服务器集群的方法，如果有需要，可以参考这里搭建一个本地的服务器集群。</p>
<h2>环境准备</h2>
<p>在开始搭建 Hadoop 之前，还需要做一些准备。</p>
<p>首先，关闭服务器的防火墙，并且禁止开机启动，这样就不用在各个服务器上对端口进行控制。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl stop firewalld.service</span><br><span class="line">$ systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure></p>
<p>然后需要定义一下服务器的 hostname，在集群内，直接使用 hostname 来替代机器进行操作，以 IP 为 192.168.56.3 的服务器为例（这是我的服务器集群的地址，具体看自己集群的 IP 配置）：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/sysconfig/network</span><br><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=bigdata1</span><br><span class="line">GATEWAY=192.168.56.2</span><br></pre></td></tr></table></figure></p>
<p>同样编辑另外两台服务器，起名为 bigdata2 和 bigdata3。</p>
<p>然后编辑各个服务器的 <code>/etc/hosts</code> 文件，添加 hostname 到 IP 的映射：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/hosts</span><br><span class="line">192.168.56.3 bigdata1</span><br><span class="line">192.168.56.4 bigdata2</span><br><span class="line">192.168.56.5 bigdata3</span><br></pre></td></tr></table></figure></p>
<p>最后，为了在宿主机上可以方便的访问各个服务器，同样也要编辑宿主机的 hosts 文件：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/hosts</span><br><span class="line"></span><br><span class="line">192.168.56.3 bigdata1</span><br><span class="line">192.168.56.4 bigdata2</span><br><span class="line">192.168.56.5 bigdata3</span><br></pre></td></tr></table></figure></p>
<p>到这里，服务器集群的配置就完成了，接下来就开始配置 Hadoop 环境。</p>
<p>Hadoop 也依赖 Java 环境，所以首先需要配置 JDK，本文使用的是 openjdk1.8。</p>
<p>本文所有的软件都会安装到 <code>/opt/module</code> 目录下，如果没有这个目录，创建一个。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir /opt/module</span><br></pre></td></tr></table></figure></p>
<p>可以将下载好的 jdk 通过 scp 命令从宿主机拷贝到 服务器，然后解压到目标目录：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf openjdk-8u41-b04-linux-x64-14_jan_2020.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure></p>
<p>解压完成后再配置环境变量：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#Java config</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/module/java-se-8u41-ri</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br><span class="line"></span><br><span class="line">Openjdk version <span class="string">"1.8.0_41"</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_41-b04)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.40-b25, mixed mode)</span><br></pre></td></tr></table></figure></p>
<p>JDK 配置完成。</p>
<p>然后同样将 scp 命令将 hadoop 安装包拷贝到服务器，解压到 /opt/module 目录中：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf hadoop-2.9.2.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure></p>
<p>同样配置环境目录</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/profile</span><br><span class="line"><span class="comment">#Hadoop config</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/opt/module/hadoop-2.9.2</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/sbin</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hadoop version</span><br><span class="line">Hadoop 2.9.2</span><br><span class="line">Subversion https://git-wip-us.apache.org/repos/asf/hadoop.git -r 826afbeae31ca687bc2f8471dc841b66ed2c6704</span><br><span class="line">Compiled by ajisaka on 2018-11-13T12:42Z</span><br><span class="line">Compiled with protoc 2.5.0</span><br><span class="line">From <span class="built_in">source</span> with checksum 3a9939967262218aa556c684d107985</span><br><span class="line">This <span class="built_in">command</span> was run using /opt/module/hadoop-2.9.2/share/hadoop/common/hadoop-common-2.9.2.jar</span><br></pre></td></tr></table></figure></p>
<p>hadoop 的安装完成，到这里，单台机器的软件已经安装完成。</p>
<p>如果每台机器都要这样配置就太繁琐了，可以利用 rsync 将安装好的软件直接拷贝到其他的机器，这里当然也可以使用 scp 命令进行拷贝，但是 scp 命令每次都是全量拷贝，在文件很多时，拷贝的速度会很慢，而 rsync 是增量拷贝，只拷贝那些被修改了的文件，所以拷贝的速度会很快。</p>
<p>如果系统上，没有这个软件，就使用以下命令进行安装：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install rsync</span><br></pre></td></tr></table></figure></p>
<p>安装完成后利用 rsync 将安装好的软件同步到另外两台服务器：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rsync -rvl /opt/module/ root@bigdata2:/opt/module</span><br><span class="line">$ rsync -rvl /opt/module/ root@bigdata3:/opt/module</span><br></pre></td></tr></table></figure></p>
<p>然后分别配置环境变量（其实 /etc/profile 文件也可以被同步到另外的服务器，这里为了演示，就没有直接同步过去）：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/profile</span><br><span class="line"><span class="comment">#Java config</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/module/java-se-8u41-ri</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#Hadoop config</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/opt/module/hadoop-2.9.2</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/sbin</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></p>
<p>到这里，所有软件安装完成。</p>
<h2>集群规划</h2>
<p>基础环境配置完成后，需要对集群中服务器做规划，让每台服务器承担不同的角色。</p>
<p>具体规划如下，最重要的 NameNode 放在第一台服务器上，yarn 的 ResourceManager 放在 第二台服务器上，SecondaryNamenode 则放在第三台服务器上。</p>
<p>具体规划如下：</p>
<p><img src="jiqunguihua.jpg" alt=""></p>
<h2>集群配置</h2>
<p>然后就可以根据上面的规划来配置集群，以 IP 为 192.168.56.3 的服务器为例。</p>
<p>Hadoop 的所有配置文件都在 <code>etc/hadoop</code> 目录下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /opt/module/hadoop-2.9.2/etc/hadoop</span><br></pre></td></tr></table></figure></p>
<p>首先配置 Hadoop 的核心文件，打开 <code>core-site.xml</code>，添加如下配置，确定 NameNode 所在的服务器：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi core-site.xml</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://bigdata1:9000&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/opt/module/hadoop-2.9.2/data/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后打开 <code>[hadoop-env.sh](http://hadoop-env.sh)</code> 配置 JDK:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi hadoop-env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/module/java-se-8u41-ri/</span><br></pre></td></tr></table></figure></p>
<p>然后接着配置 HDFS 相关，配置每个文件的保存的份数，同时配置 SecondaryNameNode 所在的服务器，编辑 <code>hdfs-site.xml</code>文件:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi hdfs-site.xml</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;bigdata3:50090&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后就开始配置 yarn：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi yarn-env.sh</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/module/java-se-8u41-ri/</span><br></pre></td></tr></table></figure></p>
<p>确定mapreduce 所用的算法，以及确定 ResourceManager 所在的服务器，编辑 <code>yarn-site.xml</code>:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi yarn-site.xml</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;bigdata2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后配置一下 mapreduce:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi mapred-env.sh</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/module/java-se-8u41-ri/</span><br></pre></td></tr></table></figure></p>
<p>配置 mapreduce 任务在通过 yarn 来调度：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp mapred-site.xml.template mapred-site.xml</span><br><span class="line">$ vi mapred-site.xml</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p>
<p>最后还要做一个集群的配置，让各个服务器知道这个集群中有哪些服务器：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi slaves</span><br><span class="line">bigdata1</span><br><span class="line">bigdata2</span><br><span class="line">bigdata3</span><br></pre></td></tr></table></figure></p>
<p>然后将配置同步到另外两台机器：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rsync -rvl /opt/module/hadoop-2.9.2/ root@bigdata2:/opt/module/hadoop-2.9.2</span><br><span class="line">$ rsync -rvl /opt/module/hadoop-2.9.2/ root@bigdata3:/opt/module/hadoop-2.9.2</span><br></pre></td></tr></table></figure></p>
<p>所有的配置到这里就完成了。</p>
<h2>集群操作</h2>
<p>接下来启动集群，首次启动集群需要对 NameNode 进行格式化：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /opt/module/hadoop-2.9.2</span><br><span class="line">$ bin/hdfsnamenode-format</span><br></pre></td></tr></table></figure></p>
<p>然后启动 hdfs，要在第一台服务器(IP: 192.168.56.3) 上启动：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></p>
<p>然后启动 yarn，在第二台服务器（IP：192.168.56.4）上启动：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sbin/start-yarn.sh</span><br></pre></td></tr></table></figure></p>
<p>然后访问 http://192.168.56.5:50090/，如果看到如下的的界面，说明集群就启动成功了。</p>
<p><img src="hadoop.png" alt=""></p>
<p>停止集群时通过如下命令停止就可以了：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sbin/stop-yarn.sh</span><br><span class="line">$ sbin/stop-dfs.sh</span><br></pre></td></tr></table></figure></p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个HBase集群</title>
    <url>/2020/07/11/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAHBase%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>在大数据集群中，HDFS 是基础设施，所以搭建环境会有一些麻烦，HBase 作为上层应用，搭建会简单很多。</p>
<p>本文介绍一种搭建 HBase 集群的方式。</p>
<p>搭建 HBase 集群所需的软件和环境：</p>
<ul>
<li>搭建了 HDFS 和 Zookeeper 集群的环境</li>
<li>HBase-1.6.0</li>
</ul>
<p>对于搭建 HDFS 和 Zookeeper 集群，可以参照我之前的文章。</p>
<p>本文继续在之前的环境中进行，具体的机器名称及 IP 以自己的实际环境为准。</p>
<h2>软件安装</h2>
<p>将 HBase 安装包拷贝到 bigdata1（192.168.56.3）虚拟机中，然后解压到目标目录下</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf hbase-1.6.0-bin.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure></p>
<p>并将目录改名：</p>
<p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">$ cd /opt/<span class="built_in">module</span></span><br><span class="line">$ mv hbase<span class="number">-1.6</span><span class="number">.0</span>-bin hbase<span class="number">-1.6</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></p>
<h2>软件配置</h2>
<p>进入到 hbase 目录之后，开始配置 HBase 的环境，首先需要配置 JDK 环境，然后要禁用 HBase 中自带的 zookeeper，在后面会与我们之前就配置好的 zookeeper 集群进行集成。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /opt/module/hbase-1.6.0</span><br><span class="line">$ vi conf/hbase-evn.sh</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/module/java-se-8u41-ri/</span><br><span class="line"><span class="built_in">export</span> HBASE_MANAGES_ZK=<span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>接下来需要配置 hbase-site.xml 文件，这是 HBase 的核心配置文件：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi conf/hbase-site.xml</span><br></pre></td></tr></table></figure></p>
<p>首先需要配置 hdfs 的地址，并且要把 HBase 配置为分布式模式，然后在配置好 HBase 的端口号。</p>
<p>再接下来需要配置好 zookeeper 的地址，上面说到了要禁用 HBase 自带的 zookeeper。</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://bigdata1:9000/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.master.port<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>16000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>bigdata1:2181,bigdata2:2181,bigdata3:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/apache-zookeeper-3.6.1/zkData/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来需要配置 HBase 集群的机器，编辑 regionservers 文件，将三台虚拟机的名称填充进去：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ vi regionservers</span><br><span class="line">bigdata1</span><br><span class="line">bigdata2</span><br><span class="line">bigdata3</span><br></pre></td></tr></table></figure></p>
<p>HBase 需要依赖 hdfs 作为底层存储，在 Hbase的配置中，还需要依赖 hadoop 的配置文件，当然也可以直接将配置文件拷贝过来，但是使用软连接是一种更加合理的方式。</p>
<p>下面软连接 hadoop 配置文件到 hbase：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ ln -s /opt/module/hadoop-2.9.2/etc/hadoop/core-site.xml /opt/module/hbase-1.6.0/conf/core-site.xml</span><br><span class="line">$ ln -s /opt/module/hadoop-2.9.2/etc/hadoop/hdfs-site.xml /opt/module/hbase-1.6.0/conf/hdfs-site.xml</span><br></pre></td></tr></table></figure></p>
<p>到这里，HBase 的配置基本就完成了，然后将配置好的HBase 同步到另外两台虚拟机上：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ rsync -rvl /opt/module/hbase-1.6.0/ root@192.168.56.4:/opt/module/hbase-1.6.0</span><br><span class="line">$ rsync -rvl /opt/module/hbase-1.6.0/ root@192.168.56.5:/opt/module/hbase-1.6.0</span><br></pre></td></tr></table></figure></p>
<h2>启动集群</h2>
<p>配置完成之后，就可以来启动 HBase 集群了，输入以下命令：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ bin/start-hbase.sh</span><br></pre></td></tr></table></figure></p>
<p>如果正常启动的话，就可以通过 <a href="http://hadoop102:16010/" target="_blank" rel="noopener">http://bigdata1:16010</a> 来进入到 HBase 的管理页面</p>
<p>如果要停止 HBase 集群的话，使用下面的命令就可以。</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ bin/stop-hbase.sh</span><br></pre></td></tr></table></figure></p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个Zookeeper集群</title>
    <url>/2020/07/04/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAZookeeper%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>Zookeeper 在分布式系统中被用来同步各个服务器节点之间的状态，也可以用作服务发现，在各种分布式系统中，有很广泛的应用。</p>
<p>本文介绍一种搭建 Zookeeper 集群的方法。</p>
<p>和大多数分布式系统一样，Zookeeper 适合部署在节点为奇数的服务器集群中。</p>
<p>Zookeeper 的部署的环境和软件要求为：</p>
<ul>
<li>本地服务集群</li>
<li>openjdk8</li>
<li>zookeeper-3.4.14</li>
</ul>
<p>本文使用之前配置好的的本地虚拟机集群，如果有配置服务器集群的需求，可以参照我之前关于搭建服务器集群文章。</p>
<h2>软件安装</h2>
<p>软件安装相对简单，只需要将 Zookeeper 解压到 /opt/module （对这块有疑问的可以去看我之前的文章），并把目录更名为 <code>apache-zookeeper-3.6.1</code>。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf apache-zookeeper-3.6.1-bin.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure></p>
<h2>集群配置</h2>
<p>在 apache-zookeeper-3.6.1 目录中创建一个 <code>zkData</code> 目录，这里面用来存放服务运行中产生的数据以及集群的配置</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p zkData</span><br></pre></td></tr></table></figure></p>
<p>进入到 <code>conf</code> 目录，将 <code>zoo_sample.cfg</code> 改名为 <code>zoo.cfg</code></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> conf</span><br><span class="line">$ cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></p>
<p>然后编辑 zoo.cfg 文件，将 <code>dataDir</code> 配置为刚才创建好的 zkData 目录</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi zoo.cfg</span><br><span class="line">dataDir=/opt/module/apache-zookeeper-3.6.1/zkData</span><br></pre></td></tr></table></figure></p>
<p>然后将配置好的软件同步到另外两个服务器</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rsync -rvl /opt/module/apache-zookeeper-3.6.1/ root@192.168.56.4:/opt/module/apache-zookeeper-3.6.1</span><br><span class="line">$ rsync -rvl /opt/module/apache-zookeeper-3.6.1/ root@192.168.56.5:/opt/module/apache-zookeeper-3.6.1</span><br></pre></td></tr></table></figure></p>
<p>还有最后一步，需要在三台机器上分别执行，以 192.168.56.3 机器为例，进入 zkData 目录，然后创建 <code>myid</code> 文件，文件中随便填入一个数字，只要别与另外两台机器重复</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> zkData</span><br><span class="line">$ touch myid</span><br></pre></td></tr></table></figure></p>
<p>然后再编辑 zoo.cfg，在配置文件中加上如下内容，需要注意 <code>server</code> 后面的数字需要与每台服务器中 myid 文件中的数字相同，然后配置好机器名称以及选举时需要用到的的端口号</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> conf</span><br><span class="line">$ vi zoo.cfg</span><br><span class="line">server.3=bigdata1:2888:3888</span><br><span class="line">server.4=bigdata2:2888:3888</span><br><span class="line">server.5=bigdata3:2888:3888</span><br></pre></td></tr></table></figure></p>
<p>bigdata1，bigdata2，bigdata3 是三台机器的别名，在 <code>/etc/hosts</code> 文件中定义。</p>
<p>在另外两台机器上分别编辑 myid 和 zoo.cfg，myid 中的内容不能相同。</p>
<p>到这里，配置工作就完成了。</p>
<h2>运行验证</h2>
<p>配置完成后，在三台机器上分别执行：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bin/zkServer.sh start</span><br></pre></td></tr></table></figure></p>
<p>如果没有报错，那么三台机器上的 Zookeeper 服务应该启动了，在启动前，我们无法确定那台服务器是 <code>leader</code>，哪台服务器是 <code>follower</code> ，这会根据当时服务器的状态自动选举产生。</p>
<p>启动后，可以来查看机器状态：</p>
<p>bigdata1: 可以看到这是一个从节点</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/module/apache-zookeeper-3.6.1/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure></p>
<p>bigdata2: 这也是一个从节点</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/module/apache-zookeeper-3.6.1/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure></p>
<p>bigdata3：这是一台主节点</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/module/apache-zookeeper-3.6.1/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: leader</span><br></pre></td></tr></table></figure></p>
<p>在确认集群启动之后，就可以通过客户端来连接集群，除了下面使用的命令行客户端之外，还可以使用各种编程语言的客户端。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bin/zkCli.sh</span><br></pre></td></tr></table></figure></p>
<p>连接进入集群后，通过 <code>ls /</code> 来查看集群的根节点，默认情况下，只有一个空的 zookeeper 节点</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls /</span><br><span class="line">[zookeeper]</span><br></pre></td></tr></table></figure></p>
<p>创建一个名称为 ray 的节点，里面的内容是 <code>rayjun</code></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ create /ray <span class="string">"rayjun"</span></span><br></pre></td></tr></table></figure></p>
<p>通过 get 命令来查看 ray 节点下的内容</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ get /ray</span><br><span class="line">rayjun</span><br></pre></td></tr></table></figure></p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式 大数据 zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写 Go 代码</title>
    <url>/2021/03/06/%E5%A6%82%E4%BD%95%E5%86%99-Go-%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>在学完 Go 的语法之后，就可以开始写代码了，但一个项目中不可能只有几个代码文件，而是由很多代码组成，下面这篇文章将告诉你如何组织这些 Go 代码。</p>
<p>原文地址：<a href="https://golang.org/doc/code" target="_blank" rel="noopener">https://golang.org/doc/code</a></p>
<hr>
<h2>写在前面</h2>
<p>这篇文档演示了基于 Go Modules（模块） 的包的开发流程，并介绍了获取、构建和安装 Go 模块、包、命令时使用的 <a href="https://golang.org/cmd/go/" target="_blank" rel="noopener">Go 工具</a>。</p>
<p>注意：这篇文章会假设你在使用 Go1.13或更高版本，并且没有设置 GO111MODULE 环境变量。如果需要是使用 Go Modules 的版本，看<a href="https://golang.org/doc/gopath_code.html" target="_blank" rel="noopener">这里</a>。</p>
<h2>组织代码</h2>
<p>Go 代码是通过 package（包） 来组织。包是同一目录下所有源文件的集合，它们会被编译在一起。一个源文件中定义的函数、类型、变量和常量对同一个包下的其他源文件都是可见的。</p>
<p>一个 repository（仓库）中包含一个或多个 module（模块）。模块由多个相关的包组成，并且会一起发布。一个仓库中通常只会包含一个模块，这个模块位于仓库的根目录。go.mod 中会声明模块路径，该模块中的所有包再被导入的时候，到会把这个路径当做前缀加上。一个模块的范围是从包含 go.mod 的文件夹及文件夹中所有的文件夹（包括所有的子文件夹），到那些包含了 go.mod 的子文件夹（如果有的话）为止。</p>
<p>在代码可以编译之前，你不需要把代码推送到远程的仓库。模块可以不属于任何残酷，仅仅在本地定义。把要发布的代码组织好是一个好习惯。</p>
<p>每个模块的路径不仅仅用于作为导入包的前缀，在使用 go 命令下载包的时候也需要用到。比如，为了下载 <a href="http://golang.org/x/tools" target="_blank" rel="noopener">golang.org/x/tools</a> 模块，go 命令就会找到 <a href="https://golang.org/x/tools" target="_blank" rel="noopener">https://golang.org/x/tools</a>（详情看<a href="https://golang.org/cmd/go/#hdr-Relative_import_paths" target="_blank" rel="noopener">这里</a>）。</p>
<p>导入路径是用来导入包的字符串。一个包的导入路径就是模块的路径加上这个包在模块中的子目录路径。比如模块 github.com/google/go-cmp 包含一个包，在 cmp 目录下。那么这个包的导入路径就是 github.com/google/go-cmp/cmp。标准库中的包没有模块路径前缀。</p>
<h2>你的第一个程序</h2>
<p>在编译和运行一个简单程序之前，要选择一个模块路径（在这里用 example.com/user/hello）并且创建一个 go.mod 文件来描述这个模块：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir hello <span class="comment"># 可选，如果已经存在，直接把项目拉取到本地</span></span><br><span class="line">$ <span class="built_in">cd</span> hello</span><br><span class="line">$ go mod init example.com/user/hello</span><br><span class="line">go: creating new go.mod: module example.com/user/hello</span><br><span class="line">$ cat go.mod</span><br><span class="line">module example.com/user/hello</span><br><span class="line"></span><br><span class="line">go 1.14</span><br></pre></td></tr></table></figure></p>
<p>Go 源文件的第一个语句必须是<strong>包名</strong>。可执行的文件必须使用 <strong>main</strong> 作为包名。</p>
<p>接下来，在当前目录下创建一个 hello.go 文件，写入以下代码：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello, world."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在你可以使用 go 命令来编译并安装这个程序：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install example.com/user/hello</span><br></pre></td></tr></table></figure></p>
<p>这个命令将会编译 <strong>hello</strong> 程序，产生一个可执行文件。这个命令会被安装为 <code>$HOME/go/bin/hello</code>（在 Windows 系统中，路径是 <code>%USERPROFILE%\go\bin\hello.exe</code>）。</p>
<p>安装的目录通过 GOPATH 和 GOBIN 环境变量来控制。如果 GOBIN 设置了，就会安装到 GOBIN 指定的目录。如果 GOPATH 设置了，这个就会安装到 GOPATH 目录下的子目录 bin 中。否则就会被安装到默认的 GOPATH 子目录下 bin 下（$HOME/go 或者 %USERPROFILE%\go）。</p>
<p>你可以使用 <code>go env</code>命令来设置环境变量的默认值：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go env -w GOBIN=/somewhere/<span class="keyword">else</span>/bin</span><br></pre></td></tr></table></figure></p>
<p>使用  <code>go env -u</code> 删除 go env -w 设置的变量值：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go env -u GOBIN</span><br></pre></td></tr></table></figure></p>
<p>像 <code>go install</code> 这样的命令可以在模块的根目录及其子目录中使用。如果当前的工作目录不在 example.com/user/hello 模块中，go install 会失败。</p>
<p>为了方便起见，go 命令接受工作目录的相对路径，如果没有给出其他路径，则默认为当前工作目录下的包。因此，在我们的工作目录中，以下命令都是等价的:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install example.com/user/hello</span><br><span class="line"></span><br><span class="line">$ go install .</span><br><span class="line"></span><br><span class="line">$ go install</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们来运行一下这个程序，确保功能正常。为了使用方便，我们把安装目录增加到系统 PATH 路径下，这样就可以直接在命令行使用程序:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># windows 用户看这里： https://github.com/golang/go/wiki/SettingGOPATH</span></span><br><span class="line"><span class="comment"># 设置 %PATH%.</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:$(dirname $(go list -f <span class="string">'&#123;&#123;.Target&#125;&#125;'</span> .))</span><br><span class="line">$ hello</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure></p>
<p>如果你在用版本管理系统，现在就可以初始化仓库，添加文件，并提交第一次修改。这个步骤是可选的，在写代码的时候，不一定要使用版本管理系统：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/user/hello/.git/</span><br><span class="line">$ git add go.mod hello.go</span><br><span class="line">$ git commit -m <span class="string">"initial commit"</span></span><br><span class="line">[master (root-commit) 0b4507d] initial commit</span><br><span class="line"> 1 file changed, 7 insertion(+)</span><br><span class="line"> create mode 100644 go.mod hello.go</span><br></pre></td></tr></table></figure></p>
<p>go 命令通过请求相应的 HTTPS URL 并读取 HTML 响应中的元数据来定位给定模块的存储库（参见 <a href="https://golang.org/cmd/go/#hdr-Remote_import_paths" target="_blank" rel="noopener">go help importpath</a>）。许多代码托管服务已经为包含 Go 代码的存储库提供了元数据，因此，为了让你的模块可以顺利的被人找到，直接使用存储库的 URL 作为你的模块路径。</p>
<h3>导入当前模块内的包</h3>
<p>让我们写一个 <code>morestrings</code> 包并在 hello 程序中使用它。首先，为这个包创建一个目录：$HOME/hello/morestrings，并创建一个 reverse.go 文件，填充下面的内容：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package morestrings implements additional functions to manipulate UTF-8</span></span><br><span class="line"><span class="comment">// encoded strings, beyond what is provided in the standard "strings" package.</span></span><br><span class="line"><span class="keyword">package</span> morestrings</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReverseRunes returns its argument string reversed rune-wise left to right.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseRunes</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	r := []<span class="keyword">rune</span>(s)</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		r[i], r[j] = r[j], r[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为我们的 ReverseRunes 方法以大写字母开头，所以它是导出的，可以在其他的包中导入 morestrings 包来使用.</p>
<p>使用 go build 命令编译测试一下这个包：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$HOME</span>/hello/morestrings</span><br><span class="line">$ go build</span><br></pre></td></tr></table></figure></p>
<p>这不会产生输出文件，相反，它将已编译的包保存在本地构建缓存中。</p>
<p>在确认 morestrings 是可编译的，就可以在 hello 程序中使用它。然后修改 $HOME$/hello/hello.go 来使用 morestrings 包：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"example.com/user/hello/morestrings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(morestrings.ReverseRunes(<span class="string">"!oG ,olleH"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>安装 hello 程序：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install example.com/user/hello</span><br></pre></td></tr></table></figure></p>
<p>运行这个新版的程序，你应该可以看见一个反转的字符串：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hello</span><br></pre></td></tr></table></figure></p>
<h3>导入远程模块的包</h3>
<p>导入路径可以使用版本管理系统（如 Git 或 Mercurial）获取源码，go 工具会自动从远程仓库获取包。例如，在程序中使用 github.com/google/go-cmp/cmp：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"example.com/user/hello/morestrings"</span></span><br><span class="line">	<span class="string">"github.com/google/go-cmp/cmp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(morestrings.ReverseRunes(<span class="string">"!oG ,olleH"</span>))</span><br><span class="line">	fmt.Println(cmp.Diff(<span class="string">"Hello World"</span>, <span class="string">"Hello Go"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当你运行 go install，go build，或者 go run 等命令时，就会自动下载这些远程的模块并记录到 go.mod 文件中：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install example.com/user/hello</span><br><span class="line">go: finding module <span class="keyword">for</span> package github.com/google/go-cmp/cmp</span><br><span class="line">go: downloading github.com/google/go-cmp v0.4.0</span><br><span class="line">go: found github.com/google/go-cmp/cmp <span class="keyword">in</span> github.com/google/go-cmp v0.4.0</span><br><span class="line">$ hello</span><br><span class="line">Hello, Go!</span><br><span class="line">  string(</span><br><span class="line">- 	<span class="string">"Hello World"</span>,</span><br><span class="line">+ 	<span class="string">"Hello Go"</span>,</span><br><span class="line">  )</span><br><span class="line">$ cat go.mod</span><br><span class="line">module example.com/user/hello</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require github.com/google/go-cmp v0.4.0</span><br></pre></td></tr></table></figure></p>
<p>模块依赖关系会自动下载到 GOPATH 下的 pkg/mod 子目录。某个模块的给定版本的下载内容在所有需要该版本的其他模块之间共享，因此 go 命令将这些文件和目录定义为只读。如果要删除这些下载的模块，可以使用：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go clean -modcache</span><br></pre></td></tr></table></figure></p>
<h3>测试</h3>
<p>Go 有一个轻量级的测试框架，包含 <code>go test</code> 命令和 <code>testing</code> 包。</p>
<p>测试文件的结尾必须以 <code>_test.go</code> 结尾，并且测试函数的名称都是 TestXXX，方法签名是 func(t *testing.T)。测试框架会运行每一个函数，如果函数调用了t.Error 或者 t.Fail 函数，那么这个测试就可以被认为失败。</p>
<p>为 morestrings 添加一个测试 $HOME/hello/morestrings/reverse_test.go，写入以下代码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> morestrings</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverseRunes</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		in, want <span class="keyword">string</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;<span class="string">"Hello, world"</span>, <span class="string">"dlrow ,olleH"</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"Hello, 世界"</span>, <span class="string">"界世 ,olleH"</span>&#125;,</span><br><span class="line">		&#123;<span class="string">""</span>, <span class="string">""</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		got := ReverseRunes(c.in)</span><br><span class="line">		<span class="keyword">if</span> got != c.want &#123;</span><br><span class="line">			t.Errorf(<span class="string">"ReverseRunes(%q) == %q, want %q"</span>, c.in, got, c.want)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 go test 来运行测试：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/user/morestrings 0.165s</span><br></pre></td></tr></table></figure></p>
<p>运行 <code>go help test</code> 或者查看<a href="https://golang.org/pkg/testing/" target="_blank" rel="noopener">文档</a>来看更多细节。</p>
<p>译 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建Hive环境</title>
    <url>/2020/07/12/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAHive%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>Hive 是一个 Hadoop 平台的上的数据仓库工具，可以将结构化的的诗句映射成一张表，并提供了类似 SQL 的查询的功能。</p>
<p>HIve 没有集群的概念，只需要将 Hive 部署在 Hadoop 平台上就可以使用。</p>
<p>本文来介绍一种搭建 Hive 环境的方式。</p>
<p>搭建 Hive 所需的软件和环境：</p>
<ul>
<li>搭建了 Hadoop 集群的环境</li>
<li>Hive-1.2.2</li>
</ul>
<p>搭建 Hadoop 集群可以参照我之前的文章，本文继续在之前的环境中进行，具体的机器名称及 IP 以自己的实际环境为准。</p>
<h2>软件安装</h2>
<p>将 Hive 安装包解压到目标目录下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf apache-hive-1.2.2-bin.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure></p>
<p>然后将 hive 目录重命名：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mv apache-hive-1.2.2-bin/ hive-1.2.2</span><br></pre></td></tr></table></figure></p>
<h2>软件配置</h2>
<p>需要配置 hive 的环境参数：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hive-1.2.2</span><br><span class="line">$ cp conf/hive-env.sh.template conf/hive-env.sh</span><br></pre></td></tr></table></figure></p>
<p>配置 hadoop 的位置：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ vi conf/hive-env.sh</span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-2.9.2</span><br><span class="line">export HIVE_CONF_DIR=/opt/module/hive/conf</span><br></pre></td></tr></table></figure></p>
<p>在启动 hive 之前，需要先启动 hdfs 和 yarn：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sbin/start-dfs.sh</span><br><span class="line">$ sbin/start-yarn.sh</span><br></pre></td></tr></table></figure></p>
<p>在 hdfs 上创建 hive 的根目录，并赋予权限：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bin/hadoop fs -mkdir /tmp</span><br><span class="line">$ bin/hadoop fs -mkdir -p /user/hive/warehouse</span><br><span class="line">$ bin/hadoop fs -chmod g+w /tmp</span><br><span class="line">$ bin/hadoop fs -chmod g+w /user/hive/warehouse</span><br></pre></td></tr></table></figure></p>
<p>然后就可以启动 hive了：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bin/hive</span><br></pre></td></tr></table></figure></p>
<p>hive 到这里就可用了，但是 hive 在开始使用之后，会将创建的表的元数据存储在自带的本地数据库中，这样不安全，所以一般都会将这些数据单独存储到 MySQL中。</p>
<h2>metastore 配置</h2>
<p>在这里我介绍一种安装 MySQL 的方式，但这不是唯一的方式，可以根据自己的情况自行选择安装方式。</p>
<h3>安装 mysql</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">$ yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">$ yum -y install mysql-community-server</span><br></pre></td></tr></table></figure></p>
<p>mysql 设置</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl start  mysqld.service</span><br></pre></td></tr></table></figure></p>
<p>获取 MySQL 密码</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep <span class="string">"password"</span> /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line">2020-07-08T14:43:58.666069Z 1 [Note] A temporary password is generated <span class="keyword">for</span> root@localhost: SySy,a&lt;j5cBw</span><br></pre></td></tr></table></figure></p>
<p>然后就可以登录 MySQL:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -uroot -p<span class="string">"SySy,a&lt;j5cBw"</span></span><br></pre></td></tr></table></figure></p>
<p>修改密码，后续就可以使用 root进行登录了：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'root'</span>;</span><br></pre></td></tr></table></figure></p>
<h3>Hive 连接 MySQL</h3>
<p>Hive 连接MySQL 需要添加一个 mysql 的 connector，拷贝到 hive 的 lib 目录下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp mysql-connector-java-5.1.49-bin.jar /opt/module/hive-1.2.2/lib/</span><br></pre></td></tr></table></figure></p>
<p>然后创建一个 <code>hive-site.xml</code>的配置文件：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ touch conf/hive-site.xml</span><br><span class="line">$ vi conf/hive-site.xml</span><br></pre></td></tr></table></figure></p>
<p>在配置文件中填充以下内容，就是连接 MySQL 所需的配置：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/metastore?createDatabaseIfNotExist=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>JDBC connect string for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>username to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>password to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后重新启动 hive：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ bin/hive</span><br></pre></td></tr></table></figure></p>
<p>正常启动后可以发现 mysql 中多了一个 metastore 的数据库，这个数据库存储着 hive 的中数据表的元数据。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个本地服务器集群</title>
    <url>/2020/06/21/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>如今，单机服务器的时代已经过去了，部署任何服务，如果不多加几台服务器，就没办法让人心安。</p>
<p>而且在本地自己学习测试的时候，也经常需要用到服务器集群，比如搭建一个 MySQL 集群，一个 Redis 集群，一个 HDFS 集群，但是为了测试就买云服务器未免有些太奢侈了，所以搭建本地集群是一种既经济又实惠的方式。</p>
<p>这篇文章介绍一种在本地搭建服务器集群的方法。</p>
<p>软硬件要求：</p>
<ul>
<li>一台电脑（系统不限，配置高一点更好）</li>
<li><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">VirtualBox</a></li>
<li><a href="http://mirrors.aliyun.com/centos/" target="_blank" rel="noopener">Centos7</a></li>
</ul>
<p>VirtualBox 提供了各个系统的安装版本，下载完成后，直接点击软件包进行安装即可，不再赘述。</p>
<p>Centos 可以选择自己需要的版本，或者 Linux 的其他发行版本也行，注意要选择 Minimal 版本，用作服务器，不需要桌面之类的，这样服务器镜像的体积就可以很小。</p>
<p>本文搭建搭建 centos 集群的目标如下：</p>
<ul>
<li>使用虚拟机搭建一个拥有三台服务器的集群</li>
<li>三台虚拟机都可以与宿主机互相访问</li>
<li>三台虚拟机都可以访问外网</li>
<li>三台机器之间可以不需要输入密码直接使用 ssh 连接</li>
</ul>
<blockquote>
<p>本文基于 Mac os 10.15.5，VirtualBox6.1.8，centos7，另外阅读本文需要有一些基本的网络知识</p>
</blockquote>
<h2>安装服务器</h2>
<p>在开始之前，需要在 VirtualBox 的全局配置上加一块网卡，如下图所示：</p>
<p><img src="1.png" alt=""></p>
<p>在这里需要注意的是 IPv4 的地址和网络掩码，IPv4 地址就会成为整个服务器集群的网关，通常情况下不需要修改（如果你对计算机网络如数家珍，那轻便，随便改），设置好网关和子网掩码之后，后续配置的虚拟机 IP 都需要在这个网段内。</p>
<p>然后就可以创建一个虚拟机，名字随便设置，选择好目标文件夹，用来存储虚拟机的相关文件。</p>
<p>我们要安装的 centos7 是 Linux，所以虚拟机类型选择 Linux，版本选择里面并没有 Centos 的选项，那么选择 Red Hat(64-bit) 就可以了：</p>
<p><img src="2.png" alt=""></p>
<p>配置完成后就要给虚拟机分配内存，按照自己的电脑配置就行选择，基本上 2G 左右就可以了：</p>
<p><img src="3.png" alt=""></p>
<p>然后就是创建虚拟硬盘，由于是无图形界面的 Centos系统，默认的配置也够用了：</p>
<p><img src="4.png" alt=""></p>
<p><img src="5.png" alt=""></p>
<p><img src="6.png" alt=""></p>
<p><img src="7.png" alt=""></p>
<p>到这里，虚拟机就创建好了，接下来要为虚拟机提供系统的启动镜像，选中虚拟机，点击设置：</p>
<p><img src="8.png" alt=""></p>
<p>再点击存储：</p>
<p><img src="9.png" alt=""></p>
<p>选择下载好的镜像：</p>
<p><img src="10.png" alt=""></p>
<p>再选择网络，默认情况下只启用了一块网卡，为了满足后续的需求，我们需要再开启一块网卡：</p>
<p><img src="11.png" alt=""></p>
<p>选择 host-only 模式：</p>
<p><img src="12.png" alt=""></p>
<p>点击 ok 保存配置，然后就可以启动虚拟，第一次启动会安装系统，安装的过程中设置 root 密码，虚拟机的安装就完成了。</p>
<p>为了组成一个服务器集群，我们需要三个虚拟机，另外两台的安装方式和上面一样。</p>
<h2>网络配置</h2>
<p>在本文中，我使用 NAT + host-only 的方式来完成虚拟机既能访问外部网络，宿主机也能访问虚拟机的网络配置，但这不是唯一的方式。</p>
<p>刚安装好的虚拟机无法访问外部网络，这是因为虚拟机的网卡还没有开启，先进入到虚拟机开启网卡，让虚拟机可以通过 NAT 的方式访问外网，然后使用 host-only 的方式实现宿主机访问虚拟机。</p>
<p>使用 root 身份登录进系统，进入到网络的配置目录:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure></p>
<p>如果前面配置没有出错的话，在这里可以看到两个网卡的配置的：</p>
<p><img src="13.png" alt=""></p>
<p><code>ifcfg-enp0s3</code> 就对应 NAT 配置的那张网卡，<code>ifcfg-enp0s8</code> 就对应 host-only 配置的网卡。</p>
<p>先来配置 NAT 网络，使用 vi 打开 ifcfg-enpos3 配置:</p>
<blockquote>
<p>vi 是 Linux 系统自带的一个编辑器</p>
</blockquote>
<p><img src="14.png" alt=""></p>
<p>把 ONBOOT 的值改成 yes 就可以，表示开机启用这个网卡，配置完 NAT 之后，就可以在虚拟机内访问互联网了。</p>
<p>再来配置一下 host-only 网络：</p>
<p><img src="15.png" alt=""></p>
<p>首先要把网络从 dhcp 自动获取 ip 改成 static，再同样设置 ONBOOT 为 yes，IPADDR 指定这台虚拟机的固定 IP，IP 可以随意设置，但是要在这个网段内，NETMASK 配置的是这个网络的网络掩码。</p>
<p>最后配置一下网关:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/networking</span><br></pre></td></tr></table></figure></p>
<p>填入以下内容：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">GATEWAY=192.168.56.2 # 这个值就是在配置 VirtualBox 全局网卡时的网关的 IP，不要配错了</span><br></pre></td></tr></table></figure></p>
<p>这些都配置完成之后，重启网络服务:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure></p>
<p>然后访问外网:</p>
<p><img src="16.png" alt=""></p>
<p>宿主机访问虚拟机:</p>
<p><img src="17.png" alt=""></p>
<p>单台的网络已经配置好了，另外两台按照同样的配置就行，但需要为虚拟机配置不同的 IP。</p>
<blockquote>
<p>在本文的例子中，三台虚拟机的 IP 为：
192.168.56.3
192.168.56.4
192.168.56.5</p>
</blockquote>
<h2>服务器互联</h2>
<p>到这里，三台服务器都能够连接互联网，宿主机也可以访问虚拟机了，虚拟机之间也可以通过 ssh 连接输入密码后进行访问。</p>
<p>但是很多时候服务器之间需要能够直接传输文件，如果每次还需要输入密码，那就太不方便了。</p>
<p>机器之间登录还是使用 ssh，但是可以改良一下，每台服务器把其他两台设置为信任的机器，这样就可以直接登录，而不用每次都输入密码。</p>
<p>以 IP 为 192.168.56.3 的虚拟机为例，通过 ssh-keygen 生成公钥和密钥:</p>
<p><img src="18.png" alt=""></p>
<p>然后使用 ssh-copy-id 将公钥拷贝到像免密登录的机器：</p>
<p><img src="19.png" alt=""></p>
<p>然后就可以免密登录了：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.56.4</span><br><span class="line">ssh root@192.168.56.5</span><br></pre></td></tr></table></figure></p>
<p>另外两台机器进行同样的配置，然后三台虚拟机之间就可以相互免密访问。</p>
<p>到这里，本地服务器集群就搭建完毕了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>如何打造一个高效的工作环境</title>
    <url>/2019/03/18/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>这篇文章并不是我一个人独立完成的，感谢<a href="https://coolshell.cn/" target="_blank" rel="noopener">皓哥</a>帮忙改稿和补充，也感谢其他同学的校对，才有了这篇文章。</p>
<hr>
<p>程序员是一个很懒的群体，总想着能够让代码为自己干活，他们不断地把工作生活中的一些事情用代码自动化了，从而让整个社会的效率运作地越来越高。所以，程序员在准备去优化这个世界的时候，都会先要优化自己的工作环境，是所谓“工欲善其事，必先利其器”。</p>
<p>我们每个程序员都应该打造一套让自己更为高效的工作环境。那怕就是让你少输入一次命令，少按一次键，少在鼠标和键盘间切换一次，都会让程序员的工作变得更为的高效。所以，程序员一般需要一台性能比较好，不会因为开了太多的网页或程序就卡得不行的电脑，还要配备多个显示器，一个显示器写代码，一个查文档，一个测试运行结果，而不必在各种窗口来来回回的切换……在大量的窗口间切换经常会迷路，而且也容易出错（分不清线上或测试环境）……</p>
<p>除了硬件上的装备，软件上也是能够得升程序员生产力的地方，下面我们就想在软件层面说一下可以提升程序员生产力的一些东西。</p>
<p>这篇文章在查阅了很多资料以及结合自身的实践，从四个方面来说明如何打造一套适合自己的工具，分别是<strong>编辑器篇</strong>、<strong>命令行篇</strong>、<strong>Shell和脚本篇</strong>、<strong>版本管理篇</strong>。</p>
<h3>编辑器篇</h3>
<p>对于程序员来说，日常与编辑器打交道的时间非常长。编辑器是值得我们投入大量时间去学习并且定制来满足我们的需要。</p>
<p>如何选择合适的编辑器呢？编辑器有很多，有的值得投资时间去学习，有的基本就不用花时间去学。应当去学习那些能够提升生产力，有很强的生命力，并且能够适应各类环境的编辑器。</p>
<p><strong>Vim</strong> 和 <strong>Emacs</strong> 就是非常值得投资的编辑器，如果你决定开始学习 Vim/Emacs，刚开始的时候会感觉高很痛苦，甚至会伤害到自己的生产力，但是没关系，通过两三周的专注练习后，就可以通过学习编辑器的死亡之谷，很快就可以赚回票价了。</p>
<p>使用 Vim/Emacs 的另一个重要好处是，当你在处理一些线上问题的时候，有时候需要一个 IDE，你发现在一个Term 终端上是运行不了图形界面的编辑器了，你只有 Vim/Emacs 这样的选择。在 Coolshell 上有一篇《无插件Vim 编程技巧》（https://coolshell.cn/articles/11312.html）你可以移步一看。</p>
<p>为什么不学习 Notepad，因为，<strong>使用高效编辑器的终极目标是抛弃鼠标，让手编辑的速度可以跟的上大脑思考的速度</strong>。就我自己来说，从大二开始接触 Emacs 开始，已经使用 5 年了，通过不断的对 Emacs 进行定制，已经有了一套自己的使用模式了，每次打开 Emacs 就像是打开了自己才知道的秘籍，这是其他 IDE 都没有办法比的，通过不断定制自己的工具，可以激发自己创造的欲望。</p>
<p>但是我不参加编辑器的圣战，这些都是无意义的口水战。在一次接触了 Vim 之后，我反而喜欢上 Vim 的编辑模式了，于是在 Emacs 中使用上了 Vim 的编辑模式，实际的情况是这两者并不冲突（皓哥翻译的那篇 《简明 Vim 练级攻略》（https://coolshell.cn/articles/5426.html）文章非常不错）。</p>
<p>在 Emacs 上，有很多有用的特性和插件。 Emacs 的 <strong>org-mode</strong>，这个工具用来写作，还可用来做任务管理，任务计时器，甚至可以用来做表格的计算。功能上已经完全不是 markdown 能比的，但是遗憾的是目前只能在 Emacs 中使用（貌似有人在 Vim 上实现过）。</p>
<p>还有就是 Emacs 中的用来做文件管理的插件 <strong>helm</strong> 和 <strong>ivy</strong>，这两个插件完成的功能差不多，但是 helm 比较重量级一些，如果一个项目的代码量比较大时，文件的切换和搜索就没那么快了，所以我更喜欢轻量级的 ivy。</p>
<p>还有两个我最喜欢的插件，<strong>evil</strong> 和 <strong>magit</strong>，evil 可以让 Emacs 变身成为一个 Vim，大多数的 Vim 操作都可以覆盖上。magit 是一个可以使 Emacs 变身成为 Git 的插件。当然其他的各种语言的支持插件就是常规操作了，不多说。</p>
<p>下面推荐一些 Emacs 和 Vim 的学习资源:</p>
<p><strong>Emacs</strong></p>
<ul>
<li>
<p><strong>一年成为 Emacs 高手</strong>，当年我也是靠着这一篇文章真正入门 emacs,</p>
<p>https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org</p>
</li>
<li>
<p>陈斌 (一年成为 Emacs 高手的作者)的 Emacs 配置，是一个很不错的配置，我现在使用的配置要就是从这个演化来的 https://github.com/redguardtoo/emacs.d</p>
</li>
<li>
<p>Steve Purcell 大牛的配置，很适合 Web 开发者：https://github.com/purcell/emacs.d</p>
</li>
<li>
<p>Spacemacs 配置，适合新手，有着非常完善的文档：https://github.com/syl20bnr/spacemacs</p>
</li>
<li>
<p>reddit 的 Emacs 频道，最前沿的 Emacs 技巧：https://www.reddit.com/r/emacs/</p>
</li>
<li>
<p>Emacs org-mode 的文档，从这个文档中你可以发现纯文本的魔力：https://orgmode.org/</p>
</li>
<li>
<p>Emacs Wiki，上面有大量的 Emacs 插件的实践，虽然质量参差不齐，但是也有很多优秀的插件 https://www.emacswiki.org/emacs/EmacsWiki</p>
</li>
</ul>
<p><strong>Vim</strong></p>
<ul>
<li>Doist 创业公司 CEO amix 的 Vim 配置，被称之为最强 vimrc：https://github.com/amix</li>
<li>junegunn 是韩国的一个大牛，擅长写 Vim 插件，他的 Vim 插件看起来总是令人赏心悦目：https://github.com/junegunn/vim-plug</li>
<li>SpaceVim，一个开箱即用的 Vim 配置，对新手很友好，和 Spacemacs 一样，有着很完善的文档：https://github.com/SpaceVim/SpaceVim</li>
<li>reddit 的 Vim 频道，有很多最前沿的 Vim 技巧:https://www.reddit.com/r/vim/</li>
</ul>
<h3>命令行篇</h3>
<p>一个好的、可定制的命令行环境可以给工作效率带来很大的提升。如果你还在使用这个，那就差点意思了：</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/shell/Image.png" alt=""></p>
<p>在不同的操作系统下，都有着很不错的命令行工具，比如 Mac 下的 <strong>Iterm2</strong>，Linux 下的原生命令行，如果你是在 Windows 下工作，问题也不大，因为 Windows 下现在有了 <strong>WSL</strong>。WSL 提供了一个由微软开发的Linux兼容的内核接口（不包含Linux内核代码），然后可以在其上运行GNU用户空间，例如 Ubuntu，openSUSE，SUSE Linux Enterprise Server，Debian和Kali Linux。这样的用户空间可能包含 Bash shell 和命令语言，使用本机 GNU/Linux 命令行工具（sed，awk 等），编程语言解释器（Ruby，Python 等），甚至是图形应用程序（使用主机端的X窗口系统）。</p>
<p>使用命令行可以完成所有日常的操作，新建文件夹（mkdir）、新建文件（touch）、移动（mv）、复制（cp）、删除（rm）等等。而且使用 Linux/Unix 命令行最好的方式是可以用 awk、sed、grep、xargs、find、sort 等等这样的命令，然后用管道把其串起来，就可以完成一个你想要的功能，尤其是一些简单的数据统计功能。这是Linux命令行不可比拟的优势。比如：</p>
<ul>
<li>查看连接你服务器 top10 用户端的 IP 地址：</li>
</ul>
<p><code>netstat -nat | awk '{print $5}' | awk -F ':' '{print $1}' | sort | uniq -c | sort -rn | head -n 10</code></p>
<ul>
<li>查看一下你最常用的10个命令：</li>
</ul>
<p><code>cat .bash_history | sort | uniq -c | sort -rn | head -n 10 (or cat .zhistory | sort | uniq -c | sort -rn | head -n 10</code></p>
<p>在命令行中使用 <strong>alias</strong>  可以将使用频率很高命令或者比较复杂的命令合并成一个命令，或者修改原生的命令。</p>
<p>下面这几个命令，可能是你天天都在敲的。所以，你应该设置成 alias 来提高效率</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias nis&#x3D;&quot;npm install --save &quot;</span><br><span class="line">alias svim&#x3D;&#39;sudo vim&#39;</span><br><span class="line">alias mkcd&#x3D;&#39;foo()&#123; mkdir -p &quot;$1&quot;; cd &quot;$1&quot; &#125;; foo &#39;</span><br><span class="line">alias install&#x3D;&#39;sudo apt get install&#39;</span><br><span class="line">alias update&#x3D;&#39;sudo apt-get update &amp;&amp; sudo apt-get upgrade&#39;</span><br><span class="line">alias ..&#x3D;&quot;cd ..&quot;</span><br><span class="line">alias ...&#x3D;&quot;cd ..; cd ..&quot;</span><br><span class="line">alias www&#x3D;&#39;python -m SimpleHTTPServer 8000&#39;</span><br><span class="line">alias sock5&#x3D;&#39;ssh -D 8080 -q -C -N -f user@your.server&#39;</span><br></pre></td></tr></table></figure></p>
<p>你还可以参考如下的一些文章，看看别人是怎么用好 <code>alias</code> 的</p>
<ul>
<li>https://www.cyberciti.biz/tips/bash-aliases-mac-centos-linux-unix.html</li>
<li>https://www.digitalocean.com/community/questions/what-are-your-favorite-bash-aliases</li>
<li>https://www.linuxtrainingacademy.com/23-handy-bash-shell-aliases-for-unix-linux-and-mac-os-x/</li>
<li>https://brettterpstra.com/2013/03/31/a-few-more-of-my-favorite-shell-aliases/</li>
</ul>
<p>命令行中除了原生的命令之外，还有很多可以提升使用体验的工具。下面罗列一些很不错的命令，把原生的命令增强地很厉害:</p>
<ul>
<li>
<p><strong>fasd</strong> 增强了 <code>cd</code> 命令 (https://github.com/clvv/fasd)。</p>
</li>
<li>
<p><strong>bat</strong> 增强了 <code>cat</code> 命令 (https://github.com/sharkdp/bat)。如果你想要有语法高亮的 <code>cat</code>，可以试试 <strong>ccat</strong>(https://github.com/jingweno/ccat)</p>
</li>
<li>
<p><strong>exa</strong> 增强了 <code>ls</code> 命令(https://github.com/ogham/exa），如果你需要在很多目录上浏览各种文件 ，<strong>ranger</strong> 命令可以比 <code>cd</code> 和 <code>cat</code> 更有效率（https://github.com/ranger/ranger)，甚至可以在你的终端预览图片。</p>
</li>
<li>
<p><strong>fd</strong> 是一个比 <code>find</code> 更简单更快的命令(https://github.com/sharkdp/fd)，他还会自动地忽略掉一些你配置在 <code>.gitignore</code> 中的文件，以及 <code>.git</code> 下的文件。</p>
</li>
<li>
<p><strong>fzf</strong> 是另外一个很好用的文件搜索神器 (https://github.com/junegunn/fzf)，其主要是搜索当前目录以下的文件，还可以使用 <code>fzf --preview 'cat {}'</code> 边搜索文件边浏览内容。</p>
</li>
<li>
<p><code>grep</code> 是一个上古神器，然而，<strong>ack</strong> (https://beyondgrep.com/)、<strong>ag</strong> (https://github.com/ggreer/the_silver_searcher) 和 <strong>rg</strong> (https://github.com/BurntSushi/ripgrep) 是更好的grep，和上面的fd一样，在递归目录匹配的时候，会忽略到你配置在 .gitignore 中的规则。</p>
</li>
<li>
<p><code>rm</code> 是一个危险的命令，尤其是各种 <code>rm -rf …</code>，所以，<strong>trash</strong>（https://github.com/andreafrancia/trash-cli/) 是一个更好的删除命令。</p>
</li>
<li>
<p><code>man</code> 命令是好读文档的命令，但是man的文档有时候太长了，所以，你可以试式 <strong>tldr</strong>（https://github.com/tldr-pages/tldr) 命令，把文档上的一些示例整出来给你看。</p>
</li>
<li>
<p>如果你想要一个图示化的<code>ping</code>，你可以试试 <strong>prettyping</strong> (https://github.com/denilsonsa/prettyping) 。</p>
</li>
<li>
<p>如果你想搜索以前打过的命令，不要再用 Ctrl +R 了，你可以使用加强版的 <strong>hstr</strong> (https://github.com/dvorka/hstr) 。</p>
</li>
<li>
<p><strong>htop</strong> (https://hisham.hm/htop/） 是 top 的一个加强版。然而，还有很多的各式各样的top，比如：用于看IO负载的 <strong>iotop</strong> (http://guichaz.free.fr/iotop/)，网络负载的 <strong>iftop</strong> (http://www.ex-parrot.com/~pdw/iftop/), 以及把这些top都集成在一起的 <strong>atop</strong> (https://github.com/Atoptool/atop)。</p>
</li>
<li>
<p><strong>ncdu</strong> (https://dev.yorhel.nl/ncdu) 比 du 好用多了用。另一个选择是 nnn（https://github.com/jarun/nnn) 。</p>
</li>
<li>
<p>如果你想把你的命令行操作建录制成一个 SVG 动图，那么你可以尝试使用 <strong>asciinema</strong> (https://asciinema.org/) 和 <strong>svg-trem</strong> (https://github.com/marionebl/svg-term-cli) 。</p>
</li>
<li>
<p><strong>httpie</strong>(https://github.com/jakubroztocil/httpie) 是一个可以用来替代 curl 和 wget 的 http 客户端，httpie 支持 json 和语法高亮，可以使用简单的语法进行 http 访问: <code>http -v github.com</code>。</p>
</li>
<li>
<p><strong>tmux</strong> (https://github.com/tmux/tmux) 在需要经常登录远程服务器工作的时候会很有用，可以保持远程登录的会话，还可以在一个窗口中查看多个 shell 的状态。</p>
</li>
<li>
<p><strong>Taskbook</strong>(https://github.com/klaussinani/taskbook) 是可以完全在命令行中使用的任务管理器 ，支持 ToDo 管理，还可以为每个任务加上优先级。</p>
</li>
<li>
<p><strong>sshrc</strong> (sshrc：https://github.com/Russell91/sshrc ) 是个神器，在你登录远程服务器的时候也能使用本机的 shell 的 rc 文件中的配置。</p>
</li>
<li>
<p><strong>goaccess</strong> (https://github.com/allinurl/goaccess) 这个是一个轻量级的分析统计日志文件的工具，主要是分析各种各样的 access log。</p>
</li>
</ul>
<p>关于这些增加命令，参考自下面的这些文章</p>
<ol>
<li>https://dev.to/_darrenburns/10-tools-to-power-up-your-command-line-4id4</li>
<li>https://dev.to/_darrenburns/tools-to-power-up-your-command-line-part-2-2737</li>
<li>https://dev.to/_darrenburns/power-up-your-command-line-part-3-4o53</li>
<li>https://darrenburns.net/posts/tools/</li>
<li>https://hacker-tools.github.io/</li>
</ol>
<h3>Shell 和脚本篇</h3>
<p>shell 是可以与计算机进行高效交互的文本接口。shell 提供了一套交互式的编程语言（脚本），shell的种类很多，比如 <strong>sh</strong>、<strong>bash</strong>、<strong>zsh</strong> 等。</p>
<p>shell 的生命力很强，在各种高级编程语言大行其道的今天，很多的任务依然离不开 shell。比如可以使用 shell 来执行一些编译任务，或者做一些批处理任务，初始化数据、打包程序等等。</p>
<p>写一个脚本很简单，<strong>touch zsh-script.sh</strong>：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/zsh</span></span><br><span class="line">echo Hello shell</span><br></pre></td></tr></table></figure></p>
<p>一个脚本就写完了，<strong>#!/bin/zsh</strong> 表示使用的是哪种 shell。写完之后需要给脚本加上执行的权限:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给脚本执行的权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x zsh-script.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行脚本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./zsh-script.sh</span></span><br></pre></td></tr></table></figure></p>
<p>脚本的语法很简单，而且可以在脚本中使用命令行的所有命令。还有很多其他有意思的玩法，比如在后台运行：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./zsh-script.sh &amp;</span></span><br></pre></td></tr></table></figure></p>
<p>还有可以定时执行，在 <strong>crontab</strong> 加入：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* * * * * /home/ray/zsh-script.zsh</span><br></pre></td></tr></table></figure></p>
<p>crontab 是 Linux 中的一个定时器，可以定制执行任务，上面的表示每分钟执行一次脚本。</p>
<p>我最喜欢的就是 <strong>zsh</strong> + <strong><a href="https://ohmyz.sh/" target="_blank" rel="noopener">oh-my-zsh</a></strong> + <strong><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">zsh-autosuggestions</a></strong> 的组合，你也可以试试看。其中 zsh 和 oh-my-zsh 算是常规操作了，但是 zsh-autosuggestions 特别有用，可以超级快速的帮你补全你输入过的命令，让命令行的操作更加高效。 只需要简单的安装配置，你的命令行马上变得高档大气上档次，狂拽炫酷吊炸天。</p>
<p>另外，<strong><a href="https://fishshell.com/" target="_blank" rel="noopener">fish</a></strong> 也是另外一个牛逼的shell，比如：命令行自动完成（根据历史记录），命令行命令高亮，当你要输入命令行参数的时候，自动提示有哪些参数…… fish在很多地方也是用起来很爽的。和上面的 oh-my-zsh 有点不分伯仲了。</p>
<p>你也许会说，用 Python 脚本或 PHP 来写脚本会比 Shell 更好更没有 bug，但我要申辩一下:</p>
<ul>
<li>其一，如果你有一天要维护线上机器的时候，或是到了银行用户的系统（与外网完全隔离，而且服务器上没有安装 Python/PHP 或是他们的的高级库，那么，你只有 Shell 可以用了）。</li>
<li>其二，而且，如果要跟命令行交互很多的话，Shell 是不二之选，试想一下，如果你要去 100 台远程的机器上查access.log 日志中有没有某个错误，完成这个工作你是用 PHP/Python 写脚本快还是用 Shell 写脚本快呢？</li>
</ul>
<p>要写好一个脚本并不容易，下面有一些小模板供你参考：</p>
<p>处理命令行参数的一个样例</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while [ &quot;$1&quot; !&#x3D; &quot;&quot; ]; do</span><br><span class="line">    case $1 in</span><br><span class="line">        -s  )   shift	</span><br><span class="line">		SERVER&#x3D;$1 ;;  </span><br><span class="line">        -d  )   shift</span><br><span class="line">		DATE&#x3D;$1 ;;</span><br><span class="line">	--paramter|p ) shift</span><br><span class="line">		PARAMETER&#x3D;$1;;</span><br><span class="line">        -h|help  )   usage # function call</span><br><span class="line">                exit ;;</span><br><span class="line">        * )     usage # All other parameters</span><br><span class="line">                exit 1</span><br><span class="line">    esac</span><br><span class="line">    shift</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>命令行菜单的一个样例</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Bash Menu Script Example</span><br><span class="line"></span><br><span class="line">PS3&#x3D;&#39;Please enter your choice: &#39;</span><br><span class="line">options&#x3D;(&quot;Option 1&quot; &quot;Option 2&quot; &quot;Option 3&quot; &quot;Quit&quot;)</span><br><span class="line">select opt in &quot;$&#123;options[@]&#125;&quot;</span><br><span class="line">do</span><br><span class="line">    case $opt in</span><br><span class="line">        &quot;Option 1&quot;)</span><br><span class="line">            echo &quot;you chose choice 1&quot;</span><br><span class="line">            ;;</span><br><span class="line">        &quot;Option 2&quot;)</span><br><span class="line">            echo &quot;you chose choice 2&quot;</span><br><span class="line">            ;;</span><br><span class="line">        &quot;Option 3&quot;)</span><br><span class="line">            echo &quot;you chose choice $REPLY which is $opt&quot;</span><br><span class="line">            ;;</span><br><span class="line">        &quot;Quit&quot;)</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">        *) echo &quot;invalid option $REPLY&quot;;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>颜色定义，你可以使用 <code>echo -e &quot;${Blu}blue ${Red}red ${RCol}etc....&quot;</code> 进行有颜色文本的输出</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RCol&#x3D;&#39;\e[0m&#39;    # Text Reset</span><br><span class="line"></span><br><span class="line"># Regular           Bold                Underline           High Intensity      BoldHigh Intens     Background          High Intensity Backgrounds</span><br><span class="line">Bla&#x3D;&#39;\e[0;30m&#39;;     BBla&#x3D;&#39;\e[1;30m&#39;;    UBla&#x3D;&#39;\e[4;30m&#39;;    IBla&#x3D;&#39;\e[0;90m&#39;;    BIBla&#x3D;&#39;\e[1;90m&#39;;   On_Bla&#x3D;&#39;\e[40m&#39;;    On_IBla&#x3D;&#39;\e[0;100m&#39;;</span><br><span class="line">Red&#x3D;&#39;\e[0;31m&#39;;     BRed&#x3D;&#39;\e[1;31m&#39;;    URed&#x3D;&#39;\e[4;31m&#39;;    IRed&#x3D;&#39;\e[0;91m&#39;;    BIRed&#x3D;&#39;\e[1;91m&#39;;   On_Red&#x3D;&#39;\e[41m&#39;;    On_IRed&#x3D;&#39;\e[0;101m&#39;;</span><br><span class="line">Gre&#x3D;&#39;\e[0;32m&#39;;     BGre&#x3D;&#39;\e[1;32m&#39;;    UGre&#x3D;&#39;\e[4;32m&#39;;    IGre&#x3D;&#39;\e[0;92m&#39;;    BIGre&#x3D;&#39;\e[1;92m&#39;;   On_Gre&#x3D;&#39;\e[42m&#39;;    On_IGre&#x3D;&#39;\e[0;102m&#39;;</span><br><span class="line">Yel&#x3D;&#39;\e[0;33m&#39;;     BYel&#x3D;&#39;\e[1;33m&#39;;    UYel&#x3D;&#39;\e[4;33m&#39;;    IYel&#x3D;&#39;\e[0;93m&#39;;    BIYel&#x3D;&#39;\e[1;93m&#39;;   On_Yel&#x3D;&#39;\e[43m&#39;;    On_IYel&#x3D;&#39;\e[0;103m&#39;;</span><br><span class="line">Blu&#x3D;&#39;\e[0;34m&#39;;     BBlu&#x3D;&#39;\e[1;34m&#39;;    UBlu&#x3D;&#39;\e[4;34m&#39;;    IBlu&#x3D;&#39;\e[0;94m&#39;;    BIBlu&#x3D;&#39;\e[1;94m&#39;;   On_Blu&#x3D;&#39;\e[44m&#39;;    On_IBlu&#x3D;&#39;\e[0;104m&#39;;</span><br><span class="line">Pur&#x3D;&#39;\e[0;35m&#39;;     BPur&#x3D;&#39;\e[1;35m&#39;;    UPur&#x3D;&#39;\e[4;35m&#39;;    IPur&#x3D;&#39;\e[0;95m&#39;;    BIPur&#x3D;&#39;\e[1;95m&#39;;   On_Pur&#x3D;&#39;\e[45m&#39;;    On_IPur&#x3D;&#39;\e[0;105m&#39;;</span><br><span class="line">Cya&#x3D;&#39;\e[0;36m&#39;;     BCya&#x3D;&#39;\e[1;36m&#39;;    UCya&#x3D;&#39;\e[4;36m&#39;;    ICya&#x3D;&#39;\e[0;96m&#39;;    BICya&#x3D;&#39;\e[1;96m&#39;;   On_Cya&#x3D;&#39;\e[46m&#39;;    On_ICya&#x3D;&#39;\e[0;106m&#39;;</span><br><span class="line">Whi&#x3D;&#39;\e[0;37m&#39;;     BWhi&#x3D;&#39;\e[1;37m&#39;;    UWhi&#x3D;&#39;\e[4;37m&#39;;    IWhi&#x3D;&#39;\e[0;97m&#39;;    BIWhi&#x3D;&#39;\e[1;97m&#39;;   On_Whi&#x3D;&#39;\e[47m&#39;;    On_IWhi&#x3D;&#39;\e[0;107m&#39;;</span><br></pre></td></tr></table></figure></p>
<p>取当前运行脚本绝对路径的示例：（注：Linux下可以用 <code>dirname $(readlink -f $0)</code> ）</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FILE&#x3D;&quot;$0&quot;</span><br><span class="line">while [[ -h $&#123;FILE&#125; ]]; do</span><br><span class="line">    FILE&#x3D;&quot;&#96;readlink &quot;$&#123;FILE&#125;&quot;&#96;&quot;</span><br><span class="line">done</span><br><span class="line">pushd &quot;&#96;dirname &quot;$&#123;FILE&#125;&quot;&#96;&quot; &gt; &#x2F;dev&#x2F;null</span><br><span class="line">DIR&#x3D;&#96;pwd -P&#96;</span><br><span class="line">popd &gt; &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure></p>
<p>如何在远程服务器运行一个本地脚本</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#无参数</span><br><span class="line">ssh user@server &#39;bash -s&#39; &lt; local.script.sh</span><br><span class="line"></span><br><span class="line">#有参数</span><br><span class="line">ssh user@server ARG1&#x3D;&quot;arg1&quot; ARG2&#x3D;&quot;arg2&quot; &#39;bash -s&#39; &lt; local_script.sh</span><br></pre></td></tr></table></figure></p>
<p>如何检查一个命令是否存在，用 <code>which</code> 吗？最好不要用，因为很多操作系统的 <code>which</code> 命令没有设置退出状态码，这样你不知道是否是有那个命令。所以，你应该使用下面的方式。</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># POSIX 兼容:</span><br><span class="line">command -v &lt;the_command&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># bash 环境:</span><br><span class="line">hash &lt;the_command&gt; </span><br><span class="line">type &lt;the_command&gt; </span><br><span class="line"></span><br><span class="line"># 示例：</span><br><span class="line">gnudate() &#123;</span><br><span class="line">    if hash gdate 2&gt;&#x2F;dev&#x2F;null; then</span><br><span class="line">        gdate &quot;$@&quot;</span><br><span class="line">    else</span><br><span class="line">        date &quot;$@&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，如果要写出健壮性更好的脚本，下面是一些相关的技巧：</p>
<ul>
<li>使用 <code>-e</code> 参数，如：<code>set -e</code> 或是 <code>#!/bin/sh -e</code>，这样设置会让你的脚本出错就会停止运行，这样一来可以防止你的脚本在出错的情况下还在拼拿地干活停不下来。</li>
<li>使用 <code>-u</code> 参数，如： <code>set -eu</code>，这意味着，如果你代码中有变量没有定义，就会退出。</li>
<li>对一些变理，你可以使用默认值。如：<code>${FOO:-'default'}</code></li>
<li>处理你代码的退出码。这样方便你的脚本跟别的命令行或脚本集成。</li>
<li>尽量不要使用 <code>;</code> 来执行多个命令，而是使用 <code>&amp;&amp;</code>，这样会在出错的时候停止运行后续的命令。</li>
<li>对于一些字符串变量，使用引号括起，避免其中有空格或是别的什么诡异字符。</li>
<li>如果你的脚有参数，你需要检查脚本运行是否带了你想要的参数，或是，你的脚本可以在没有参数的情况下安全的运行。</li>
<li>为你的脚本设置 <code>-h</code> 和 <code>--help</code> 来显示帮助信息。千万不要把这两个参数用做为的功能。</li>
<li>使用 <code>$()</code> 而不是 `` 来获得命令行的输出，主要原因是易读。</li>
<li>小心不同的平台，尤其是 MacOS 和 Linux 的跨平台。</li>
<li>对于 <code>rm -rf</code> 这样的高危操作，需要检查后面的变量名是否为空，比如：<code>rm -rf $MYDIDR/*</code> 如果 <code>$MYDIR</code>为空，结果是灾难性的。</li>
<li>考虑使用 &quot;find/while&quot; 而不是 “for/find”。如：<code>for F in $(find . -type f) ; do echo $F; done</code> 写成 <code>find . -type f | while read F ; do echo $F ; done</code> 不但可以容忍空格，而且还更快。</li>
<li>防御式编程，在正式执行命令前，把相关的东西都检查好，比如，文件目录有没有存在。</li>
</ul>
<p>最后推荐一些 Shell 和脚本的参考资料。</p>
<p>各种有意思的命令拼装，一行命令走天涯:</p>
<ul>
<li>http://www.bashoneliners.com/</li>
<li>http://www.shell-fu.org/</li>
<li>http://www.commandlinefu.com/</li>
</ul>
<p>下面是一些脚本集中营，你可以在里面淘到各种牛X的脚本：</p>
<ul>
<li>http://www.shelldorado.com/scripts/</li>
<li>https://snippets.siftie.com/public/tag/bash/</li>
<li>https://bash.cyberciti.biz/</li>
<li>https://github.com/alexanderepstein/Bash-Snippets</li>
<li>https://github.com/miguelgfierro/scripts</li>
<li>https://github.com/epety/100-shell-script-examples</li>
<li>https://github.com/ruanyf/simple-bash-scripts</li>
</ul>
<p>甚至写脚本都可以使用框架:</p>
<ul>
<li>写bash脚本的框架  https://github.com/Bash-it/bash-it</li>
</ul>
<p>Google的Shell脚本的代码规范：</p>
<ul>
<li>https://google.github.io/styleguide/shell.xml</li>
</ul>
<p>最后，别忘了几个和shell有关的索引资源：</p>
<ul>
<li>https://github.com/alebcay/awesome-shell</li>
<li>https://github.com/awesome-lists/awesome-bash</li>
<li>https://terminalsare.sexy/</li>
</ul>
<h3>版本管理篇</h3>
<p>版本管理的工具对我来说已经不仅仅不是管理代码的工具了。任何需要不断优化，不断修改的内容都需要进行版本管理。</p>
<p>版本管理的工具很多。现在还有好些人还不喜欢 Git 还在用 svn，那是因为他们并不知道 Git 的强大之处，这种脱机的版本管理可以让你在没有网的情况下提效代码变更，再加上 Git 切换 branch 快得不行，merge branch 时会把 branch 的改动情况一同 merge 了，这样可以让你看到整个历史。再有 stash，cherry-pick 等等这样的黑魔法加持，你的工作效率真的很爽的。如今最好用的应该就是 <strong>Git</strong> 了，在加上最近 <strong>GitHub</strong> 私有仓库的开放，让这一优势继续扩大。</p>
<p>Git 这么好用的原因来源于其底层数据结构的设计，非常的有意思，如果你接触过区块链，你会发现 Git 底层的数据结构与区块链的数据结构有异曲同工之处。</p>
<p>Git 除了可以完成通常的版本管理之外，它还拥有一些很神奇的技能：</p>
<ul>
<li>帮你找 bug 的命令: <strong>git bisect</strong>，通过二分搜索的方式来帮助你定位到引入 bug 的 commit。</li>
<li>可以帮助你洞察一切的 <strong>git blame</strong> 可以给你文件的每行信息都进行注释，然后就可以看到关于该行修改的每一次 commit 的哈希标签、作者和提交日期。</li>
<li>可以帮你恢复一切的 <strong>git reflog</strong>，通常我们 <strong>git reset</strong> 命令都是慎用的，要不然就坏事了，但是 git relog 在你将变化提交之前，可以帮助你回到任何修改之前，包括 git reset。但是 reflog 只是保存在本地，而且不是永久保存，有一个可以配置的过期时间。</li>
</ul>
<p>除此之外，还有一些 Git 的小技巧：</p>
<ul>
<li>如果你当前修改的文档在你本地的master上，然后你想把这个修改迁移到一个branch上，这样方便你做PR，如果这些修改还没有被add，那么你可以使用 <code>git checkout -b new_branch_name</code> 来完成。</li>
<li>如果你commit后，还没有push，你想修改一下这前的commit，你可以使用 <code>git commit --amend</code></li>
<li>使用 <code>git pull --rebase</code> 可以避免出现一个 merge buble。</li>
<li>如果你要删除远程分支，可以使用 <code>git push origin --delete &lt;remote-branchname&gt;</code></li>
<li>使用 <code>git add -p</code> 可以让你挑选修改，这样你可以把你的一次大改动变成多个提交。</li>
<li><code>git checkout -p</code> 和 <code>git add -p</code> 类似，如果让你挑选你想checkout的修改。</li>
<li>你知道你可以使用时间在你的git命令行上吗？比如：<code>git diff HEAD@{'2 months ago'}</code> 或 <code>git diff HEAD@{yesterday}</code> 或 <code>git diff HEAD@{'2010-01-01 12:00:00'}</code></li>
</ul>
<p>有时候，设置一下 Git 的别名也是可以让你更高效工作的一件事，比如：</p>
<p>使用如下的 <code>git lg</code> 别名</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --&quot;</span><br></pre></td></tr></table></figure></p>
<p>就可以把原来的 <code>git log</code> 的输出</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/git/git.log_.01.png" alt=""></p>
<p>变成下面这个样子</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/git/git.log_.02.png" alt=""></p>
<p>除此之外，Git 还有好些比较有用的别名，下面这几个收集库，可以让你更高效更赏心悦目地使用 Git</p>
<ul>
<li>https://github.com/momeni/gittify</li>
<li>https://github.com/GitAlias/gitalias</li>
<li>https://gist.github.com/mwhite/6887990</li>
</ul>
<p>Git 有多种用法，可以使用原生的 Git 命令行，原生的 Git 命令加上 shell 脚本的包装就可以做到很高效了。 Git 也有图形化的界面，比如 Git 安装包自带的 gitk 或者 TortoiseGit，因为比起命令行来太慢了。还有就是 magit，这是 Emacs 的一个插件，这个插件将所有 Git 的操作都融入到 Emacs 中了，只需要使用使用快捷键就能够完成 Git 的所有操作，但是同时又带有一点图形化的感觉，这么说有点苍白无力，看图:</p>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/emacs/emacs-git.jpg" alt=""></p>
<p>我现在日常会使用 Git 来进行代码管理、博客文章的管理和自己的知识库的管理。这些内容使用版本管理起来的好处是可以看见自己的成长过程，每一次修改的内容，每一个想法的进化。</p>
<p>下面推荐一下 Git 的学习资料:</p>
<ul>
<li>Progit2，最好的深入学习 Git 的教材，而且是开源的https://github.com/progit/progit2</li>
<li>Magit，Git 在 Emacs 上的打开方式：https://magit.vc/</li>
<li>Vim-fugitive，Git 在 Vim 上的打开方式：https://github.com/tpope/vim-fugitive</li>
<li>Git 相关的 shell 提示： https://github.com/magicmonty/bash-git-prompt</li>
</ul>
<p>Happy hacking！</p>
<p>(完)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确的关闭线程池</title>
    <url>/2020/11/14/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>线程池是 Java 开发中常用的组件之一，在应用程序关闭的时候，需要将线程池关闭。但关闭线程池时，要按照不同的情况来使用不同的方式。下面介绍几种关闭线程池的常用方法。</p>
<p>本文基于 OpenJDK11</p>
<h2>1. 线程池简介</h2>
<p>Java 中的线程池都实现了 <code>Executor</code>接口，这个接口提供了执行任务的入口。ExecutorService 继承了 Executor，提供了对线程池生命周期的管理，在开发中用的最多。</p>
<p>对于关闭线程池，ExecutorService 提供了三种方式：</p>
<ul>
<li>shutdown</li>
<li>shutdownNow</li>
<li>awaitTermination</li>
</ul>
<p>这几种方法都可以关闭线程池，但是每种方式之间有一些差别。</p>
<p>现有如下任务：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"任务开始执行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"任务执行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用 <code>shutdown</code>方法之后，线程池就不会再接收新的任务，如果强行添加，就会报错。而线程池中的任务会继续执行，但是却不保证这些任务能够执行完成，具体原因，下文会说到。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">threadPool.submit(<span class="keyword">new</span> Task());</span><br><span class="line">threadPool.shutdown();</span><br><span class="line">threadPool.submit(<span class="keyword">new</span> Task());</span><br></pre></td></tr></table></figure></p>
<p>上面代码的执行结果如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@<span class="number">7e07</span>db1f</span><br></pre></td></tr></table></figure></p>
<p>调用 <code>shutdownNow</code> 方法之后，所以运行中的任务都会终止，而且会返回队列中等待的任务。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">threadPool.submit(<span class="keyword">new</span> Task());</span><br><span class="line">threadPool.shutdownNow();</span><br></pre></td></tr></table></figure></p>
<p>调用 <code>awaitTermination</code> 之后，线程池中的任务会继续运行，而且还可以接受新的任务。它是线程阻塞的，会等到任务执行完成才结束主线程，这是它与shutdown 的区别。当然也不会无限期的等下去，可以通过设置超时时间，在超时时间之后，就会结束线程的阻塞。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">threadPool.submit(<span class="keyword">new</span> Task());</span><br><span class="line">threadPool.awaitTermination(<span class="number">6</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></p>
<h2>2. 正确的关闭线程池</h2>
<h3>执行简单任务</h3>
<p>还以上面的 Task 为例，这种 Task 不依赖外部的数据，执行这种任务的线程池在关闭时，只需要调用 shutdown 方法即可。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    threadPool.submit(<span class="keyword">new</span> Task());</span><br><span class="line">    threadPool.submit(<span class="keyword">new</span> Task());</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"主线程结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时程序的输出如下，任务会在主线程结束之后继续执行。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">任务开始执行</span><br><span class="line">任务开始执行</span><br><span class="line">主线程结束</span><br><span class="line">任务执行结束</span><br><span class="line">任务执行结束</span><br></pre></td></tr></table></figure></p>
<h3>执行复杂任务</h3>
<p>在执行一些复杂任务时，任务需要依赖外部的数据，任务为下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task1</span><span class="params">(Map&lt;String, String&gt; o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (data.containsKey(<span class="string">"invoke"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"正常任务执行!"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"正常任务结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在线程池中执行这个任务：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    Map&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    data.put(<span class="string">"invoke"</span>, <span class="string">"true"</span>);</span><br><span class="line">    threadPool.submit(<span class="keyword">new</span> Task1(data));</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    data.remove(<span class="string">"invoke"</span>);</span><br><span class="line">    System.out.println(<span class="string">"主线程结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果如下，在外部数据依赖删除之后，程序也就执行结束了。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">正常任务执行!</span><br><span class="line">主线程结束</span><br><span class="line">正常任务结束</span><br></pre></td></tr></table></figure></p>
<p>如果这个依赖是一些网络连接，或者数据库连接，在主程序退出之后，这些连接就会被销毁，那么线程池中的任务就无法继续执行。所以这个时候需要阻塞主线程，给线程池中的任务一些执行的时间。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    Map&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    data.put(<span class="string">"invoke"</span>, <span class="string">"true"</span>);</span><br><span class="line">    threadPool.submit(<span class="keyword">new</span> Task1(data));</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!threadPool.awaitTermination(<span class="number">4</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"任务还没结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data.remove(<span class="string">"invoke"</span>);</span><br><span class="line">    System.out.println(<span class="string">"主线程结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用了 awaitTermination 方法之后，主线程就会被阻塞，等待线程池中的任务继续执行，但是也不会无限期的等下去，等待超时时间过了之后，主程序还是会退出。</p>
<p>在关闭线程池时，一般是 shutdown 与 awaitTermination 方法配合使用。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadPool.shutdown();</span><br><span class="line"><span class="keyword">if</span> (!threadPool.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"任务还没结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果还想确认在线程池退出时，确保线程池中的任务全部结束，可以在阻塞时间过了之后使用 shutdownNow:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadPool.shutdown();</span><br><span class="line"><span class="keyword">if</span> (!threadPool.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"任务还没结束"</span>);</span><br><span class="line">    threadPool.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以让线程池按照预想的结果关闭。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>子弹短信轻体验</title>
    <url>/2018/08/26/%E5%AD%90%E5%BC%B9%E7%9F%AD%E4%BF%A1%E8%BD%BB%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>子弹短信是一款锤子出品的聊天工具，可以高效率的发送消息。最大的优势是子弹短信可以将语音转化成为文字直接发送出去，据老罗说是为了解决经常收到一大堆语音不知道如何是好的问题。但是语言也存在语音识别不准确的问题，所以语音也会随着文字一起发送出来。这样就达到了效率高和信息准确的问题。</p>
<p>看起来大家对这个产品比较感兴趣，这几天都冲上了 IOS 免费榜的榜首了，但是这个并不能说明太多的问题，这里面的绝大多数人（包括我）都只是为了尝尝鲜，想体验一下。但是实际上，体验完了之后也就完了，并不会有从微信上迁移过来的想法。当然，这个并不全是因为自己的好友圈都在微信上，很大一部分原因是因为这个产品并没有优秀到让人想迁移过来。</p>
<p>产品本身而言，当然在语音的输入上确实是解决了一个小问题，提高的效率肯定也没有老罗说的那么夸张，这里面很多的功能都是需要结合锤子系统产能很好的使用的。比如找锤友，比如结合闪念胶囊，这些都是只能使用锤子系统之后产能使用到的功能，但是锤子系统本身的用户就有限。这个是这个产品最为致命的短板，而且就产品本身而言，也没其他的很好的体验。特别是底部菜单那一个大大的资讯流，搞不懂他们是想要做什么。</p>
<p>综合来说，这个是一个非常一般的软件。</p>
]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>锤子</tag>
      </tags>
  </entry>
  <entry>
    <title>如何隐藏你的数据库密码</title>
    <url>/2020/08/15/%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8F%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>当一个服务要上线的时候，配置文件中总会写满各种配置信息，其中有很多的敏感信息，比如数据库的账号和密码，依赖外部服务的 appid 和 secret。</p>
<p>从安全的角度考虑，这些信息肯定都不能用明文的形式展现出来，不应该暴露给开发人员，毕竟这年头，删库跑路，偷数据的人不算少数，另外更严重的是一旦服务器被黑，这些敏感信息也都被泄漏了。</p>
<p>所以要想办法将这些信息隐藏起来，但同时不能影响服务的正常运行。</p>
<p>最好的方式就是将这些信息加密，在系统需要用到这些信息的时候再解密。整体的设计思路如图：</p>
<p><img src="1.png" alt=""></p>
<p>在实现这个思路的过程中，有几个问题需要解决：</p>
<ul>
<li>怎么加密</li>
<li>加密后的信息怎么存储</li>
<li>在什么时间以及怎么解密</li>
</ul>
<p>首先加密算法要使用可解密的，根据自己的需求进行选择就可以，比如 Base64，如果对加密的要求比较高，就可以使用 RSA 进行加密，但不管选择哪种加密方式，私钥要保存好。</p>
<p>加密后的信息需要用键值对的形式存储在数据库中，键值对的形式如下：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">user_database_username: YXNkZmFkZmFmc2RmYXNmZg==</span><br></pre></td></tr></table></figure></p>
<p>存储的数据库可以根据具体的情况进行选择，需要能持久化数据的数据库，比如 MySQL。</p>
<p>然后应用在使用账号密码或者其他敏感信息的时候，只需要在配置文件中配置好加密信息对应的 key。</p>
<p>然后每次服务启动的时候，都先去加载这些配置文件，完成对加密信息的解密，然后才开始去初始化系统。</p>
<p>解密的时候通过调用接口的形式来解密，之所以通过接口，是因为解密的密钥不能放在应用服务器上。</p>
<p>这个接口可以通过 Http 接口，也可以通过 RPC 接口，可以根据具体的情况来确定。虽然每个框架的实现不一样，但是原理总是类似的。</p>
<p>找到每个框架启动时候用于加载配置文件的流程，然后对这个流程中的某个节点做一点修改，就可以完成对加密配置的解密。</p>
<p>以 Spring 框架为例，来实现这个解密过程，只需要继承 <code>PropertyPlaceholderConfigurer</code> 类，重写其中的 <code>convertProperties</code> 方法，将加密的信息通过解密接口解密，将解密后的值重新赋值给这些配置，整个过程就完成了。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerPropertyPlaceholderConfigurer</span> <span class="keyword">extends</span> <span class="title">PropertyPlaceholderConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CustomerPropertyPlaceholderConfigurer.class);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">convertProperties</span><span class="params">(Properties props)</span> </span>&#123;</span><br><span class="line">        Enumeration propertyNames = props.propertyNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(propertyNames.hasMoreElements()) &#123;</span><br><span class="line">            String propertyName = (String)propertyNames.nextElement();</span><br><span class="line">            String propertyValue = props.getProperty(propertyName);</span><br><span class="line">            String convertedValue = <span class="keyword">this</span>.convertPropertyValue(propertyValue);</span><br><span class="line"></span><br><span class="line">            convertedValue = decrypt(convertedValue);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!ObjectUtils.nullSafeEquals(propertyValue, convertedValue)) &#123;</span><br><span class="line">                logger.info(<span class="string">"Decrypt property: &#123;&#125;"</span>, propertyName);</span><br><span class="line">                props.setProperty(propertyName, convertedValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">decrypt</span><span class="params">(String encryptValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现具体的解密服务调用</span></span><br><span class="line">        <span class="keyword">return</span> encryptValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然这样做了之后，存储密钥的服务器也会存在风险，一个比较好的方式是将存储加密信息和密钥的数据库部署在内网，无法通过外网进行访问。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2018年书单</title>
    <url>/2018/12/29/%E6%88%91%E7%9A%842018%E5%B9%B4%E4%B9%A6%E5%8D%95/</url>
    <content><![CDATA[<p>前两年的阅读习惯中，总是下意识的去追求量，觉得一年能够看多少本书是非常了不起的一件事。但是后来其实发现读书其实不能这么来，因为有些书值得反复看，有些书看一遍都有点浪费时间。所以今年看过的书并不是很多，下面是我今年的书单，这些书我都至少看过了两遍。</p>
<h3>原则</h3>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/2018shudan/yuanze.jpg" alt=""></p>
<p>虽然这本书被很多人吹过，但是我也还是想放在推荐的第一位。我觉得这本书并没有大多数人吹的那么好，之所以名气这么大，与它的作者所拥有财富有很大的关系。这本书里面说列出的原则，有太多是包含了作者的主观意识的，也就是说这本书里面的很多原则是不适合所有人去实践的。这本书最值得推荐的理由是里面有作者建立自己原则的方法论，也就是我们通常所说的授人与渔。作者自己的原则不一定适合我们，但是我们可以使用作者建立原则的方法论去建立自己的原则。</p>
<h3>七十二堂写作课</h3>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/2018shudan/72.jpg" alt="">
这是一本年代久远的书，是夏丏尊和叶圣陶合著的一部如何写作的书。是民国时期中学生的教材。大多数人高考过后写作水平和英语是直线下降的，但是即使在高中的巅峰时期，这本书里面大多数的写作方法我也是不知道的，所以感到很惭愧，就反复看了几遍，非常适合作为写作的入门书。看完这本书也许并不能帮助你写出惊艳的文字，但是至少可以发现自己文章的问题在哪里。</p>
<h3>黑客与画家</h3>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/2018shudan/heikeyuhuajia.jpg" alt="">
这并不是一本讲黑客技术的书，这其实是一本讲创业的书。这本书讨论的都是思考问题的方式。
创业者需要有不一样的思考方式，创业者的起步来自于一个想法的萌芽。大多数人受了多年的应试教育后根本就没有学会如何去思考。这本书通过一些不枯燥的例子来让教我们从不同的角度去思考同一个问题，创业之前先学会思考。</p>
<h3>韭菜的自我修养</h3>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/2018shudan/jiucai.jpg" alt="">
在推荐这本书的时候，我犹豫了一下，因为这个本身算不上是一本多好的书，而且涉及到一些敏感的话题，很有可能会被人喷，但是我还是想推荐出来。严格来说这可能都不算是一本书，非常薄，两个小时就可以读完。暂时不讨论这本书是否是用于洗白录音事件，李笑来人品是否有问题，只讨论这个小册子本身。这本小册子里面有值得学习的投资方法论。我觉得每个人都应该学习一点投资的知识，有一点投资的能力，这些能力可以帮助我们自身做出更好的决策。但是大多数好的投资类书籍都是大部头，没有充足的时间和精力是很难啃下来的，这本小册子让你在通俗的语言中学会投资中很重要的事。</p>
<h3>枪炮、病菌、与钢铁</h3>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/2018shudan/gun.jpg" alt="">
这是一本讲述人类发展进程的书，作者用独特的视角来解释了这个过程。作者是一个生物学家，他从生物学的角度出发，去解释为何欧亚人能够统治全世界，去理解现代世界及其诸多不公平形成的原因，反击了以种族主义为基础的人类史理论。这本书能对我们头脑中固定的观念造成很大的冲击，让我们可以从不同的视角上去感受整个人类的发展。</p>
<h3>罗生门</h3>
<p><img src="http://rayjun.oss-cn-beijing.aliyuncs.com/2018shudan/luoshengmen.jpg" alt="">
这是今年的书单里面唯一的一本虚构类书籍。这本书听过的人很多，但是看过的人应该不多。这是有助于认识人性复杂的一本书。这本书里面我们最熟悉的一个故事就是被黑泽明拍成电影的那个故事，出自罗生门的<strong>密林中</strong>，这个故事也就直接指代了罗生门这本书。但其实这本书不只是有揭露人性阴暗的故事，也有挺暖心的故事。这不也正是人自己么？除了阴暗面，也有充满希望的一面。</p>
<p>(图片来源于豆瓣读书)</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>学会写作</title>
    <url>/2019/01/27/%E5%AD%A6%E4%BC%9A%E5%86%99%E4%BD%9C/</url>
    <content><![CDATA[<p>如果一个人一生只能学习一个技能，那这个技能便是写作了。</p>
<p>很多时候觉得自己头脑中思绪万千，有很多的的想法将要喷涌而出，可是当拿出电脑准备将想法输出的时候，发现根本就写不出什么。这其实就是在思考的阶段出了问题，自己以为自己想清楚了，其实并没有。</p>
<p>写作和思考从来就是一体的，写作是思考结果的一个输出。如果大多数时候，只思考，不输出，那就会陷入一个自证的循环，很多的想法也就停留在脑子中。而且这些大多数的想法都是有缺陷，不完备的。</p>
<p>其实我在这里说的写作是宏观意义上的写作。不拘束于题材，甚至不局限于文字，如果你愿意，甚至可以用图、思维导图等方式来展现。我们这里讨论的写作并不是说要达到多高的水平，写作这件事情速成是不靠谱的，这是一件值得用一生去不断精进的技能。</p>
<h3>怎样开始写作呢？</h3>
<p>拿起纸笔写或者键盘敲就是了，不用管你写出来的是什么文体，这些都不重要，重要的是把脑中想好的话写出来。</p>
<p>写出来只是第一步。写出来之后自己需要反复的看，看了之后才能发现自己那部分遗漏了什么，然后再去构思这一部分，然后再补充。反复几次之后，一篇写作就算是完成了。</p>
<p>当完成一篇写作后，自己看了一遍后发现，这与我之前所想的完全不是一回事呀。这写都是正常的，在刚开始写作时，能够把一篇文章完整的写好已经是一件不容易的事情，所以这个时候不要有太重的挫折感，这是正常情况。</p>
<p>在写完最开始的几篇很难看的文章之后，就应该开始去输出了，就是需要将自己写好的文章发布出去，无论是通过博客还是各个写作平台。反正就是需要将自己写好文章拿去给别人看，接收别人的反馈。然后通过这些反馈再去审视自己的文章，发现其中的问题，并且在后续的写作过程中来避免这些问题。</p>
<h3>为什么要学习写作？</h3>
<p>为了写好一篇文章，你需要不断的去审视自己的头脑，然后不断去完备自己的想法。在这个过程中，需要不断的改善自己的思考方式。</p>
<p>写作的过程中，你会不断完善自己的思维体系，你写过的文章就是自己思维的成长轨迹，同时在写作的过程中持续的输出，那么也就不断提高了自己的影响力。</p>
<p>对自身的成长来说，积累的最好的方式也是写作，不论是专业方面的积累还是思维的积累。好记性不如烂笔头，能够用文字记下来的东西总比放在脑子里面更牢靠一些。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解 Java8 的函数式编程</title>
    <url>/2020/08/09/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Java8-%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>Java8 出现的时间已经不算短了，免费维护期马上也要到期了，官方已经开始推荐使用 Java11。</p>
<p>Java8 是革命性的一个版本，一直以来，Java 最受诟病的地方就是代码写起来很啰嗦，仅仅写一个 HelloWorld 都需要些很多的样板代码。</p>
<p>在 Java8 推出之后，啰嗦的代码有了很大的改观，Java 也可以写出简单优美的代码。最明显的改观就是 Java 开始支持函数式编程。</p>
<p>函数式编程的定义很晦涩，但是我们可以将函数式编程理解为函数本身可以作为参数进行传递，就是说，参数不仅仅可以是数据，也可以是行为（函数或者方法的实现其实就是逻辑行为）。</p>
<p>可能是 Java8 步子跨的太大，以至于现在还有很多人没有赶上来，依然用 Java8 在写 Java5 风格的代码。</p>
<p>这篇文章的目的就是彻底说清楚 Java8 的变化，以及快速全面的使用 Java8 的特性，让 Java 代码优雅起来。</p>
<h2>函数式接口</h2>
<p>在开始说 Java8 的函数式编程之前，我们需要说明一下，在 Java8 中新增加的一个概念，叫<strong>函数式接口</strong>。</p>
<p>这个函数式接口是 Java8 实现函数式编程的基础，正是这类接口的存在，才能把函数（方法）当做参数进行传递，至少表面上看起来是这样的，但是实际上传递的还是对象，这个问题我们下面再讨论，先回到函数式接口。</p>
<p>下面就是一个函数式接口：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数式看起来和普通的接口没有什么区别，唯一的区别是函数式接口只能有<strong>一个抽象方法</strong>。</p>
<p>如果你想让别人立马理解这个接口是函数式接口，可以加上 <code>@FunctionalInterface</code> 注解，这个注解不会提供任何额外的功能，仅仅用来表示这个接口是一个函数式接口。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只能有一个抽象方法是为了更方便的把函数作为参数来传递，这个后面再细说。</p>
<p>我们可以根据自己的需要来定义函数式接口，JDK 为了使用方便，内置了很多函数式接口，日常使用完全够了。</p>
<p>常用的函数接口有：</p>
<ul>
<li>Function</li>
<li>Predicate</li>
<li>Consumer</li>
</ul>
<p>函数式接口其实就这么简单，看到这里你可能还是对函数式接口不是很理解，没关系，现在你仅仅只需要记住<strong>函数式接口就是模板</strong>。</p>
<h2>Lambda 表达式</h2>
<p>说起 Java8 的函数式编程，很多人都知道 lambda 表达式，这也是 Java8 中最容易被人记住的地方。</p>
<p>先来通过一个直观的例子来了解一下 lambda，在操作 ArrayList 等数据结构时，我们有可能要对其中的数据进行排序，比如：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i1, Integer i2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i1.comparaTo(i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，真正有用的代码也有比较大小的那行，其他的都是样板代码。在这样的情况下，lambda 就很有用。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = (Integer i1, Integer i2) -&gt; &#123;<span class="keyword">return</span> i1.compareTo(i2);&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样看起来是不是很简单了，但是还是继续优化，可以把返回参数的部分也省略：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = (Integer i1, Integer i2) -&gt; i1.compareTo(i2)</span><br></pre></td></tr></table></figure></p>
<p>既然两个参数都是 Integer 那是不是也可以省略，最后就得到了下面这样的形式：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = (i1, i2) -&gt; i1.compareTo(i2)</span><br></pre></td></tr></table></figure></p>
<p>这就是 lambda 的力量，可以把上面那么多的代码浓缩成一行。</p>
<p>lambda 其实就是一段代码，但也不仅仅是一段代码，再简单的 lambda 也会有三部分，参数列表，箭头和 lambda 主体，上面的 <code>(i1, i2)</code> 就是参数列表， <code>i1.compareTo(i2)</code> 就是 lambda 主体，箭头把这两部分隔开了。</p>
<p>lambda 是匿名的，这点和 Java 中的匿名实现类有点像（本质上一样），而且它是一种函数，不属于任何类（属于类的函数称之为方法），并且可以作为参数进行传递，而且还很简洁。</p>
<p>看到这里，可能就有人猜到函数式接口和 lambda 之间可能有某些关系了，没错，我们已经快说到最重要的部分。</p>
<p>在这之前再来理解一个概念，函数签名，函数签名为可以表示一类函数，如果两个函数的以下部分相同，就可以说这两个函数的签名一致：</p>
<ul>
<li>函数参数及其类型</li>
<li>返回值及其类型</li>
<li>可能会抛出的异常</li>
<li>还有访问控制符（public等等）</li>
</ul>
<p>最关键的地方来了，<strong>只要 lambda 和函数式接口方法的签名一致，lambda 表达式就可以作为参数传入到以该函数式接口为参数类型的方法中</strong>。</p>
<p>来看个详细的例子， <code>Comparator</code> 接口的定义如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然 Comparator 中方法不止一个，但是抽象方法只有 <code>compare</code> 一个，上面的 lambda 完全可以作为 compare 方法的实现，实际上，<strong>lambda 表达式确实是作为函数式接口抽象方法的实现，而且，lambda 表达式为作为整个函数接口的实例</strong>。</p>
<p>到这里，真相大白，Java 8 的虽然支持了函数式编程，这不代表函数就是 Java中的一等公民了，每一个函数其实还是被包裹成一个对象，对象依然是 Java 中的一等公民。</p>
<p>所以简单来说，只要 lambda 的表达式的参数和返回类型可以与函数式接口中的抽象方法对的上，lambda 就可以作为该函数式接口的实现进行传递。</p>
<p>比如上面列举的几种函数式接口，其实就是对一些通用函数的抽象，比如 Function 函数式接口如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种就代表接受一个参数，返回另一个值的函数，只要满足这个要求的 lambda 表达式都可以作为 它的实现。</p>
<p>再比如 Predicate 接口，代表接受一个参数返回一个布尔值的函数：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Comsumer 接口表示接受一个参数，什么都不返回的函数：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果这样理解起来还是有点困难，那就把这些函数式接口理解为 lambda 表达式的类型。</p>
<h2>类型检查和类型推断</h2>
<p>在上面我们说到了只要函数式接口抽象方法的函数签名与 lambda 一致，那么就可以把 lambda 表达式作为该函数式接口的实现。</p>
<p>上面的例子中， lambda 的参数类型也是可以省略的，那么 Java 是如何判断 lambda 是否与函数式接口匹配呢？</p>
<p>如果 lambda 表达式中，参数和返回值的类型都省略之后，需要从使用 lambda 的上下文推断出来。</p>
<p><img src="1.png" alt=""></p>
<h2>方法引用</h2>
<p>本来到这里应该就很完美了，lambda 够简洁，用它写代码，可以省略很多无用的样本代码，但是 lambda 也不完美，因为 lambda 表达式的代码很难复用，而且很多的 lambda 表达式仅仅就是调用了其他的方法。</p>
<p>这个时候，方法引用就可以派上用场了，比如上面的例子，其实仅仅就是调用了 <code>Integer.compareTo()</code> 方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = (i1, i2) -&gt; i1.compareTo(i2)</span><br></pre></td></tr></table></figure></p>
<p>还可以简化成下面的样子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = Integer::compareTo</span><br></pre></td></tr></table></figure></p>
<p>使用方法引用的时候，要使用 <code>::</code> ，而且任何方法都可以这样被引用，无论是静态方法还是实例方法。</p>
<p>方法引用可以被认为是 lambda 的语法糖，使用方法引用可以让代码更加简洁，更直观，看到方法引用的名称就能大概知道代码的逻辑，并且还可以对一些代码进行复用。</p>
<h2>写出Java8 风格的代码</h2>
<p>在 Java8 之后，很多代码的写法应该摒弃，下面列举一些常见的例子。</p>
<h3>遍历 List</h3>
<p>Java8 以前：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java8 及以后：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure></p>
<p>forEach 接收 Consumer 类型的函数，而 System.out.println() 刚好就符合要求。</p>
<h3>遍历 Map</h3>
<p>Java8 以前：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">"Key: "</span> + entry.getKey() + <span class="string">", Value:"</span> + entry.getValue());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java8 及以后：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((k, v) -&gt; &#123;System.out.println(<span class="string">"Key: "</span>+ k +<span class="string">", Value: "</span>+ v)&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里的 forEach 不是接收 Consumer 类型的函数，而是接收 BiConsumer 类的函数，可以用来处理 map 这种包含 key-value 类型的数据，在大多数场景下，内置的函数式接口以及足够我们使用，只有在一些特殊的场景下才需要自己定制。</p>
<p>这里也没有现成的方法引用，所以就可以使用 lambda 表达式来实现。</p>
<h3>执行异步任务</h3>
<p>假如要使用线程池来执行任务。</p>
<p>Java8 以前：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2000</span>));</span><br><span class="line"></span><br><span class="line">executor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread pool execute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Java8 以后：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2000</span>));</span><br><span class="line"></span><br><span class="line">executor.submit(() -&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"Thread pool execute"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>也可以使用 lambda 来解决这个问题，Runnable 也是一个函数式接口。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java 函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2018/04/11/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>插入排序通过构建有序序列，对于未排序的数据，从已排序的序列从后向前扫描，并找到相应的位置插入。</p>
<h4>算法描述</h4>
<ol>
<li>从第一个元素开始，默认第一个元素已排序；</li>
<li>取出下一个元素i，从已排序的元素序列中从后向前扫描；</li>
<li>对比每一个已排序的元素，将大于(小于)改元素的已排序元素向后移一个位置直到找到小于(大于)该元素的位置，将i  排在这个元素的后面；</li>
<li>重复2-3直到遍历结束，排序完成；</li>
</ol>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/849589-20171015225645277-1151100000.gif" alt=""></p>
<h4>代码实现</h4>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                arr[j-<span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>日志系列-Log4j2简明教程</title>
    <url>/2019/11/01/%E6%97%A5%E5%BF%97%E7%B3%BB%E5%88%97-Log4j2%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>在大型系统中，日志是一个很重要的部分，线上问题的排查很大程度上依赖日志。记录日志的过程，大体上可以分成三个步骤：</p>
<ul>
<li>在程序中对原始日志信息进行采集</li>
<li>对采集下来的日志信息进行格式化</li>
<li>将格式化好的日志信息写入目的地</li>
</ul>
<p>Log4j2 的架构也自然是按照这个来的，Log4j2 中有三个重要的组件分别实现了这些功能，分别是 <code>Logger</code> 、<code>Layout</code> 和<code>Appender</code>，日志数据流向图如下:
<img src="https://rayjun.oss-cn-beijing.aliyuncs.com/Java/log4j2/log4j2.jpg" alt=""></p>
<h3>Log4j2 使用</h3>
<p>Log4j2 使用很简单，以 Maven 为例，只需要在 <code>pom.xml</code> 中添加:</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后就可以在 Java 代码中直接使用:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4j2HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger(Log4j2HelloWorld.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果不加配置文件，默认的输出级别是 <code>ERROR</code></p>
</blockquote>
<h3>配置详解</h3>
<p>Log4j2 有两种配置方式:</p>
<ul>
<li>通过 <code>ConfigurationFactory</code> 使用编程的方式进行配置</li>
<li>通过配置文件配置，支持 <code>XML</code> 、<code>JSON</code> 、<code>YAML</code> 和 <code>properties</code> 等文件类型</li>
</ul>
<p>通过编程实现的方式如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Plugin</span>(name = <span class="string">"CustomerConfigurationFactory"</span>, category = ConfigurationFactory.CATEGORY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerConfigurationFactory</span> <span class="keyword">extends</span> <span class="title">ConfigurationFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String[] getSupportedTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Configuration <span class="title">getConfiguration</span><span class="params">(LoggerContext loggerContext, ConfigurationSource configurationSource)</span> </span>&#123;</span><br><span class="line">        ConfigurationBuilder&lt;BuiltConfiguration&gt; builder = newConfigurationBuilder();</span><br><span class="line">        builder.setStatusLevel(Level.INFO);</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Log4j2</code> 在找不到配置文件的情况下会使用一个默认的配置，默认的配置只会在控制台打印日志，并且默认级别是 <code>Level.ERROR</code>。</p>
<p>在 <code>Log4j2</code> 中，默认实现了四种 <code>ConfigurationFactory</code>，分别用来加载 <code>JSON</code> <code>YAML</code> <code>properties</code> <code>XML</code> 格式的配置文件。</p>
<p>默认的配置文件名称为 <code>log4j2</code>，会根据 <code>log4j2</code> 的文件类型匹配相应的 <code>ConfigurationFactory</code> 的具体实现。比如 <code>log4j2.xml</code> 会使用 <code>XmlConfigurationFactory</code> 来读取配置文件，其它类型的配置文件同理。</p>
<blockquote>
<p>假如同时存在 <code>log4j2.properties</code> <code>log4j2.yaml</code> <code>log4j2.json</code> <code>log4j2.xml</code> 四个配置文件，加载的优先级为 <code>properties</code> &gt; <code>yaml</code> &gt; <code>json</code> &gt; <code>xml</code>。</p>
</blockquote>
<p>四种配置文件的配置方式基本一致，区别在于每种配置文件的语法不一样。下面以 XML 为例进行解析。</p>
<blockquote>
<p>XML 有两种配置模式，<strong>简约模式</strong> 和 <strong>严格模式</strong></p>
</blockquote>
<h4>Configuration</h4>
<p>Confirguration 是配置文件根元素，每个配置文件有且仅有一个。如果不使用配置文件使用<strong>默认配置</strong>，以下配置与默认配置等价:
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
每一个配置都至少包含一个 <code>Appender</code> 和 <code>Logger</code>。<code>status</code> 属性用于配置 Log4j2 内部的的日志级别。</p>
<p>Log4j2 可以自动检测配置文件的变化，<code>monitorInterval</code> 属性可以配置自动检测配置文件的时间，这个属性最小的值为 5，代表 5 秒检测一次。
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">monitorInterval</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line">....</span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4>Logger</h4>
<p>Logger 元素用于配置日志记录器。Logger 有两种形式，<code>Logger</code> 和 <code>Root</code>，两个区别在于 Root 没有 <code>name</code> 属性并且不支持 <code>additivity</code> 属性。</p>
<p>假如我们要获取一个特定类的的某个级别的日志。调高日志的级别无法完成这样的需求。一种可行的方式是在 Loggers 中添加一个 Logger，配置方式如下:</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"cn.rayjun.Log4j2HelloWorld"</span> <span class="attr">level</span>=<span class="string">"trace"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br></pre></td></tr></table></figure>
这样配置，除了 <code>cn.rayjun.Log4j2HelloWorld</code> 类会打印出 <code>trace</code> 级别的日志，其他就只会打印出 <code>error</code> 级别的日志，打印结果如下:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">19:59:06.957 [main] TRACE cn.rayjun.Log4j2HelloWorld - Enter</span><br><span class="line">19:59:06.957 [main] TRACE cn.rayjun.Log4j2HelloWorld - Enter</span><br><span class="line">19:59:06.959 [main] ERROR cn.rayjun.Log4j2HelloWorld - Hello world</span><br><span class="line">19:59:06.959 [main] ERROR cn.rayjun.Log4j2HelloWorld - Hello world</span><br></pre></td></tr></table></figure>
但是上面打印的日志有个问题，信息都被打印了两遍，为了解决这个问题，需要添加 <code>additivity</code> 参数并且置为 false，如下配置：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"cn.rayjun.Log4j2HelloWorld"</span> <span class="attr">level</span>=<span class="string">"trace"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br></pre></td></tr></table></figure>
默认情况下 Logger 都是同步的，但是也有异步的实现，Root 的异步版本是 <code>AsyncRoot</code>，Logger 的异步版本是 <code>AsyncLogger</code>，异步 Logger 依赖外部队列 <a href="http://lmax-exchange.github.io/disruptor/" target="_blank" rel="noopener">LMAX Disruptor</a>。</p>
<p>使用异步 Logger 需要加上外部依赖:
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
使用异步 Logger:
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">AsyncRoot</span> <span class="attr">level</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">AsyncRoot</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Logger 在具体使用中需要声明一个 Logger 对象，官方推荐将 Logger 声明为一个静态变量，可以提高日志记录的性能:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger(Log4j2HelloWorld.class);</span><br></pre></td></tr></table></figure></p>
<h4>Appender 配置</h4>
<p><code>Appender</code> 负责将日志分发到相应的目的地。也就是说 <code>Appender</code> 决定日志以何种方式展示，上面使用到的就是 <code>ConsoleAppender</code>，这个 Appender 会将日志直接打印到控制台。同时还支持将日志输出到<code>文件</code>、<code>数据库</code>、<code>消息队列</code> 。</p>
<p><code>FileAppender</code> 基本配置如下：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"MyFile"</span> <span class="attr">fileName</span>=<span class="string">"logs/app.log"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d %p %c&#123;1.&#125; [%t] %m%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br></pre></td></tr></table></figure>
如果想要把日志记录到数据库中，那就使用<code>JDBCAppender</code>， 基本配置如下：
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">JDBC</span> <span class="attr">name</span>=<span class="string">"databaseAppender"</span> <span class="attr">tableName</span>=<span class="string">"dbo.application_log"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">DataSource</span> <span class="attr">jndiName</span>=<span class="string">"java:/comp/env/jdbc/LoggingDataSource"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Column</span> <span class="attr">name</span>=<span class="string">"eventDate"</span> <span class="attr">isEventTimestamp</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Column</span> <span class="attr">name</span>=<span class="string">"level"</span> <span class="attr">pattern</span>=<span class="string">"%level"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Column</span> <span class="attr">name</span>=<span class="string">"logger"</span> <span class="attr">pattern</span>=<span class="string">"%logger"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Column</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">pattern</span>=<span class="string">"%message"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Column</span> <span class="attr">name</span>=<span class="string">"exception"</span> <span class="attr">pattern</span>=<span class="string">"%ex&#123;full&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">JDBC</span>&gt;</span></span><br></pre></td></tr></table></figure>
默认情况下 Appender 都是同步的，就是说日志产生的时候就会进行处理。但是有时候会从程序性能的角度进行考虑，生成的日志不会立即进行刷盘或者进行传输，而是在一个合适的时间集中进行处理，配置方式如下，异步 Appender 使用 <code>ArrayBlockingQueue</code> 作为队列，与异步 Logger 不同，异步 Appender 不需要外部依赖，但是官方推荐使用异步 Logger 而不是异步 Appender：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"MyFile"</span> <span class="attr">fileName</span>=<span class="string">"logs/app.log"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d %p %c&#123;1.&#125; [%t] %m%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Async</span> <span class="attr">name</span>=<span class="string">"Async"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"MyFile"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Async</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>把日志保存为文件是一个常用的操作，保存在文件中的日志以追加方式写入，但是单个文件不可能无限增大，也不可能手工来分割日志文件，所以需要通过自动的方式来分割日志。这就需要使用 <code>RollingFileAppender</code>，通过设定日志分割的条件。分割的条件可以从两个方面进行设定，以时间频率或者日志文件的大小来触发日志的分割。</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFile"</span> <span class="attr">fileName</span>=<span class="string">"logs/app.log"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">filePattern</span>=<span class="string">"logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d %p %c&#123;1.&#125; [%t] %m%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"250 MB"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<code>TimeBasedTriggeringPolicy</code> 会与 filePattern 的配置相匹配，如果 filePattern 是 <code>{yyyy-MM-dd HH-mm}</code> ，最小的时间粒度是分钟，那么就会每隔一分钟生成一个文件，如果改成 <code>{yy-MM-dd HH}</code>，最小时间粒度是小时，那么就会每隔一个小时生成一个文件。<code>SizeBasedTriggeringPolicy</code> 表示设定日志的大小，上面的配置是指日志大小到 250M 后开始生成新的日志文件。</p>
<p><code>RollingRandomAccessFileAppender</code> 与 <code>RollingFileAppender</code> 在功能上基本一致，但是底层的实现有所区别，RollingFileAppender 底层是 <code>BufferedOutputStream</code>，RollingRandomAccessFileAppender 底层是使用 <code>ByteBuffer</code> + <code>RandomAccessFile</code> ，性能上有了很大的提升。</p>
<h4>Layouts</h4>
<p>Appender 会使用 <code>Layout</code> 来对日志进行格式化。Lo4j1 和 Logback 中的 Layout 会把日志转成 String，而在 Log4j2 中使用的则是 byte 数组，这是从性能的角度进行的优化。</p>
<p>Layout 配置支持多种方式。用的最多的方式就是 <code>PatternLayout</code>，就是通过正则表达式来格式化日志，应用的也最多，基本配置如下：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d %p %c&#123;1.&#125; [%t] %m%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>%d 表示时间，默认情况下表示打印完整时间戳 <code>2012-11-02 14:34:02,123</code>，可以调整 %d 后面的参数来调整输出的时间格式</li>
<li>%p 表示输出日志的等级，可以使用 %highlight 来高亮显示日志级别</li>
<li>%c 用来输出类名，默认输出的是完整的包名和类名，%c{1.} 输出包名的首字母和完整类名</li>
<li>%t 表示线程名称</li>
<li>%m 表示日志内容，%M 表示方法名称</li>
<li>%n 表示换行符</li>
<li>%L 表示打印日志的代码行数</li>
</ul>
<h4>Filter</h4>
<p>Filter 用于过滤一些日志信息，Filter 在过滤每一条日志时都会返回一个值 <code>ACCEPT</code>、 <code>DENY</code> 或者<code>NEUTRAL</code>。</p>
<p>不同的 Filter 的有不同的用处，<code>BrustFilter</code> 用于防止日志流量过大，还可以使用 <code>DynamicThresholdFilter</code> 根据属性来过滤特定级别的日志。可以根据具体的需要选择相应的 Filter</p>
<h4>完整配置示例</h4>
<p>假设现在有一个日志需求：日志以文件的形式进行保存，需要保存完整的日志信息，包括日志对应的类代码行数等，并且需要根据时间和日志文件的大小生成新的日志文件。</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"warn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%-5p %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%t] [%C.%M] [%m]%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingRandomAccessFile</span> <span class="attr">name</span>=<span class="string">"$&#123;service_name&#125;-log"</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">fileName</span>=<span class="string">"~/$&#123;service_name&#125;/$&#123;service_name&#125;.log"</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">filePattern</span>=<span class="string">"~/$&#123;service_name&#125;/$&#123;service_name&#125;.log.%d&#123;yyyyMMddHH&#125;"</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">append</span>=<span class="string">"true"</span> <span class="attr">immediateFlush</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">pattern</span>=<span class="string">"[%-5p %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%t] [%C.%M] [%m]%n"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"250 MB"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingRandomAccessFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AsyncRoot</span> <span class="attr">level</span>=<span class="string">"$&#123;log_level&#125;"</span> <span class="attr">includeLocation</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"$&#123;service_name&#125;-log"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">AsyncRoot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Logger 上如果加上了 includeLocation 后，日志性能会下降的很厉害，如果日志的位置信息不是必要的，就不需要加上</p>
</blockquote>
<h3>自定义日志级别</h3>
<p>Log4j2 中内置的日志级别有：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>OFF</td>
<td>0</td>
</tr>
<tr>
<td>FATAL</td>
<td>100</td>
</tr>
<tr>
<td>ERROR</td>
<td>200</td>
</tr>
<tr>
<td>WARN</td>
<td>300</td>
</tr>
<tr>
<td>INFO</td>
<td>400</td>
</tr>
<tr>
<td>DEBUG</td>
<td>500</td>
</tr>
<tr>
<td>TRACE</td>
<td>600</td>
</tr>
<tr>
<td>ALL</td>
<td><code>Integer.MAX_VALUE</code></td>
</tr>
</tbody>
</table>
<p>如果这些日志还不满足需求，可以自定义日志的级别，可以在配置文件当中定义，也可以在代码中直接定义。每一个自定义的日志都由两部分组成，<strong>级别名称</strong>和<strong>级别的值</strong>，可以根据自己的需要进行定义。</p>
<p>在 <code>Confguration</code> 节点下加上以下自定义级别，就可以在 <code>Logger</code> 中使用
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CustomLevels</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CustomLevel</span> <span class="attr">name</span>=<span class="string">"DIAG"</span> <span class="attr">intLevel</span>=<span class="string">"350"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CustomLevel</span> <span class="attr">name</span>=<span class="string">"NOTICE"</span> <span class="attr">intLevel</span>=<span class="string">"450"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">CustomLevel</span> <span class="attr">name</span>=<span class="string">"VERBOSE"</span> <span class="attr">intLevel</span>=<span class="string">"550"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">CustomLevels</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"trace"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span> <span class="attr">level</span>=<span class="string">"diag"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br></pre></td></tr></table></figure>
在代码中使用就更加方便:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.log(Level.forName(<span class="string">"CUSTOMER_LEVEL"</span>, <span class="number">350</span>), <span class="string">"customer level"</span>);</span><br></pre></td></tr></table></figure></p>
<h3>配合 Slf4j 使用</h3>
<p>使用 <code>Slf4j</code> 非常简单，只需要在项目中加入以下依赖：</p>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
然后就可以在代码中使用了：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slf4jDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = LoggerFactory.getLogger(Slf4jDemo.class);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"Slf4j log info"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（完）</p>
<ul>
<li>https://logging.apache.org/log4j/2.x/manual/index.html</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>打造高效 Windows 开发环境指南</title>
    <url>/2018/08/12/%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88-Windows-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>之前开发的时候大部分使用的都是 Mac OS，因为 相比于 Windows ，Mac OS 有着更好的颜值和更高效的工具，在 Mac OS上，有几个关键的效率工具：</p>
<ul>
<li>Alfred 高效搜索工具</li>
<li>Iterm2 + oh-my-zsh 命令行工具</li>
</ul>
<p>在之前，就开发环境来说，基本就是一边倒的局势，但是这个情况在 WSL 出现之后就带来了转机。</p>
<h4>WSL 是什么</h4>
<p>WSL 的全称是 Windows Subtem for Linux。WSL 可以直接在 Windows 上运行 Linux 环境，包括绝大多数的</p>
<p>命令行工具和应用。同时可以从linux的命令行里运行 Windows 程序，也可以在 Windows 中运行 Linux 程序。重</p>
<p>点是这些环境是直接运行在 Linux 环境上的，而不需要安装一个繁重的虚拟机。安装 WSl 非常简单，只需要到 Microsoft Store 中下载：</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E7%89%872.png" alt=""></p>
<p>然后用管理员身份打开 <code>PowerShell</code> ，执行以下命令启用 WSL:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure></p>
<p>也可以通过控制面板中的程序和功能菜单中的启用或者关闭 Windows 功能选项来开启 WSL 功能。</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E7%89%873.png" alt=""></p>
<p>然后重启电脑就完成了安装。</p>
<p>然后就可以在 WSl 安装任何你想要的开发环境。</p>
<h4>hpyer 终端</h4>
<p>对于Mac 上我最满意的地方就是有一个又好用颜值又高的终端。所以对于对于一个高效的开发环境来说，没有一个好用的终端肯定是不合格的。<code>hyper</code>的出现在很大程度上解决了 Windows 上备受诟病的终端问题。而且在 WSL 的配合下，在 Windows 上也能用上 oh-my-zsh 上了。有人就意见了，Windows 能有好看的终端？不信你看:</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/tupian5.png" alt=""></p>
<p>这根本就看不出来是 Windows 上的终端。然后装上 <a href="https://ohmyz.sh/" target="_blank" rel="noopener">oh-my-zsh</a> 和<a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md" target="_blank" rel="noopener">zsh-autosuggestions</a>，体验与 <code>Mac OS</code>上的相差就不是很大了。</p>
<h4>Wox+Everything 高效搜索工具</h4>
<p><a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a> 是 <code>Mac</code>上的另一个大杀器，是 spotlight 的增强版，能够大大的提升文件、应用、网页搜索的效率。但是可惜的是这个工具只能在 <code>Mac</code> 上使用，但是在 Windows 上通过 <a href="http://www.wox.one/" target="_blank" rel="noopener">Wox</a> 和 <a href="http://www.voidtools.com/" target="_blank" rel="noopener">Everything</a> 的组合基本也能完成关键的功能。<code>EveryThing</code> 是 Windows 搜索的增强版，如果不安装这个，<code>Wox</code>就会使用 Winodws 的基本搜索。那样搜索的效果就差不少了。看一下搜索的效果:</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/tupian6.png" alt=""></p>
<p>web 搜索:</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E7%89%874.png" alt=""></p>
<p>这个工具其实不仅仅适用于技术人员，对于非技术人员来说，在效率上也是一大助力。</p>
<p>在 Windows 上有了了 WSL 之后，Windows 对开发者不友好的锅基本就甩了大半了，特别是现在 Windows相关的硬件做的也越来越好，整体的颜值也在不断的提升，颜值是第一生产力， 所以现在选择开发工具的时候也不一定要选择 Mac 了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mac windows</tag>
      </tags>
  </entry>
  <entry>
    <title>是的，我又换工作了</title>
    <url>/2020/12/27/%E6%98%AF%E7%9A%84%EF%BC%8C%E6%88%91%E5%8F%88%E6%8D%A2%E5%B7%A5%E4%BD%9C%E4%BA%86/</url>
    <content><![CDATA[<p>是的，我又换工作了。</p>
<p>距离上次换工作，还没有到一年半的时间。我自己也没有想到，会在年底换工作。</p>
<p>至于换工作的原因，也没有那么特殊。对于一份自己满意的工作，需要满足两点，一是能够在其中实现自己的价值，获得足够的成长，而是获得自己还满意的薪酬。如果这两者有一点满足不了，那就可以成为换工作的原因了，我自然也不例外。</p>
<p>太频繁的换工作，自然是不好的事情。但是当自己内心的预期被打破，再强行留下来只会让自己工作状态更差，这样对公司不好，对自己更不好，变动要比不变动好。</p>
<p>这次换工作对我来说，调整特别大，一方面是工作内容的变化，另一方面是技术栈的变化。在小米这边做的是支付的风控系统，然后主要使用的技术栈是 Java 系列，到腾讯这边之后，业务变更为区块链，然后技术栈也变成了 Go。</p>
<p>在之前自己有过一些区块链的储备，所以这次在面试的时候，这些知识储备也是加分项。</p>
<p>区块链一直都在被质疑，被吐槽没有实际的落地项目（其实已经有很多了），但是对于新生事物来说，被质疑，被看衰都是很正常的事情。我当然也没有 100% 的把握说这方面在未来一定能够发展的很好。但对于这样的一个新生领域，能够投入进去，去贡献自己的一份力量，也是一个令人兴奋的事情。</p>
<p>在这里，后续分享的内容会变成区块链和 Go，如果你对这方面的内容还感兴趣，欢迎继续关注。</p>
<p>另外说一下，我目前这个团队，还在大量的招人，后端、产品、前端都还在大量招，base 在北京/深圳。如果对这个领域感兴趣，欢迎来投递简历，可以直接留言咨询，也可以直接发送简历到 rayjun0412@gmail.com。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>日志系列-Java日志框架简介</title>
    <url>/2019/10/26/%E6%97%A5%E5%BF%97%E7%B3%BB%E5%88%97-Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>日志对于程序很重要，日常分析生产环境问题的时候，基本就靠日志了。
Java 中有很多记录日志的工具，很多时候不太容易分清楚，比如一会 <code>SLF4J</code> ，一会 <code>Log4j</code>，后面还有 <code>Log4j2</code>，让人傻傻分不清。</p>
<h4>日志框架有哪些</h4>
<p>Java 中主流的日志框架如下：</p>
<ul>
<li><a href="http://logging.apache.org/log4j/1.2/index.htm" target="_blank" rel="noopener">Log4j</a></li>
<li><a href="https://logging.apache.org/log4j/2.x/index.html" target="_blank" rel="noopener">Log4j2</a></li>
<li><a href="http://logback.qos.ch/" target="_blank" rel="noopener">Logback</a></li>
</ul>
<p>Log4j 是一个很经典的日志框架，有很广泛的应用，但是在 2015 年官方宣布不在维护，转而推广 Log4j2，Log4j2 是 Log4j 的升级版，Log4j2 吸收了 Log4j 和其他框架的优点，同时也规避了 Log4j 存在的问题。</p>
<p>Logback 的作者与 Log4j 的作者是同一个人，Logback 的实现方式与 Log4j 的实现方式差不多，但是提升了性能和一些配置方式，原生支持 Slf4j。</p>
<p>JDK 中本身的日志 API，缺乏缓冲处理，在生产环境对性能的影响很大，相比于专门的日志框架功能差太多，所以不会用到生产环境中。</p>
<p>除了这些框架外，还有其他用途的日志框架，比如 <a href="https://tinylog.org/v2/" target="_blank" rel="noopener">tinylog</a>，<a href="https://github.com/zalando/logbook" target="_blank" rel="noopener">Logbook</a> 等框架。</p>
<h4>Slf4j 是什么</h4>
<p>Slf4j 是一套标准的日志接口。它本身是没有记录日志的功能的，需要依赖上面提到的那些日志框架。使用 Slf4j 的好处就是日志具体的记录方式和接口完全分离了。即使要换其他的日志框架，也不用改动代码。</p>
<p>假如你需要使用日志打印 <code>Hello World</code>，在 Log4j 中，需要这么做:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = Logger.getLogger(Log4jDemo.class.getName());</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      log.info(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在 Log4j2 中，需要这么做:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.LogManager</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4j2Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LogManager.getLogger(Log4jDemo.class);</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      log.info(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
不同的日志框架使用的方式不一样，这样一旦需要换一个日志框架，将会是一件非常痛苦的事情，如果使用 Slf4j，不论底层使用的是哪一个日志框架，都可以使用相同的形式来记录日志:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slf4jDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> statis Logger logger = LoggerFactory.getLogger(Slf4jDemo.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Hello world."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以不论具体使用的是什么日志框架，都可以在上面套一个 <code>Slf4j</code>。</p>
<p><a href="http://commons.apache.org/proper/commons-logging/" target="_blank" rel="noopener">Apache Commons Logging</a> 的目标与 Slf4j 是一致的，但是 Apache Commons Logging 的 API 没有 Slf4j 的丰富，而且限制太多，自然就没有 Slf4j 受欢迎。</p>
<h4>日志框架用哪个</h4>
<p>那么问题来了，任何框架都需要应用到实际的项目当中。</p>
<p>根据上面的讨论， Slf4j 肯定是需要的，那么底层的日志框架应该使用哪个。Log4j 肯定就不考虑了，Log4j2 就是为了干掉 Log4j 而诞生的。所以选择就集中在了 Log4j2 与 Logback 之间。</p>
<p>在生产环境中，会产生大量的日志，这些日志最后都是需要写入到磁盘当中的。所以 IO 性能会影响日志框架的性能。而提升 IO 性能的有效方法就是提供缓冲区，先把日志写入到缓冲区，然后在特定的条件下将日志写入到磁盘当中。Log4j2 和 Logback 都提供了缓冲能力，也就是异步写入日志的能力。</p>
<p><a href="https://www.sitepoint.com/which-java-logging-framework-has-the-best-performance/" target="_blank" rel="noopener">性能测试</a>显示，Log4j2 在记录同步日志的性能上比 Logback 要好 25% 左右，是所有的日志框架中最好的。Log4j2 和 Logback 在异步日志上性能差不多，但是 Logback 在记录异步日志功能上存在一些未解决的 bug，所以如果要使用异步日志，就不推荐使用 Logback。并且 Log4j2 比其他的日志框架更能适应多线程的环境。</p>
<p>其他日志框架有的优点， Log4j2 都有，其他框架有的问题，Log4j2 都没有，所以选择 Log4j2 大概率是不会错的，所以 <code>Slf4j + Log4j2</code> 是一个比较好的选择。</p>
<p>后面会写一个日志专题系列。</p>
<p>(完)</p>
<ul>
<li>https://www.sitepoint.com/which-java-logging-framework-has-the-best-performance/</li>
<li>https://en.wikipedia.org/wiki/Java_logging_framework</li>
<li>https://dzone.com/articles/java-logging-frameworks-and-tools</li>
<li>https://www.baeldung.com/java-logging-intro</li>
<li>https://stackify.com/compare-java-logging-frameworks/</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构简明教程</title>
    <url>/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>数据结构的重要性无需多说，本文总结了常用的数据结构及其特点和适用场景，具体有：</p>
<ul>
<li>数组</li>
<li>链表</li>
<li>栈</li>
<li>队列</li>
<li>跳表</li>
<li>散列表</li>
<li>树</li>
<li>图</li>
</ul>
<h3>数组</h3>
<p>数组是一种<strong>线性表</strong>数据结构，它用一组连续的内存空间，来存储一组相同的类型的数据。</p>
<p><strong>数组有两个特点：</strong></p>
<ul>
<li>数据线性排列，每个数据最多有前和后两个方向</li>
<li>有着<strong>连续</strong>的内存空间和相同类型的数据</li>
</ul>
<p>这两个特点带来随机访问的特性，根据下标随机访问的时间复杂度为 $O(1)$，但是为了保持内存数据的连续性，会导致插入和删除这两个操作比较低效，因为需要不断去移动数据。</p>
<p>随机访问实际上是通过<strong>寻址公式</strong>来实现的，为了让寻址公式可以正常运行，那么要求数据中存储的数据类型必须要一样。</p>
<p><strong>寻址公式</strong>:
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[i]_address &#x3D; base_address + i * data_type_size</span><br></pre></td></tr></table></figure></p>
<h3>链表</h3>
<p>链表是通过<strong>引用（指针）<strong>将零碎的内存块串联起来。每一个内存块称之为</strong>结点</strong>。</p>
<p>常见的链表类型有：</p>
<ul>
<li>单链表</li>
<li>双向链表</li>
<li>循环联表</li>
</ul>
<p>链表的第一个结点叫<strong>头结点</strong>，最后一个节点叫<strong>尾节点</strong>，尾节点的 next 指向 NULL。</p>
<p>链表结点的结构如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;        </span><br><span class="line">     Node next; <span class="comment">// 记录下一个结点</span></span><br><span class="line">     Node prev; <span class="comment">// 记录上一个结点，双向链表才会有</span></span><br><span class="line">     <span class="keyword">int</span> data; <span class="comment">// 存储数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>链表与数组的不同之处：</strong></p>
<ul>
<li>数组内存连续，链表内存不连续</li>
<li>数组本身不支持动态扩容，链表本身支持动态扩容</li>
</ul>
<p><strong>链表和数组的性能对比：</strong></p>
<table>
<thead>
<tr>
<th>时间复杂度</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入、删除</td>
<td>$O(N)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>随机访问</td>
<td>$O(1)$</td>
<td>$O(n)$</td>
</tr>
</tbody>
</table>
<h3>栈</h3>
<p>栈是一种操作受限的线性表，只允许在一段插入和删除数据，<strong>后进者先出，先进者后出</strong>。</p>
<p><strong>栈的实现方式：</strong></p>
<ul>
<li>使用数组实现的栈称之为顺序栈</li>
<li>使用链表实现的栈称之为链式栈</li>
</ul>
<p>栈的时间复杂度和空间复杂度都是 O(1)。<strong>顺序栈</strong> 本身是不支持扩容的，但是可以通过将其全部元素拷贝到另一个更大的数组中实现扩容。在扩容的过程中，使用摊还分析可以得出平均的时间复杂度为 O(1)。</p>
<p><strong>栈的应用：</strong></p>
<ul>
<li>函数调用栈</li>
<li>表达式求值</li>
<li>括号匹配</li>
</ul>
<h3>队列</h3>
<p>队列也是一种操作受限的线性表。特点是先进者先出</p>
<p>队列和栈非常相似，只有两个操作，入队（enqueue）和出队（dequeue）两个操作。</p>
<p><strong>队列的实现方式：</strong></p>
<ul>
<li>使用数组实现的<strong>顺序</strong>队列</li>
<li>使用链表实现的<strong>链式</strong>队列</li>
</ul>
<p>数组实现队列的时候会有数据搬移的问题，如果为了彻底解决这个问题，可以通过实现 <strong>循环队列</strong> 的方式来解决问题。</p>
<p><strong>队列的应用：</strong></p>
<ul>
<li>使用数组实现的循环队列</li>
<li>阻塞队列（生产者-消费模型）</li>
<li>并发队列</li>
</ul>
<h3>跳表</h3>
<blockquote>
<p>通过对链表添加索引，就可以支持“二分”查找</p>
</blockquote>
<p>跳表可以支持快速的插入、删除、查找操作，在一些场景下甚至可以替代红黑树。</p>
<p><strong>跳表的实现：</strong></p>
<p>跳表其实就是在有序链表的基础上，每隔 k 个节点提取一个节点到上一级，抽出来的那一层就是索引层。
加了一层索引之后，查找一个节点需要遍历的节点就少了，查找效率也就提高了。而且这个索引可以添加多层。</p>
<p><strong>链表的时间复杂度：</strong></p>
<p>跳表的高度是logmn，每隔 m 节点建立一个索引，n 为节点总数，可以适当增大 m 来减小跳表的时间复杂度。 跳表查询的时间复杂度为 O(logn), 空间复杂度为 O(n)。</p>
<p><strong>跳表索引的更新：</strong></p>
<p>在往跳表中插入数据的过程中，需要更新索引，如果不更新，将会使跳表退化成链表，链表的更新是通过一个随机函数来更新的，比如随机函数生成 k，那么就将数据更新到 1 ~ k 级索引中。</p>
<p><strong>跳表的应用：</strong></p>
<ul>
<li>redis</li>
</ul>
<h3>散列表</h3>
<p>散列表也称之为<strong>哈希表</strong>。</p>
<blockquote>
<p>散列表是用<strong>数组</strong>支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。</p>
</blockquote>
<h4>散列表的实现</h4>
<p>散列表的结构与数组类似，访问元素的时间复杂度也是 O(1)。散列表通过<strong>散列函数（哈希函数）<strong>将散列表中每个元素的</strong>键（关键字）<strong>映射成</strong>散列值</strong>。在查询的过程中，使用相同的散列函数将键转化成散列值并且快速访问到数据。</p>
<p>所以对于一个散列表来说，散列函数（hash(key)）是最为关键的一点，<strong>hash</strong>就是哈希函数，<strong>key</strong>是键或者关键字。构建哈希函数有三个要点：</p>
<p><strong>1.</strong> 散列函数计算得到的散列是一个非负整数
<strong>2.</strong> 如果 key1 == key2，那么 hash(key1) == hash(key2)
<strong>3.</strong> 如果 key1 != key2，那么 hash(key1) != hash(key2)</p>
<p>但是如果实现一个完全满足第三个条件的散列表基本是不可能的。这种情况称之为<strong>散列冲突</strong>。</p>
<h4>散列冲突</h4>
<p>解决散列冲突有两种方法：<strong>开放寻址法</strong> 和 <strong>链表法</strong></p>
<p><strong>开放寻址法</strong>：
开放寻址法的核心思想是如果出现了散列冲突么，那么我们就找一个新的空闲位置将数据插入。找到新的空闲位置有如下三种方法：</p>
<ul>
<li>线性探测</li>
<li>二次探测</li>
<li>双重散列</li>
</ul>
<p>线性探测就是沿着冲突的位置一直往下找，直到找到空闲的位置，查找的时候类似，如果找到空闲位置还灭有找到，说明元素在散列表中不存在。删除的时候要注意将元素标记为已删除标记，否则会影响查找。</p>
<p>线性探测是每次将下标加1，而二次探测则是将下标每次都加当前下标的二次方（hash(key)+ 0, hash(key1) + 1^2， hash(key2) + 2^2）。而双重散列就是使用两个散列函数，第一个散列函数冲突的时候就会使用第二个散列函数。</p>
<p>当链表中空闲位置很少的时候，冲突的概率就会增大不少。空位的多少使用装载因子来表示：</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">装载因子 = 散列表中元素的个数 / 散列表的长度</span><br></pre></td></tr></table></figure>
装载因子越大，说明空闲位置越少，冲突也就越多，散列表的性能就会下降。</p>
<p><strong>链表法</strong>：</p>
<p>链表法就是在每个下标的位置挂上一条链表，所有散列值相同的元素就会存储在这个链表中。查找删除的时间复杂度是 O(k)，其中 k = n/m。n 表示散列表中数据的个数，m 表示散列表中链表的条数。</p>
<blockquote>
<p>链表法更灵活，比如可以将链表换成红黑树等数据结构</p>
</blockquote>
<h4>工业级散列表的设计方法</h4>
<p>如果哈希表的散列函数设计的不好或者装载因子过高，都有可能导致发生哈希碰撞的可能，使查询效率降低。</p>
<p>所以设计散列表会考虑一下三个方面：</p>
<p><strong>散列函数的设计</strong>:</p>
<ul>
<li>散列函数的设计不能太复杂</li>
<li>散列函数生成的值要尽可能随机并且分部均匀</li>
</ul>
<p><strong>装载因子与扩容</strong>:</p>
<ul>
<li>装载因子需要控制在合理的范围内，如果装载因子过大，就需要动态扩容</li>
<li>动态扩容需要视情况而定，不能简单的一次性扩容，可以新建一个散列表，直接插入数据到新的散列表，通过一点点将老散列表的数据迁移过去。</li>
</ul>
<p><strong>冲突解决方法</strong>：</p>
<ul>
<li>开放寻址法： 数据量小，装载因子小时适合</li>
<li>链表法：比较适合存储大对象，大量数据的散列表</li>
</ul>
<p>散列表和链表经常在一起使用，这两者组合使用其实就是结合了数组和链表的优势，规避两者的不足。</p>
<h3>树</h3>
<p>树结构与现实生活中树的结构非常类似。树中的每个元素称之为<strong>节点</strong>，用连线连接的两个节点，我们称之为<strong>父子关系</strong>。连接同一个父节点的元素我们称之为<strong>兄弟节点</strong>，在树中，所有的兄弟节点是不能相互连接的。没有父子节点的元素称之为<strong>根节点</strong>。没有子节点的元素称之为<strong>叶子节点</strong>。</p>
<p>树中还有几个关键的概念:</p>
<ul>
<li><strong>节点的高度</strong>：节点到叶子节点的最长路径（边数）</li>
<li><strong>节点的深度</strong>：根节点到这个节点所经历的边的个数</li>
<li><strong>节点的层数</strong>：节点的深度 + 1</li>
<li><strong>树的高度</strong>：根节点的高度</li>
</ul>
<h4>二叉树</h4>
<p>树的结构有多种，但是最常用的还是二叉树，二叉树的每个节点最多两个子节点。</p>
<p><strong>满二叉树</strong>：</p>
<p>叶子节点都在最底层，除了叶子节点外，每个节点都有左右两个节点，这种树称之为满二叉树</p>
<p><strong>完全二叉树</strong>：
叶子节点在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种树称之为完全二叉树</p>
<h4>树的存储方式</h4>
<p><strong>链式存储法</strong>：</p>
<p>节点使用链表节点表示，每个节点都有一个 left 指针和一个 right 指针，大部分二叉树都是这种结构来实现的</p>
<p><strong>顺序存储法</strong>：</p>
<p>节点 x 存储的位置为 i，那么左子节点的位置就是 2 * i，右子树的位置就是 2 * i + 1。一般为了计算方便，根节点存储的位置为 1。</p>
<p>通过顺序存储的方式，一颗完全二叉树仅仅浪费一个下标为0的存储位置，如滚是非完全二叉树，就会浪费比较多的存储空间。</p>
<p>一棵完全二叉树，使用数组存储是最省内存的方式。</p>
<h4>二叉树的遍历</h4>
<p>三种遍历方式的顺序是相对于根节点来说的，首先遍历根节点就叫前序，在中间顺序遍历根节点就叫中序，最后遍历根节点就叫后序。</p>
<ul>
<li><strong>前序遍历</strong>：对树中的任意节点来说，先打印这个节点，再打印它的左子树，然后打印它的右子树</li>
<li><strong>中序遍历</strong>：对树中的任意节点来说，先打印它的左子树，然后打印这个节点，最后打印它的右子树</li>
<li><strong>后序遍历</strong>：对树中的任意节点来说，先打印它的左子树，然后打印它的右子树，最后打印这个节点</li>
</ul>
<p>遍历树的时间复杂度为 O(n)。</p>
<blockquote>
<p>实际上这三种遍历方式就是一个递归的过程</p>
</blockquote>
<h4>二叉搜索树</h4>
<blockquote>
<p>支持动态数据聚合的快速插入、删除和查找操作。</p>
</blockquote>
<p>二叉搜索树中的任意一个节点的左子树的值又要小于这个节点的值，右子树的值都要大于这个节点的值。</p>
<blockquote>
<p>二叉搜索树中序遍历可以输出一个有序数据的序列，二叉搜索树也称之为二叉排序树。</p>
</blockquote>
<p>二叉搜索树的操作性能与树的高度是成正比的，左右子树高度相差不大时，时间复杂度为 O(logn)，如果左右子树的高度相差过大，那么时间复杂度就会退化为 O(n)。</p>
<h4>平衡二叉搜索树</h4>
<p>平衡二叉树是为了解决普通二叉树在频繁的插入、删除等动态操作中，出现时间复杂度退化的情况，从 $O(logN)$ 退化到 $O(N)$</p>
<ul>
<li>AVL 树</li>
<li>R-B tree（红黑树）</li>
<li>Splay Tree（伸展树）</li>
<li>Treap（树堆）</li>
</ul>
<p>二叉树的严格定义是：二叉树中任意一个节点的左右子树的高度相差不能大于一（大多数情况下并不会严格遵守）</p>
<p>平衡二叉搜索树中平衡是指左子树和右子树的高度相对来说相差不大，这样整棵树的查找、插入和删除的效率就要高一些。</p>
<h4>递归树</h4>
<p>递归树用于分析时间复杂度。</p>
<h4>堆</h4>
<blockquote>
<p>堆是一种特殊的树，本质上就是一棵完全二叉树</p>
</blockquote>
<ul>
<li>堆是一棵完全二叉树</li>
<li>堆中的每一个节点的值都必须大于（或小于等于）其子树中每个节点的值</li>
</ul>
<p><strong>堆的应用：</strong></p>
<ul>
<li>优先级队列
<ul>
<li>合并有序小文件</li>
<li>高性能定时器</li>
</ul>
</li>
<li>求海量数据中求 Top K</li>
<li>求中位数问题</li>
</ul>
<p><strong>堆排序：</strong></p>
<p>堆排序可以分成两个步骤，<strong>建堆</strong>和<strong>排序</strong>。</p>
<p>通过建立大顶堆，最大的元素就已经在堆顶了。然后每次都取堆顶的元素。依次取下来就排完序了。</p>
<h3>图</h3>
<p>图是一种比树更复杂的数据结构。</p>
<p>图的相关概念：</p>
<ul>
<li>图中的元素称之为<strong>顶点</strong>，图的顶点可以与<strong>其他任意顶点</strong>相连</li>
<li>顶点与定点相连的关系称之为<strong>边</strong></li>
<li>边有方向的图称之为<strong>有向图</strong>，没有方向的图称之为<strong>无向图</strong>，还有一种边带权重的称之为<strong>带权图</strong></li>
<li>与顶点相连的边数称之为<strong>度</strong>，度分为<strong>入度</strong>和<strong>出度</strong></li>
</ul>
<p><strong>图的存储方式：</strong></p>
<ul>
<li>邻接矩阵存储</li>
<li>邻接表</li>
</ul>
<p><strong>图的搜索算法：</strong></p>
<ul>
<li>广度优先搜索</li>
<li>深度优先搜索</li>
</ul>
<p>(完)</p>
<ol>
<li>极客时间数据结构与算法之美专栏</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>提升用户体验，从新钱包开始</title>
    <url>/2022/10/22/%E6%8F%90%E5%8D%87%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%8C%E4%BB%8E%E6%96%B0%E9%92%B1%E5%8C%85%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<ol>
<li></li>
</ol>
<p>在之前的文章中有提到，现在的以太坊应用层需要解决的是应用不足和用户体验问题。最近很多的 eip 提案也都是瞄准了这个方向。</p>
<p>最近的 ERC4337 想要解决的就是钱包问题。在 web3 的世界里面，钱包是一个非常重要的基础设施，这个就是进入 web3 世界的钥匙。但是目前在以太坊中，EOA（外部账户）以及合约账户的使用门槛都很高。用户需要对区块链的一些基础知识有一些理解才能开始使用，而且使用的时候要一直注意安全，用户的心智负担很重。</p>
<p>让一个小白用户去接触以太坊的钱包，就好比是让一个互联网的用户直接使用 http 协议来和应用交互，很明显这个不合理。</p>
<p>最近比较讨论比较多的 ERC4337 就是这样的一个方向。这个钱包的设计在不改动以太坊合约层的情况下，来给用户和链之间加上一个中间层，用户可以通过社交恢复()的方式来修改自己的私钥或者找回丢失的资产。</p>
<p>在这个钱包体系下，用户的交易被定义为一个 UserOperation，多个 UserOperation 可以聚合在一起提交到链上（对，在这里好像看到了 rollup 的身影），而且在交易的过程中，用户可以不需要使用 ETH 来支付 gas，可以使用任意一种 ERC20 的币来替代。用户在这样的情况下甚至完全不用感受到以太坊的存在，但是交易确实已经被提交到了以太坊。</p>
<ol start="2">
<li></li>
</ol>
<p>但在计算机的世界中，没有什么问题是增加一个中间层解决不了的。</p>
<p>随着以太坊的不断升级，已经越来越像是一个基础设施，等完成分片升级之后，以太坊就是一个真正意义上的全球数据库（账本）了，它更大的作用是用来承载数据，让上链的数据不可更改。很明显，这些升级都不是为普通用户准备的。</p>
<p>对于更多要进入 web3 的用户来说，他们需要一个更方便的接入方式。那么一个合理的方式就是来增加一个中间层。</p>
<p>目前还有一些方案，想要修改以太坊的共识层来提升用户体验，这个方向是不对的，应该还是要从应用层动手。与之类似的，在开发互联网产品时，总不能说为了满足用户的需求而去修改 MySQL 的源码。</p>
<p>现在的以太坊上需要更多这样的协议，来丰富应用层，让更多的人使用，只有这样，才能让以太坊真正的被主流人群用起来，而被主流人群用起来的关键就是将以太坊隐藏掉。这个也确实是合理的做法，在当前互联网模式下，绝大多数用户是感知不到互联网的存在，但又无时无刻不在使用互联网。</p>
<ol start="3">
<li></li>
</ol>
<p>也许有人就会质疑，这样的应用还叫 web3 么，说好的去中心化呢？在以前的互联网中，所有的平台都建设有自己的数据中心，应用之间的交互很困难，就像是一座座孤岛。而在以太坊上，以太坊的的去中心化程度决定了上层应用的去中心化程度。只要以太坊的底层足够安全，足够去中心化，那么上层的应用也是去中心化的。</p>
<p>而且一直认为，web3 和 web2 不是对立面，它们必然是要走向融合的。在 web3 的世界中，也不是所有的数据都需要上传的链上，只需要保留用户关键的资产就可以。用户关心的也是这些资产是否可以正常地流通，其他的信息都分散在各个系统中。</p>
<p>在后续 layer2 层的方案逐渐完善的时候，web3 应用也会基于 layer2 层来构建，而不是直接基于以太坊，这样用链的成本也降下来了。到那个时候，用户使用 web3 就像使用 web2 一样便利，那样才会带来 web3 的真正爆发。</p>
<p>参考链接：</p>
<p>[1] <a href="https://eips.ethereum.org/EIPS/eip-4337" target="_blank" rel="noopener">https://eips.ethereum.org/EIPS/eip-4337</a></p>
<p>[2] <a href="https://www.notion.so/EIP-4337-0baad80755eb498c81d4651ccb527eb2" target="_blank" rel="noopener">https://www.notion.so/EIP-4337-0baad80755eb498c81d4651ccb527eb2</a></p>
<p>[3] <a href="https://mp.weixin.qq.com/s/ZGzw3VE-8KEQE5xu7Jw_8A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ZGzw3VE-8KEQE5xu7Jw_8A</a></p>
]]></content>
      <categories>
        <category>web3</category>
      </categories>
      <tags>
        <tag>钱包</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币的账户模型</title>
    <url>/2021/11/27/%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在区块链中，有两种账户模型：一种是账户模型，一种是比特币所用的 UTXO 模型。账户模型比较好理解，我们的的银行账户都是账户模型，在数据库中维护一条数据，我们余额的增加或者减少都是基于这条数据来进行的。</p>
<p>而 比特币所以的 UTXO 模型也被称之为 Transaction-Based 模型，就是说所有的数据都是记录在交易里面的，如果想要知道一个人的账户里面有多少钱，只能通过交易来推算。这篇文章，我们来聊一下比特币的 UTXO。</p>
<h2>1. 比特币中交易类型</h2>
<p>在比特币中，有三种常见的交易类型，一种是支付一部分给别人，然后给自己一部分找零，这个是要把一个 UTXO 拆成两个，关于找零的概念，我们下边再聊。</p>
<p><img src="0.png" alt=""></p>
<p>另外一种是需要付给别人一笔比特币，然后通过把多个 UTXO 凑在一起，发给其他用户，形成一个新的 UTXO，这种好比是将很多零钱换成了一个大额面值的钞票。</p>
<p><img src="1.png" alt=""></p>
<p>还有一种，就是在一笔交易中，需要给多个人发送比特币，就会把一个大的 UTXO 换成多个小的 UTXO，这里好比是将一张大额的钞票换成多张小额的钞票。</p>
<p><img src="2.png" alt=""></p>
<p>在一笔交易中，输入的 UTXO 的总额一般都要略大于输出的 UTXO，这是因为其中一部分的比特币，被矿工作为交易的手续费拿走了。</p>
<h2>2. UTXO 模型</h2>
<p>比特币是基于交易装账本，就是说全部的数据都存在区块链账本中。并没有一个地方记录了哪个账户下有多少币。一个账户拥有多少币，需要根据交易来推算。</p>
<p>比特币的全节点上需要维护 UTXO 这样的一个数据结构，UTXO 的全称是（Unspent Transaction Output）。全节点就是完整运行了比特币软件的网络节点，这种节点一般会参与挖矿。这些 UTXO 是全节点在遍历比特币的账本后提取出来的，然后在内存中维护。</p>
<p>如果在交易发起的时候，还需要去链上查询 UTXO，那么肯定会耗时很长，为了让 UTXO 的查询更快一下，全节点会扫描整条链，然后来生成地址和 UTXO 之间的映射关系。方便交易的时候快速查询。就会形成下面的结构：</p>
<p><img src="3.png" alt=""></p>
<p>在进行一笔交易的时候，全节点会去 UTXO 中集合中找到符合条件的 UTXO，然后再用所有者的私钥签名来发起交易。</p>
<p>每一笔交易都会花掉一些 UTXO，同时也会生成一些新的 UTXO。假如现在你有一笔 2 BTC 的 UTXO，但这时候需要支付给一个人 0.5 BTC，那么这个交易就会把这个 UTXO 拆成 0.5 和 1.5 BTC （由于有手续费，实际会略小于 1.5 ）的两个 UTXO，0.5 BTC的 UTXO 会发送到别人的地址下，1.5 BTC 的 UTXO 会返回到你的地址下，这个方式也被称之为找零。</p>
<p>被拆成两部分的 UTXO 也会被重新加入到 UTXO 的集合，供后面的交易使用，然后就会形成下面的交易链：</p>
<p><img src="4.png" alt=""></p>
<p>UTXO 中的每一个输出要给出产生该输出的交易 hash，以及在这个交易中是第几个输出。</p>
<p>这些流通的比特币，都来源于最开始比特币区块的产出。每个区块在被挖出来的时候会产生一个特殊的交易，被称之为<strong>铸币交易（coinbase-transaction）</strong>。这个交易会向那个挖出区块的地址发送一定数量的比特币，最开始是 50 个比特币，然后大约每隔四年左右，铸币交易产生的比特币会减半一次。</p>
<p>运行全节点的节点比较是少数，大多数的人使用的还是手机钱包，对于手机钱包，自然无法在手机上来维护这个数据，所以手机钱包一般是去请求某个服务器，从服务器上获得结果。</p>
<p>可以根据 API 来查询一个地址中未消费的比特币：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --location --request GET http://www.tokenview.com:8088/unspent/btc/1JctmVUHHfchRQHR1K1v9E9rs3mSWLGEmt/1/50</span><br></pre></td></tr></table></figure></p>
<p>然后就可以得到该地址的 UTXO:</p>
<p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"成功"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"block_no"</span>: <span class="number">707638</span>,</span><br><span class="line">            <span class="attr">"output_no"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"index"</span>: <span class="string">"23"</span>,</span><br><span class="line">            <span class="attr">"txid"</span>: <span class="string">"e167d10b492465e5a1b4d15176fa580af21cae314da337184f82089daf9bc740"</span>,</span><br><span class="line">            <span class="attr">"hex"</span>: <span class="string">"76a914c143e8f3f235ca9e82df0a017f01cd3f91ff3d4388ac"</span>,</span><br><span class="line">            <span class="attr">"confirmations"</span>: <span class="number">3629</span>,</span><br><span class="line">            <span class="attr">"value"</span>: <span class="string">"0.00231716"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"block_no"</span>: <span class="number">628354</span>,</span><br><span class="line">            <span class="attr">"output_no"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"index"</span>: <span class="string">"16"</span>,</span><br><span class="line">            <span class="attr">"txid"</span>: <span class="string">"8f8153d676adfb1ceb27154b96f025a6898d6ee49522cf38b847a63f93527372"</span>,</span><br><span class="line">            <span class="attr">"hex"</span>: <span class="string">"76a914c143e8f3f235ca9e82df0a017f01cd3f91ff3d4388ac"</span>,</span><br><span class="line">            <span class="attr">"confirmations"</span>: <span class="number">82913</span>,</span><br><span class="line">            <span class="attr">"value"</span>: <span class="string">"0.00231716"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>confirmations 表示该区块后面连接的区块数，区块数越大说明当前的 UTXO 越安全，被篡改的机率就越小， value 就是 UTXO 中包含的比特币的数量，txId 是输出改 UTXO 的交易Id，output_no 则是表示这是上一笔交易中的第几个输出。</p>
<h2>3. 解决双花问题</h2>
<p>在数字货币系统中，双花问题是必须要解决的。双花问题是指一分钱被花两次的情况。而比特币利用 UTXO 模型，很好的解决了这个问题。</p>
<p>由于每一笔 UTXO 在花出去的时候，都需要经过所有者的私钥签名。那些花出去了的 UTXO 就会从集合中被删除。如果有人想把 UTXO 花两次，立马就可以被发现，两笔交易中一定会有一笔会失败。</p>
<h2>4. 以太坊为什么不使用 UTXO</h2>
<p>V 神认为 UTXO 不能很好的满足以太坊的要求。以太坊以智能合约为核心，UTXO 的这种模型会让智能合约操做资金变得非常复杂。每次转账都需要小心翼翼的组合 UTXO。而且以太坊中资金转移的非常频繁，UTXO 占用的空间要远大于账户模型。</p>
<p>但是话又说回来，比特币坚决不在链层做类似智能合约之类的功能，它就是把自己定位于最底层的应用，最近 Taproot 的升级让比特币看起来更具有生命力，基于比特币上的应用生态还是有比较大的想象空间，对于比特币的 Layer2 的方案，目前还没有完全确定，但是也完全值得期待。</p>
<p>反观以太坊，一开始就把自己定位于通用计算，这样初始的生态在智能合约的爆发下确实做起来了，但是现在用户的实现体验有点太差了， gas 费高，交易速度慢，以太坊现在被人称之为富人链。所以现在以太坊着急推出 Layer2，只有系统可以支持更高频、更小额的交易，才能吸引到足够的用户。</p>
<h2>5. 交易所里的比特币</h2>
<p>还有一点需要注意，有很多中心化的交易所会提供比特币的交易，但交易所里面的比特币不是基于 UTXO。</p>
<p>当你在交易所充币的时候，交易所会为你设立一个账户，然后后续所有的交易都是基于这个账户进行的，并不会和链进行交互。</p>
<p>这样做有两个好处，第一个交易的速度更快，比特币网络上一笔交易的确认需要等不少时间，当交易很多时，速度会更慢。第二，省下了不少手续费。由于不与链交互，自然就不用交易的手续费。当然，交易所本身还是会从你的每一笔交易中收费。</p>
<p>也就是说，在交易所里的交易，并不是真正在链上进行交易。只有在把币从交易所提走的时候，才会把币打回到链上的地址。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>时代的疤痕</title>
    <url>/2018/07/26/%E6%97%B6%E4%BB%A3%E7%9A%84%E7%96%A4%E7%97%95/</url>
    <content><![CDATA[<p>一个国家的成长与一个人的成长其实没有多大的区别。在一个国家在走向成熟、健全的过程中，会犯很多的错误。</p>
<p>任何一个错误的发生都是值得我们去反思然后让整个社会变的更好的契机。一个国家是否是朝着正确的方向的发展的标准的就是看他们对待错误的方式。</p>
<p>小到一个人，大到一个国家，都是趋利的。正式这个原因才产生了大量的阴暗的角落，这些角落里面藏污纳垢，给了很多人野蛮生长的机会。在这些生长的过程中，往往会带来伤害。</p>
<p>事情既然已经发生，如何对这些事情进行处理才是最让人关心的，也是罪重要的。失效的疫苗看起来不会伤害人，但却会有增加患病的几率，这不也是一定程度上 的谋财害命吗？一点罚款是解决不了问题的，出现这个问题的本质原因不只是企业的问题。国家对于每年进口的药 的审查是非常严格，这就是意见非常好的事，在国外经过了测试的药在国内不一定可以通过测试，因为体质不同的原因很有可能让一款药水土不服。既然对于进口药能有着如此严格的要求，那么又为什么让这样的事情在家门口发生呢？这就不仅仅是简单的问题了。</p>
<p>真正的成长是能够直视自己的错误并且有合适的方式去纠正错误，反正不能是直接掩盖过去吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>浅析 Fabric Peer 节点</title>
    <url>/2021/03/28/%E6%B5%85%E6%9E%90-Fabric-Peer-%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2>1. Fabric 简介</h2>
<p>Hyperledger Fabric，也称之为超级账本，是由 IBM 发起，后成为 Linux 基金会 Hyperledger 中的区块链项目之一。</p>
<p>Fabric 是一个提供分布式账本解决方案的平台，底层的账本数据存储使用了区块链。区块链平台通常可以分为公有链、联盟链和私有链。公有链典型的代表是比特币这些公开的区块链网络，谁都可以加入到这个网络中。联盟链则有准入机制，无法随意加入到网络中，联盟链的典型例子就是 Fabric。</p>
<p>Fabric 不需要发币来激励参与方，也不需要挖矿来防止有人作恶，所以 Fabric 有着更好的性能。在Fabric 网络中，也有着诸多不同类型的节点来组成网络。其中 Peer 节点承载着账本和智能合约，是整个区块链网络的基础。在这篇文章中，会详细分析 Peer 的结构及其运行方式。</p>
<p>在本文中，假设读者已经了解区块链、智能合约等概念。</p>
<p>本文基于 Fabric1.4 LTS。</p>
<h2>2. 网络结构</h2>
<p>区块链网络是一个分布式的网络，Fabric 也是如此，由于 Fabric 是联盟链，需要准入机制，所以在网络结构上会复杂很多，下面是一个简化的 Fabric 网络：</p>
<p><img src="0.png" alt=""></p>
<p>各个元素的含义如下：</p>
<ul>
<li>A：表示客户端节点，也就是用户的应用</li>
<li>CA：表示 CA 证书节点</li>
<li>P：表示 peer 节点</li>
<li>O：表示 Orderer 节点</li>
<li>L：表示账本</li>
<li>C：表示 Channel</li>
<li>CC：表示 Channel 配置</li>
<li>R：表示组织</li>
<li>S：表示智能合约</li>
<li>NC：表示 Fabric 网络配置</li>
</ul>
<p>对于 Fabric 网络，外部的用户需要通过客户端应用，也就是图中的 A1、A2 或者 A3 来访问网络，客户端应用需要通过 CA 证书表明自己的身份，这样才能访问到 Fabric 网络中有权限访问的部分。</p>
<p>在上面的网络中，共有四个组织，R1、R2、R3 和 R4。其中 R4 是整个 Fabric 网络的创建者，网络是根据 NC4 配置的。</p>
<p>在 Fabric 网络中，不同的组织可以组成联盟，不同的联盟之间数据通过 Channel 来隔离。Channel 中的数据只有该联盟中的组织才能访问，每一个新的 Channel 都可以认为是一条新的链。与其他的区块链网络中通常只有一条链不一样，Fabric 可以通过 Channel 在网络中快速的搭建出一个新的区块链。</p>
<p>上面 R1 和 R2 组成了一个联盟，在 C1 上交易。R2 同时又和 R3 组成了另外一个联盟，在 C2 上交易。R1 和 R2 在 C1 上交易时，对 R3 是不可见的，R2 和 R3 在 C2 上交易时，对 R1 是不可见的。Channel 机制提供了很好的隐私保护能力。</p>
<p>Orderer 节点是整个 Fabric 网络共有的，用来为所有的交易排序、打包。比如上面网络中 O4 节点。本文不会对 Orderer 节点进行详细说明，可以把这个功能理解为比特币网络中的挖矿过程。</p>
<p>Peer 节点表示网络中的节点，通常一个 Peer 就表示一个组织，Peer 是整个区块链网络的基础，是智能合约和账本的载体，Peer 也是本文讨论的重点。</p>
<p>一个 Peer 节点可以承载多套账本和智能合约，比如 P2 节点，既维护了 C1 的账本和智能合约，也维护了 C2 的账本和智能合约。</p>
<h2>3. 交易流程</h2>
<p>为了可以更深入了解 Peer 节点的作用，先了解一下 Fabric 整体的交易流程。整体的交易流程图如下：</p>
<p><img src="1.png" alt=""></p>
<p>Peer 节点按照功能来分可以分为<strong>背书节点</strong>和<strong>记账节点</strong>。</p>
<p>客户端会提交交易请求到背书节点，背书节点开始模拟执行交易，在模拟执行之后，背书节点并不会去更新账本数据，而是把这个交易进行加密和签名，然后返回给客户端。</p>
<p>客户端收到这个响应之后就会把响应提交到 Orderer 节点，Orderer 节点会对这些交易进行排序，并打包成区块，然后分发到记账节点，记账节点就会对交易进行验证，验证结束之后，就会把交易记录到账本里面。</p>
<p>一笔交易是否能成功是根据背书策略来指定的，每一个智能合约都会指定一个背书策略。</p>
<h2>4. Peer 节点</h2>
<p>Peer 节点代表着联盟链中的各个组织，区块链网络也是由 Peer 节点来组成的，而且也是账本和智能合约的载体。</p>
<p>通过对上面交易过程的了解可以知道，Peer 节点是主要的参与方。如果用户想要访问账本资源，都必须要和 peer 节点进行交互。在一个 Peer 节点中，可以同时维护多个账本，这些账本属于不同的 Channel 。每个 Peer 节点都会维护一套冗余账本，这样就避免了单点故障。</p>
<p>Peer 节点根据在交易中的不同角色，可以分成背书节点（Endorser）和记账节点（Committer），背书节点会对交易进行模拟执行，记账节点才会真正将数据存储到账本中。</p>
<h3>账本</h3>
<p>账本可以分成两个部分，一部分是区块链，另一部分是 Current State，也被称之为 World State。</p>
<p>区块链上只能追加，不能对过去的数据进行修改，链上也包含两部分信息，一部分是通道的配置信息，另一部分是不可修改，序列化的记录。每一个区块记录前一个区块的信息，然后连成链，如下图所示：</p>
<p><img src="2.png" alt=""></p>
<p>第一个区块被称之为 genesis block，其中不存储交易信息。每个区块可以被分为<strong>区块头</strong>、<strong>区块数据</strong>和<strong>区块元数据</strong>。区块头中存储着当前区块的区块号、当前区块的 hash 值和上一个区块的 hash 值，这样才能把所有的区块连接起来。区块数据中包含了交易数据。区块元数据中则包括了区块写入的时间、写入人及签名。</p>
<p><img src="3.png" alt=""></p>
<p>其中每一笔交易的结构如下，在 Header 中，包含了 ChainCode 的名称、版本信息。Signature 就是交易发起用户的签名。Proposal 中主要是一些参数。Response 中是智能合约执行的结果。Endorsements 中是背书结果返回的结果。</p>
<p><img src="4.png" alt=""></p>
<p>WorldState中维护了账本的当前状态，数据以 Key-Value 的形式存储，可以快速查询和修改，每一次对 WorldState 的修改都会被记录到区块链中。WorldState 中的数据需要依赖外部的存储，通常使用 LevelDB 或者 CouchDB。</p>
<p>区块链和 WorldState 组成了一个完整的账本，World State 保证的业务数据的灵活变化，而区块链则保证了所有的修改是可追溯和不可篡改的。</p>
<p>在交易完成之后，数据已经写入账本，就需要将这些数据同步到其他的 Peer，Fabric 中使用的是 Gossip 协议。Gossip 也是 Channel 隔离的，只会在 Channel 中的 Peer 中广播和同步账本数据。</p>
<h3>智能合约</h3>
<p>智能合约需要安装到 Peer 节点上，智能合约是访问账本的唯一方式。智能合约可以通过 Go、Java  等变成语言进行编写。</p>
<p>智能合约编写完成之后，需要打包到 ChainCode 中，每个 ChainCode 中可以包含多个智能合约。ChainCode 需要安装，ChainCode 需要安装到 Peer 节点上。安装好了之后，ChainCode 需要在 Channel 上实例化，实例化的时候需要指定背书策略。</p>
<p><img src="5.png" alt=""></p>
<p>智能合约在实例化之后就可以用来与账本进行交互了，流程图如下：</p>
<p><img src="6.png" alt=""></p>
<p>用户编写并部署实例化智能合约之后，就可以通过客户端应用程序来向智能合约提交请求，智能合约会对 WorldState 中数据进行 get、put 或者 delete。其中 get 操作直接从 WorldState 中读取交易对象当前的状态信息，不会去区块链上写入信息，但 put 和 delete 操作除了修改 WorldState，还会去区块链中写入一条交易信息，且交易信息不能修改。</p>
<p>区块链上的信息可以通过智能合约访问，也可以在客户端应用通过 API 直接访问。</p>
<p>Event 是客户端应用和 Fabric 网络交互的一种方式，客户端应用可以订阅 Event，当 Event 发生时，客户端应用就会接受到消息。</p>
<p>事件源可以两类，一类是智能合约发出的 Event，另一类是账本变更触发的 Event。用户可以从 Event 中获取到交易的信息，比如区块高度等信息。</p>
<h2>5. 小结</h2>
<p>在这篇文章中，首先介绍了 Fabric 整体的网络架构，通过对 Fabric 交易流程的分析，讨论了 peer 节点在交易中的作用，然后详细分析了 peer 节点所维护的账本和智能合约，并分析了 peer 节点维护账本以及 peer 节点执行智能合约的流程。</p>
<p>文 / Rayjun</p>
<h3>REF</h3>
<p>[1] <a href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/whatis.html" target="_blank" rel="noopener">https://hyperledger-fabric.readthedocs.io/zh_CN/release-1.4/whatis.html</a></p>
<p>[2] <a href="https://developer.ibm.com/zh/technologies/blockchain/series/os-academy-hyperledger-fabric/" target="_blank" rel="noopener">https://developer.ibm.com/zh/technologies/blockchain/series/os-academy-hyperledger-fabric/</a></p>
<p>[3] <a href="https://en.wikipedia.org/wiki/Gossip_protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Gossip_protocol</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>构建可扩展 Web 应用的 7 个阶段</title>
    <url>/2020/04/11/%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95-Web-%E5%BA%94%E7%94%A8%E7%9A%84-7-%E4%B8%AA%E9%98%B6%E6%AE%B5/</url>
    <content><![CDATA[<p>这是一篇<a href="http://highscalability.com/blog/2008/9/23/the-7-stages-of-scaling-web-apps.html" target="_blank" rel="noopener">译文</a>。文章分享了构建一个可扩展 Web 应用的 7 个通用步骤。文章有点老，但是观点不过时。</p>
<hr>
<p>John Engales 是 Rackspace（一家云计算公司）的 CTO。他说一个表现良好的网站通常要经历以下 7 个阶段：</p>
<p><strong>阶段 1</strong>
刚开始：使用简单的架构，系统复杂度很低，没有冗余。只使用防火墙、负载均衡器、一对web服务器、数据库服务器和内部存储。</p>
<p><strong>阶段 2</strong>
基本上没有什么变化，只是规模会更大。</p>
<p><strong>阶段 3</strong>
痛苦的开始：媒体曝光度增加。开始使用反向代理，缓存静态资源，继续使用负载均衡和更多的数据库，并且开始重构代码。</p>
<p><strong>阶段 4</strong>
痛苦加剧：开始 memcached 进行缓存，数据的写入和复制都太耗时，要开始对数据库进行分区，对有些内容进行共享存储，对数据库进行重大的架构调整。</p>
<blockquote>
<p>现在用 memcached 的少， redis 用的更多了</p>
</blockquote>
<p><strong>阶段 5</strong>
真的痛苦：重新思考整个应用架构，比如根据用户地理位置来进行区分等等，需要创建用户集群，使用哈希计算来确定用户属于哪个集群。</p>
<blockquote>
<p>这句话里面的信息量比较大，既可以说是在请求的分发阶段，也可以包括数据的存储阶段。</p>
</blockquote>
<p><strong>阶段 6</strong>
痛苦开始少了一些了：已经有了可扩展的应用和数据库的架构，可以接受的性能，开始在系统里面添加新的功能，并且优化一些代码，规模还在增长但是依然可控。</p>
<p><strong>阶段 7</strong>
进入未知区域：剩下的瓶颈是什么（算力，空间，带宽，CDN，防火墙，负载均衡，存储，人力，进度，数据库），所有的鸡蛋还在一个篮子里（单个数据中心，单个数据备份）。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>后端 分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总述</title>
    <url>/2018/04/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E8%BF%B0/</url>
    <content><![CDATA[<p>排序算法是是一些列很基础的算法的集合，它们有着共同的特点。就是为事物进行排序。本系列的文章是对这些算法进行一个总结，本系列涉及到的算法如下。</p>
<ul>
<li>冒泡排序</li>
<li>快速排序</li>
<li>插入排序</li>
<li>希尔排序</li>
<li>选择排序</li>
<li>堆排序</li>
<li>归并排序</li>
<li>基数排序</li>
<li>桶排序</li>
<li>计数排序</li>
</ul>
<h4>算法时间和复杂度总结</h4>
<p>上述算法的特点可以总结如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法名称</th>
<th style="text-align:center">时间复杂度(平均)</th>
<th style="text-align:center">时间复杂度(最坏)</th>
<th style="text-align:center">时间复杂度(最好)</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$O(n^{1.3})$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">计数排序</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">桶排序</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">$O(n*k)$</td>
<td style="text-align:center">$O(n*k)$</td>
<td style="text-align:center">$O(n*k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 channel</title>
    <url>/2021/10/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-channel/</url>
    <content><![CDATA[<p>Go 在并发方面的表现很好，这也是 Go 的招牌。Go 在进行并发编程时，下面两个工具都会用到：</p>
<ul>
<li>goroutine：让多个任务并行，每个任务之间不相互影响</li>
<li>channel：负责 goroutine 之间的通信</li>
</ul>
<p>这篇文章会深入研究 channel 的工作机制，这里假设你已经了解 channel 的基本概念。对于 channel，我们需要知道它有如下的属性：</p>
<ul>
<li>多个 goroutine 同时访问 channel 是安全的</li>
<li>channel 中的任务是先进先出的（FIFO）</li>
<li>channel 可以在 goroutine 之间传递值</li>
<li>channel 会影响 goroutine 调度</li>
</ul>
<p>下面来探究一下这些特性是怎么实现的。</p>
<h2>1. 创建 channel</h2>
<p>可以创建的 channel 有两种：</p>
<ul>
<li>buffered channel，在创建时候需要指定缓冲区的大小</li>
<li>unbuffered channel，也被称之为<strong>同步 channel</strong>，这个可以看成是 buffered channel 的特殊情况，缓冲区的大小设置为 1</li>
</ul>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// 缓冲区大小为 3 的 buffered channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// unbuffered channel</span></span><br></pre></td></tr></table></figure></p>
<p>chan 的底层数据结构叫 <code>hchan</code>，具体结构如下：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  buf      unsafe.Pointer</span><br><span class="line">  lock     mutex</span><br><span class="line">  sendx    <span class="keyword">uint</span>   </span><br><span class="line">	recvx    <span class="keyword">uint</span></span><br><span class="line">  sendq    waitq   </span><br><span class="line">	recvq    waitq </span><br><span class="line">	qcount   <span class="keyword">uint</span>          </span><br><span class="line">	dataqsiz <span class="keyword">uint</span>          </span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 buf 是一个循环队列，用来存储 channel 接收的数据，lock 用来保护数据安全，goroutine 来访问 channel 的 buf 之前，需要先获取锁。</p>
<p>sendx 表示当前数据发送的的位置，recvx 表示当前数据接收的位置。sendq 和 recvq 是两个队列，这两个结构很重要，我们下面会讲到。</p>
<p>qcount 表示当前 buf 中存储的数据个数，dataqsiz 表示 buf 可以接受的最大数据数量。elemtype 就表示数据的类型。</p>
<p>channel 在使用 make 创建的时候，实际上会在堆上分配一块空间，初始化 hchan 结构，然后返回 hchan 的指针。这就是为什么在使用 channel 的时候，直接传递就可以，而不用获取 channel 的指针，这是因为 channel 本身就是指针。</p>
<h2>2. 发送和接收</h2>
<p>下面来详细看一下 channel 发送和接收数据的过程，现在假设有下面两个 goroutine: G1 和 G2，一个发送数据，一个接收数据：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// G1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">        taskCh &lt;- task</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// G2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">       task := &lt;- taskCh</span><br><span class="line">       process(task)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设现在 G1 先执行，将数据发送到 channel中，会经过下面的三步：</p>
<p><img src="0.png" alt=""></p>
<p>在将数据放进 buf 之前，需要先获取锁，然后将数据拷贝一份放进去（注意这里是原数据的拷贝），然后再释放锁。</p>
<p>G2 运行后，发现 buf 中有数据，就可以处理，也需要经过三步：</p>
<p><img src="1.png" alt=""></p>
<p>首先也需要获取锁，然后把数据出队列，最后释放锁。</p>
<p>但是很显然，大多数情况下，数据的接受和发送不会这么顺利，假设现在 G2 对一个数据的处理花了很长的时间，而 G1 还在不断的发送数据：</p>
<p><img src="2.png" alt=""></p>
<p>这样 buf 很快就会被数据填满，那么这么时候 G1 就会被阻塞，直接 buf 中的数据被消耗，才会继续发送数据。</p>
<p>这里 goroutine 的阻塞和唤醒就是通过 Go 运行时的调度器来完成。这里有一个经常会被说到的概念：<strong>运行时</strong>。在这里可以简单的把运行时理解为 Go 代码运行的环境，运行时负责内存分配、垃圾回收等等。</p>
<p>goroutine 表示操作系统用户态的线程，相比于操作系统的线程，更轻量级，goroutine 之间的切换代价更小，但 goroutine 实际上还是在 操作系统线程上运行的。</p>
<p>这个运行时的调度器被称为 GMP 模型，其中 G 就表示 goroutine，M 表示操作系统的线程，P 表示调度器的上下文，维护了一个可执行 goroutine 的列表，负责 goroutine 的调度。</p>
<p><img src="3.png" alt=""></p>
<p>G1 发送任务被阻塞之后，P 就会将 G1 设置为等待状态，解除 G1 与 M 之间的关系，然后从队列中取出另外一个可运行的 goroutine 来运行。这里虽然 G1 被阻塞了，但是运行 G1 的线程并没有被阻塞，依然可以继续运行，对性能的影响会相对小。</p>
<p><img src="4.png" alt=""></p>
<p>G1 在被阻塞的时候会做一些事情，还记得上面 hchan 中 sendq 么，在这个时候就要起作用了。G1 会在被阻塞前创建一个 <code>sudog</code> 的数据，并把这个放进 sendq 中：</p>
<p><img src="5.png" alt=""></p>
<p>当 G2 消费一个数据之后，就会激活 sendq，将 sudog 中的 task4 直接入队到 buf 中，然后再将 G1 设置为可运行状态。</p>
<p>这里需要注意，是 G2 直接让 task4 进入到 buf 中，而不是先唤醒 G1，这样做是为了优化性能，如果先唤醒 G1，那么 G1 还需要先获取锁，然后才能将 task4 放入到 buf 中。</p>
<p>上面说的情况是 G1 做为数据发送方被阻塞，如果是数据接收方 G2 被阻塞会怎样？</p>
<p>G2 同样也会创建一个 sudog，但不是放进 sendq 中，而是放进 recvq 中：</p>
<p><img src="6.png" alt=""></p>
<p>这里 sudog 指向的是一个内存地址，用来接收 G1 发送进来的数据。在这里，最神奇的事情发生了，我们都知道 goroutine 是在栈上分配的，所以这里的 t 是在 G2 的栈上。</p>
<p>G1 发送数据的时候，会把数据直接写入到 t 所指向的内存地址，而不是放到 buf 中。也就是说 G1 直接向 G2 的栈上写入了数据。之所以这样做，也是从性能的角度考虑，这样 G2 就不用再去获取锁了。</p>
<p>这种一个栈向另一个栈写数据的情况只有这一种，在其他的地方不会出现。</p>
<h2>3. 小结</h2>
<p>通过上面我们知道，channel 通过 mutex（锁）来保证多个 goroutine 来访问 channel 的时候是安全的，同时 channel 维护了一个循环队列来保证数据的先进先出，同时也完成了在多个 goroutine 之间的数据传递，如果 goruotine 出现阻塞，则由调度器进行调度。</p>
<p>但是 channel 的实现也做出了一些非常规的操作，跨栈写数据，这样会给垃圾回收带来很大的麻烦。但如果不这么做，性能方面就会牺牲很多，所以这是一个性能和简单的一个妥协。</p>
<p>文 / Rayjun</p>
<p>[1] https://www.youtube.com/watch?v=KBZlN0izeiY</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>湮灭</title>
    <url>/2018/05/03/%E6%B9%AE%E7%81%AD/</url>
    <content><![CDATA[<p>这是一本很另类的科幻小说，之前绝大多数的科幻小说里面，人类都是一个独立的存在，那些外星文明虽然形状被描述的乱七八糟，但是整体上也还是有着和人类相似的存在，所有的故事都是基于这个基础来进行的。但是事实真的是这样吗？湮灭说不一定。在这本书里面，外星人从头到尾没有露面，却让人感觉无处不在。</p>
<p>这是一个阴谋吗？看起来像，但是实际上也不好说。这更像是一个大自然的现象，无恶无善。只是这些对人类来说却不是这么一回事。通过不断的派遣探测队去里面探究所谓的真相。当然，一无所获，因为这里面根本就没有真相。事情就是这么发生了，就像人饿了是要吃饭一样，没有任何的道理所言。这件事情的发生不过是因为这个事情超出了人类自己的认知而已。而人自己还想不断的去里面寻找自己能够理解的真相。</p>
<p>一定是有一些存在超出了我们自己的认知范围。我们说知道的都是在我们自己局限的范围之内，超出了这个范围之外的东西对我们自己来说都是一篇茫然。这些使我们感到恐惧。自己的认知范围为自己划了一个牢，个人的成长的表现就是将这个认知圈子的不断扩大。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>科幻</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 defer、panic 和 recover</title>
    <url>/2021/08/30/%E7%90%86%E8%A7%A3-defer%E3%80%81panic-%E5%92%8C-recover/</url>
    <content><![CDATA[<p>在 Go 语言中，有很多流程控制的语句，if、else 等等，这些流程控制的关键字在其他语言中也存在的但 Go 中还有几个特殊的流程控制关键字，defer、panic 和 recover。</p>
<h2>1. defer</h2>
<p>defer 可以保证一些代码在函数或者方法返回之前被调用，即使方法没有正常执行完，发生了 panic，defer 后面的代码也会执行。这里需要注意，<strong>不是在退出某个作用域之前会被调用，而且函数或者方法</strong>。</p>
<p>defer 通常用来回收一些资源，比如关闭文件，关闭数据库连接以及释放一些资源（释放锁）。在使用 defer 的时候，有一些需要注意的地方。</p>
<ol>
<li>参数预计算</li>
</ol>
<p>在定义 defer 的时候，引用的外部参数会立刻被拷贝，在 i++ 执行之前就已经确定了，下面的代码最后打印的值是 0， 而不是1：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">	i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想要最后打印的值是 1，则做如下修改：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;()</span><br><span class="line">	i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果定义了多个 defer 语句，最后定义的最先执行</li>
</ol>
<p>下面的代码输出的结果是 4 3 2 1：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>defer 可以对方法或者函数的命名返回值进行赋值</li>
</ol>
<p>在下面的代码中，正常情况下回返回 1，使用 defer 却可以对返回值继续赋值，所以最后的返回值是 2。</p>
<h2>2. panic</h2>
<p>panic 是 Go 的内置函数，可以打断当前的代码的正常执行流程，如果一个函数中出现 panic，该函数后续的代码都会停止执行。但是会执行 F 中的 defer 代码。然后其他调用 F 函数的地方也会出现 panic，层层向上传递，直到栈顶，最后程序会崩溃。</p>
<p>panic 可以显示调用 panic 函数产生，也会通过一些运行时的错误产生，比如数组越界。</p>
<p>panic 只会触发当前 goroutine 中的 defer 代码，而不会触发其他 goroutine 中的 defer 代码。</p>
<h2>3. recover</h2>
<p>recover 也是 Go 的内置函数，这个函数可以从 panic 中恢复程序的正常执行。recover 需要和 defer 定义在一起。</p>
<p>在正常的流程中，recover 的执行不会产生任何影响。只有在 panic 发生的时候，recevoer 才会恢复应用，阻止程序崩溃。而 panic 发生的时候只会执行 defer 代码。所以 recover 只在和 defer 搭配的时候才会有意义。</p>
<p><strong>recover 和 panic 需要在同一个 goroutine  使用，跨 goroutine 无法恢复应用</strong>。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		defer fmt.Println(<span class="string">"goroutine1 invoke"</span>)</span><br><span class="line">		go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">			defer fmt.Println(<span class="string">"goroutine2 invoke"</span>)</span><br><span class="line">			go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">				defer <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">					recover()</span><br><span class="line">				&#125;()</span><br><span class="line">				defer fmt.Println(<span class="string">"goroutine3 invoke"</span>)</span><br><span class="line">				panic(<span class="string">"panic"</span>)</span><br><span class="line"></span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(1 * time.Second)</span><br></pre></td></tr></table></figure></p>
<p>下面的程序不会出现崩溃，但如果对 recover 的调用不在同一个 goroutine 中，就无法阻止程序的崩溃。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		defer fmt.Println(<span class="string">"goroutine1 invoke"</span>)</span><br><span class="line">		go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">			defer <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">				recover()</span><br><span class="line">			&#125;()</span><br><span class="line">			defer fmt.Println(<span class="string">"goroutine2 invoke"</span>)</span><br><span class="line"></span><br><span class="line">			go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">				defer fmt.Println(<span class="string">"goroutine3 invoke"</span>)</span><br><span class="line">				panic(<span class="string">"panic"</span>)</span><br><span class="line">			&#125;()</span><br><span class="line">			</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(1 * time.Second)</span><br></pre></td></tr></table></figure></p>
<h2>4. 小结</h2>
<p>defer、panic、recover 是 Go 提供的流程控制方式，defer 可以用于正常的代码流程，用于关闭资源等操作，panic 则用来表示程序出现大问题，需要终止，可以自行触发，也可以被一些运行时的错误触发。但在一些情况下，我们不希望程序因为 panic 而终止，比如 web 服务，可以通过 recoever 来恢复程序。</p>
<p><strong>本文基于 go1.14</strong></p>
<p>文 / Rayjun</p>
<p>[1] <a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="noopener">https://blog.golang.org/defer-panic-and-recover</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型中的 super 和 extends</title>
    <url>/2020/04/03/%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84-super-%E5%92%8C-extends/</url>
    <content><![CDATA[<p>很多人对 <code>&lt;? extends T&gt;</code> 和 <code>&lt;? super T&gt;</code> 这两个泛型<strong>通配符</strong>的用法不清楚，经常会出现理解无法，下面来看一下到底如何正确的使用这个组合。</p>
<h2>&lt;? extends T&gt;</h2>
<p>先来看一段代码，以下的这段代码用来遍历一个装有 Integer 数据的 list:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNumberList</span><span class="params">(List&lt;Integer&gt; integerList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : integerList) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历一个 Integer List</span></span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">printNumberList(integerList);</span><br></pre></td></tr></table></figure></p>
<p>如果我还想遍历另外一个装有 Double 数据的 list，我得写另外一段代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNumberList</span><span class="params">(List&lt;Double&gt; doubleList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Double d : doubleList) &#123;</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历一个 Double List</span></span><br><span class="line">List&lt;Double&gt; doubleList = Arrays.asList(<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>,<span class="number">5.5</span>,<span class="number">6.6</span>);</span><br><span class="line">printNumberList(doubleList);</span><br></pre></td></tr></table></figure></p>
<p>在工作中这样写代码怕是不行吧？很简单就可以想到使用<code>泛型</code>来对这个代码进行优化：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printNumberGenericsList</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T l : list) &#123;</span><br><span class="line">        System.out.println(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用泛型来遍历多种类型的 List</span></span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">List&lt;Double&gt; doubleList = Arrays.asList(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span>);</span><br><span class="line">printNumberGenericsList(integerList);</span><br><span class="line">printNumberGenericsList(doubleList);</span><br></pre></td></tr></table></figure></p>
<p>代码运行起来了，很好的解决了这个问题。其实还有问题，看下面的代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">"name1"</span>, <span class="string">"name2"</span>, <span class="string">"name3"</span>);</span><br><span class="line">printNumberGenericsList(strList);</span><br></pre></td></tr></table></figure></p>
<p>本来这个方法是想用来打印数字类型的 List，而我放进了一个 String 类型的 List，也能够正常的跑起来，对于这个方法没有什么问题，但是比如说后续把这个方法内部实现改了，加上了数字的运算，再传输 String 类型的 List 就会出错了，所以在这里我想只想接受数字类型的 List，代码修改如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNumberGenericsExtendsList</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Number l : list) &#123;</span><br><span class="line">        System.out.println(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">List&lt;Double&gt; doubleList = Arrays.asList(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span>);</span><br><span class="line">printNumberGenericsExtendsList(integerList);</span><br><span class="line">printNumberGenericsExtendsList(doubleList);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">"name1"</span>, <span class="string">"name2"</span>, <span class="string">"name3"</span>);</span><br><span class="line"><span class="comment">// 在编译期就无法通过</span></span><br><span class="line"><span class="comment">// printNumberGenericsExtendsList(strList);</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们知道了 <code>&lt;? extends T&gt;</code> 的用法，为了将这个问题说的更清楚，再来看下面这段代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Number&gt; l1 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">List&lt;? extends Number&gt; l2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;? extends Number&gt; l3 = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line"></span><br><span class="line">l1.add(<span class="number">2</span>); <span class="comment">// 编译不通过</span></span><br><span class="line">l2.add(<span class="number">2</span>); <span class="comment">// 编译不通过</span></span><br><span class="line">l3.add(<span class="number">3</span>); <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，我们声明了 3 个 list，这没什么问题，但是当我们分别向 3 个 list 中添加元素的时候，居然会报错。因为 <code>&lt;? extends Number&gt;</code> 只能保证这个 List 中的内容都是 <code>Number</code> 类型的，当你添加一个 Integer 时，list 实际有可能指向 <code>List&lt;Double&gt;</code>，所以编译器不允许向 list 中添加元素，也就是说 <code>&lt;? extends T&gt;</code> 类型的 List 是<strong>只读</strong>的。</p>
<p>同样从 list 中获取值时，它也只能保证是 Number 类型的，所以无法从中获取 Integer 或者 Double 等类型的数据（可以取出来之后进行强制类型转换）。</p>
<p><strong>也就是说 &lt;? extends T&gt; 中只能放 T 类型或其子类的对象。</strong></p>
<h2>&lt;? super T&gt;</h2>
<p>搞懂了 <code>extends</code> ，那么 super 这个就不难懂了，看下面的代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Number&gt; l1 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">List&lt;? <span class="keyword">super</span> Number&gt; l2 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">l1.add(<span class="number">1</span>); <span class="comment">// 编译通过</span></span><br><span class="line">l2.add(<span class="number">2.2</span>); <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure></p>
<p>这里的 list 可以添加元素，只能添加 Number 或者 Number 的子类对象。但是不能向 list 中添加 Object 的类型，因为这个 list 的实际类型有可能是 <code>List&lt;Number&gt;</code>。</p>
<p>从 list 取值的时候，只能取出 Object 类型的值，因为只能保证取出来的值是 Object 的子类对象。</p>
<p>&lt;? super T&gt; 和 &lt;? extends T&gt; 可以组合起来使用（Collections.copy()，删减了一些代码），如下例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; src.size(); i++)</span><br><span class="line">        dest.set(i, src.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>PECS</h2>
<p>PECS 的全称是：Producer extends and Consumer super。</p>
<p>可以认为 PECS 说明了这两个通配符的使用场景。</p>
<p>这里以 List 为例：</p>
<ul>
<li>Producer extends：如果你需要一个 List 来为你生成 T 类型的数据（也就从 list 中读取 T 类型的数据），那就把这个 List 声明为 &lt;? extends T&gt;，比如 <code>List&lt;? extends Integer&gt;</code>。但是无法向 list 中添加元素。</li>
<li>Consumer super：如果你需要一个 List 来消费 T 类型的数据（也就是将 T 类型的数据写入到 list中），那就把这个 List 声明为 &lt;? super T&gt;，如 <code>List&lt;? super Integer&gt;</code>，但是只能从中取出 Object 类型的数据（需要自己进行强制转换）。</li>
<li>如果你需要对一个 List 同时进行读和写，那就不要使用通配符。如：<code>List&lt;Integer&gt;</code></li>
</ul>
<h2>泛型擦除问题</h2>
<p>&lt;? extends T&gt; 和 &lt;? super T&gt; 除了上面的用法之外，还能部分解决<strong>泛型擦除</strong>所带来的问题。</p>
<p>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，所以最后泛型数据其实就是被保存成了 Object，这样会带来一些问题，看下面的代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    strList.getClass().getMethod(<span class="string">"add"</span>, Object.class).invoke(strList, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"strList size: "</span>+ strList.size()); <span class="comment">// strList size: 1</span></span><br></pre></td></tr></table></figure></p>
<p>是的，没错，利用反射机制把 Integer 类型的数据插入到了 List&lt;String&gt; 中，这肯定是有问题的，在获取数据时就会发生<strong>强制类型转换错误</strong>。</p>
<p>这当然是一个比较极端的情况，而且 Java 目前也没有办法完全把这个问题解决。但是使用 <code>&lt;? extends T&gt;</code> 让避免对象被擦除成 Object，如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">String</span>&gt; </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">        System.out.println(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class clazz = Demo.class;</span><br><span class="line">Field[] fs = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> ( Field f:fs) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Field name: "</span>+f.getName()+<span class="string">", field type:"</span>+f.getType().getName());</span><br><span class="line">    <span class="comment">// Field name: data, field type:java.lang.String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java 泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>简单聊一聊区块链</title>
    <url>/2018/11/11/%E7%AE%80%E5%8D%95%E8%81%8A%E4%B8%80%E8%81%8A%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<h4>区块链是什么</h4>
<p>在经历了大起大落之后，区块链似乎已经被妖魔化了，关于区块链的资料也有很多，今天我想从不同的角度来聊一下区块链。区块链的技术关键点有以下几点：</p>
<ul>
<li>
<p>P2P 网络</p>
</li>
<li>
<p>共识算法</p>
</li>
<li>
<p>哈希与加密算法</p>
</li>
<li>
<p>数据库</p>
</li>
</ul>
<p>P2P 就不用说了，是一个很成熟的技术，迅雷就是基于这个技术做的。共识算法是从传统的分布式一致性算法演化而来的。哈希算法用在了区块的打包和公钥里面，加密算法就是区块链安全的保障了。所以区块链本质上是基于这些技术实现的一个分布式网络的数据库系统。</p>
<h4>区块链能做什么</h4>
<p>从区块链这个技术诞生起，就一直有人在炒去中心化的概念，甚至有人说会带来革命，其实这一点是有待商榷的。区块链的概念诞生于比特币，但是现在区块链已经不仅仅是比特币乃至数字货币的概念了。比特币可以看做是区块链的一个应用，为什么说区块链去中心化的概念不是准确呢？因为到目前为止，真正意义上的去中心化的应用可能也就只有比特币一种了。其他的所有应用都或多或少有中心化的影子，至少不能说是完全去中心化的。</p>
<p>但是区块链确确实实是解决了一个问题，那就是信任问题。需要注意的是，区块链解决的信任问题也不是那么的完美。怎么说呢？类似比特币这种应用，它是完全去中心化的应用。那么它就可以解决全球的信任问题，这也就是为什么那么多的黑市和战乱地区的交易使用的都是比特币。</p>
<p>但是对于那些去中心化不完全的应用，它只能解决局部的信任。比如以太坊、EOS和联盟链，这类应用信任的前提是你要信任那些手握决定权的机构或者人。这类应用能解决的就是这个范围内的应用。还是不太理解？举个例子，XX银行联合国内所有的银行搭了一条联盟链，这条链可以提高交易效率，降低成本。但是关键节点的控制还都是再XX银行手中。所以你作为一个个人或者一个企业你用不用这个链取决于你信不信任这个XX银行。所以有人说，这和现在的银行体系也没啥区别呀，对呀，这就是现状。区块链至少目前没有想象的那么乐观。也许比特币的创始人正是因为看到了这一点才直接退隐，让比特币完全去中心化。</p>
<p>但是区块链也确实是解决了一些问题，至少目前可以确定的应用场景包括金融交易、产地溯源、物流。至少在需要陌生人信任的场景应该都是可以尝试区块链技术的，但是基本上这些应用的范畴都是属于联盟链的范畴，也就是说，绝大多数的区块链应用是没有去中心化的。</p>
<h4>区块链的未来在哪里</h4>
<p>面对空气币、量子威胁下，很多人觉得区块链没有未来，但是我的看法刚好是相反的。因为技术是在不断发展的，区块链技术本身也不是静态的，也是在动态发展的，所以技术方面是不需要由太多的担心的。对于区块链来说，最有价值的地方不是它的技术，而是它的思想。区块链的这些理论可以带来新的组织架构，新的交易方式，甚至于新的生活方式。在传统的公司组织、招聘和交易中，如何建立信任是一个非常消耗成本的过程。而将区块链技术天生就适合用来解决信任问题。所以区块链技术还是值得被看好的。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>算法简明教程</title>
    <url>/2017/05/06/%E7%AE%97%E6%B3%95%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3>复杂度分析</h3>
<p>通过直接跑算法得到的执行时间和占用内存大小的统计称之为<strong>事后统计法</strong>，这种方法有很大的局限性：</p>
<ul>
<li>测试结果非常依赖测试环境</li>
<li>测试结果受数据规模的影响很大</li>
</ul>
<p><strong>大 O 复杂度表示法</strong>可以不用具体的数据进行测试，就可以粗略的估算算法的执行效率。</p>
<h4>时间复杂度</h4>
<blockquote>
<p>所有代码的执行时间 $T(n)$ 与每行代码执行的执行次数 n 成正比</p>
</blockquote>
<p>$$T(n) = O(f(n))$$</p>
<p>这就是大 O 时间复杂度表示法，但这个方法实际上并不代表代码真正的执行时间，而是代表代码执行时间随数据规模增长的变化趋势，也称之为渐进时间复杂度。</p>
<p>如何具体的分析算法的时间复杂度：</p>
<ul>
<li>只关注循环执行次数最多的一段代码</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ul>
<p><strong>常见的时间复杂度</strong>：</p>
<ul>
<li>常量阶： $O(1)$</li>
<li>对数阶： $O(logn)$</li>
<li>线性阶： $O(n)$</li>
<li>线性对数阶： $O(nlogn)$</li>
<li>平方、立方、k次方阶： $O(n^2)$ $O(n^3)$ $O(n^k)$</li>
<li>指数阶： $O(2^n)$</li>
<li>阶乘阶： $O(n!)$</li>
</ul>
<p><strong>最好时间复杂度</strong>：最理想的情况下，执行这段代码的时间复杂度
<strong>最坏时间复杂度</strong>：最坏的情况下，执行这段代码的时间复杂度
<strong>平均时间复杂度</strong>：加权平均复杂度或者期望时间复杂度
<strong>摊还时间复杂度</strong>：把一次复杂操作的时间平均到 n - 1 次简单操作上，所以整体还是简单操作的时间复杂度</p>
<h4>空间复杂度</h4>
<p>表示算法的存储空间与数据规模之间的增长关系，通常用到的空间复杂度有 $O(1)$、$O(N)$、$O(N^2)$。</p>
<h3>递归</h3>
<p>可以使用递归方法解决问题的三个条件:</p>
<ul>
<li>一个问题可以分解为多个问题的解</li>
<li>这个问题与分解之后的子问题，除了数据规模不同，其他的完全一样</li>
<li>存在递归终止条件</li>
</ul>
<blockquote>
<p>编写递归代码时，需要找出递推公式，而不要去想每一层递归的细节</p>
</blockquote>
<p>递归的问题：</p>
<ul>
<li>警惕出现堆栈溢出</li>
<li>警惕重复计算</li>
</ul>
<h3>排序</h3>
<h4>排序算法的衡量标准:</h4>
<ul>
<li>排序算法的执行效率
<ul>
<li>最好情况、最坏情况、平均时间复杂度</li>
<li>时间复杂度的系数、常数、低阶</li>
<li>比较次数和交换次数</li>
</ul>
</li>
<li>排序算法的内存消耗</li>
<li>排序算法的稳定性</li>
</ul>
<h4>冒泡排序</h4>
<p>时间复杂度：$O(n^2)$
最好时间复杂度： $O(n)$
最坏时间复杂度： $O(n^2)$
空间复杂度: $O(1)$ 原地排序
稳定性：稳定
数据范围： 适合小规模数据</p>
<h4>插入排序</h4>
<p>时间复杂度：$O(n^2$
最好时间复杂度：$O(n)$
最坏时间复杂度：$O(n^2))$
空间复杂度：$O(1)$
稳定性: 稳定
数据范围： 适合小规模数据</p>
<h4>选择排序</h4>
<p>时间复杂度：$O(n^2)$
最好时间复杂度: $O(n^2)$
最坏时间复杂度: $O(n^2)$
空间复杂度: $O(1)$
稳定性: 不稳定
数据范围: 适合小规模数据</p>
<h4>归并排序</h4>
<p>归并排序是自下而上的排序方法，所以要先分区再处理数据，而快排则是相反的，需要先处理数据，再来分区。</p>
<p>时间复杂度: $O(nlogn)$
最好时间复杂度: $O(nlogn)$
最坏时间复杂度: $O(nlogn)$
空间复杂度: $O(n)$
稳定性: 稳定
数据范围: 适合大规模数据</p>
<h4>快速排序</h4>
<p>快速排序进行分区时，使用的方式与选择排序有点类似，首先选择这个分区的最后一个值作为分区点的值。就是将小于分区点的元素都放在数组的前面，最后把分区点移到中间，后面的元素就都大于分区点，分区也就完成了。</p>
<p>利用快速排序可以在 $O(N)$ 的时间复杂度内找出一个无序数组中第 K 大的元素。</p>
<p>时间复杂度：$O(nlogn)$
最好时间复杂度: $O(nlogn)$
最坏时间复杂度: $O(nlogn)$
空间复杂度: $O(1)$
稳定性: 不稳定
数据范围: 适合大规模数据</p>
<h4>桶排序</h4>
<p>桶排序的核心思想是将要排序的数据分别分到几个桶里面，然后对桶里面的数据进行单独的排序。桶内排序完成之后，将每个桶内的元素按照顺序取出，得到的结果就是有序的。</p>
<p>时间复杂度：$O(n)$
最好时间复杂度: $O(n)$
最坏时间复杂度: $O(nlogn)$
空间复杂度: $O(n)$
稳定性:  稳定
数据范围： 适合大规模数据</p>
<h4>计数排序</h4>
<p>时间复杂度：$O(n)$
最好时间复杂度: $O(n)$
最坏时间复杂度: $O(nlogn)$
空间复杂度: $O(n)$
稳定性:  稳定
数据范围： 适合数据范围不大的场景</p>
<h4>基数排序</h4>
<p>基数排序对要排序的数据是有要求的，需要可以分割出独立的‘位’来进行比较。
时间复杂度：$O(n)$
最好时间复杂度: $O(n)$
最坏时间复杂度: $O(nlogn)$
空间复杂度: $O(n)$
稳定性:  稳定
数据范围： 适合数据范围不大的场景</p>
<h4>堆排序</h4>
<p>时间复杂度: $O(NlogN)$
最好时间复杂度: $O(NlogN)$
最坏时间复杂度: $O(NlogN)$
空间复杂度: $O(1)$
稳定性：不稳定
适用范围：适用于数据处在动态变化中的数据</p>
<h3>二分查找</h3>
<p>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间缩小为0。</p>
<p>时间复杂度: $O(logN)$
空间复杂度: $O(1)$</p>
<blockquote>
<p>二分查找对于数据有着严格的要求，数据必须存储在连续内存中，而且必须有序。</p>
</blockquote>
<p>二分查找算法有很多的变体：</p>
<ul>
<li>查找第一个值等于给定值的元素</li>
<li>查找最后一个值等于给定值的元素</li>
<li>查找第一个大于等于给定值的元素</li>
<li>查找最后一个小于等于给定值的元素</li>
</ul>
<h3>字符串匹配算法</h3>
<p>字符串匹配算法在各个编程语言中都有实现。</p>
<p>字符串匹配算法有很多实现:</p>
<ul>
<li>BF: 暴力匹配算法（朴素匹配算法）</li>
<li>RK: 在 BF 的基础之上引入哈希算法来提高效率</li>
<li>BM: 通过一次多移动位数来提高效率</li>
<li>KPM: 引入了动态规划的思想</li>
</ul>
<h3>四种算法思想</h3>
<h4>贪心算法</h4>
<p>对一组数据，定义了期望值和限制值，希望从中选出几个数据，在满足限制值得情况下，期望值最大，这个时候就可以使用贪心算法。</p>
<p>贪心算法应用有：</p>
<ul>
<li>霍夫曼编码</li>
<li>最小生成树算法</li>
<li>Dijkstra 最短路径算法</li>
</ul>
<h4>分治算法</h4>
<p>分治算法的关键在于将原问题分解为 n 个与原问题结构相似的子问题，然后递归的解决这些子问题，最后合并成一个结果，就是分而治之。</p>
<p>分治算法的应用有：</p>
<ul>
<li>MapReduce</li>
<li>处理海量数据</li>
<li>归并排序</li>
</ul>
<h4>回溯算法</h4>
<p>回溯的思想有点类似于枚举搜索。为了让枚举的过程有序，会将枚举的过程分成多个阶段，每个阶段都会选择一个路径，但路径走不通时，就会退回到上一个阶段，选择另一条路径。</p>
<p>回溯算法的应用有：</p>
<ul>
<li>深度优先搜索</li>
<li>八皇后</li>
<li>0-1 背包</li>
<li>图的着色</li>
<li>旅行商问题</li>
<li>数独</li>
<li>全排列</li>
<li>正则表达式</li>
</ul>
<h4>动态规划</h4>
<p>动态规划一般用来解决最优问题。可以用动态规划解决的问题一般有三个特征:</p>
<ul>
<li>最优子结构：问题的最优解当中包含子问题的最优解，也就是说可以通过子问题的最优解来推断问题的最优解</li>
<li>无后效性：在推导后续的问题时，只关注当前阶段的状态值，而不关心这个状态是怎么推导出来的。而且某个阶段的状态确定后，就不会收后续阶段的影响。</li>
<li>重复子问题</li>
</ul>
<p>动态规划的应用有：</p>
<ul>
<li>爬楼梯</li>
<li>0-1 背包</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>看咖啡店如何做扩容</title>
    <url>/2020/03/26/%E7%9C%8B%E5%92%96%E5%95%A1%E5%BA%97%E5%A6%82%E4%BD%95%E5%81%9A%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<p>这是一篇<a href="http://highscalability.com/blog/2014/3/17/intuitively-showing-how-to-scale-a-web-application-using-a-c.html" target="_blank" rel="noopener">译文</a>，文章使用一个经营咖啡店的例子来讲解 Web 应用扩容会经历的几个阶段，很有意思，通俗易懂。</p>
<hr>
<p>我有一个小咖啡店。</p>
<p>店铺的开销和资源成正比：
100平方英尺的店铺面积和公用设施，一个服务员，一台咖啡机。</p>
<p>店铺的容量：
同一时间只能服务一个顾客，花 3 分钟出咖啡，服务完一个顾客总共会花 5 分钟。</p>
<p>假设服务员从来不休息，而且这台德国造的咖啡机不出问题，这个咖啡店的最大吞吐量是：12 个顾客 / 小时。</p>
<p><img src="1.png" alt=""></p>
<h2>Web 服务器</h2>
<p>同一时间只能服务一个客户，所以顾客会在高峰时期离开，这里也没有地方让人等。</p>
<p>我把店铺升级了，新店铺看起更好。</p>
<p>现在的开销：
同样的店铺面积，3 个服务员，2 个咖啡制造机，2 把椅子。</p>
<p>现在店铺的容量：
3 分钟可以出 2 杯咖啡，7 分钟内可以服务 3 个顾客，还可以让 2 个顾客坐在椅子上排队等候。</p>
<p>店铺的并发顾客数 = 3</p>
<p>店铺的顾客容量 = 5</p>
<p><img src="2.png" alt=""></p>
<h2>垂直扩容</h2>
<p>业务正在爆炸式增长，又该升级了，更大点会更好。</p>
<p>现在的开销：
200 平方英尺的区域，5 个服务员，4 台咖啡机，3 把椅子。</p>
<p>店铺的容量在线性增长，情况很好。</p>
<p>但是到夏天时，客流量下降了，这对于咖啡店来说很正常，所以我又想把店铺的规模缩小，但是我的房东却不允许我那么做。</p>
<p>垂直扩容对我这个客流量不稳定的店来说太贵了，大规模不一定好。</p>
<p><img src="3.png" alt=""></p>
<h2>通过负载均衡器来水平扩容</h2>
<p>房东愿意按照固定的区域（容纳 3 个服务员）来扩大或者缩小，如果我提前告知的话，他可以很轻松的打开或者关闭一个摊位。</p>
<p>如果我可以通过一个店面来同时管理多个摊位。</p>
<p>还真有这么一种柜台（<strong>负载均衡器</strong>）就是专门用来应对这种情况的。</p>
<p>它允许多个顾客同时与一个服务员交谈，实际上面对顾客的这个雇员不需要去制作咖啡了，只需要与顾客交谈并且将订单分发给制作咖啡的人。并且制作咖啡的人也不用来面对这些讨厌的顾客了。</p>
<p>这样做的优点是：如果我需要扩大规模，我可以直接添加一个可以容纳三个服务员的区域（和房东达成的协议），然后把这个区域和柜台连接起来，反之也可以用这种方式来缩小规模。</p>
<p>虽然费用增加了，但我也能更好地处理店铺的容量。我可以进行水平的扩容和缩容。</p>
<p><img src="4.png" alt=""></p>
<h2>资源集中处理</h2>
<p>我的咖啡机还可以用来处理制作食物，许多顾客告诉我他们想要买新鲜的烘焙面包，我就这个添加到菜单了。</p>
<p>但是有一个问题，一次能制作 2 杯咖啡的机器只能制作 1 磅面包，而且还要花两倍的时间。</p>
<p>在单位时间内，
生产 1 磅面包 = 制作 4 杯咖啡</p>
<p>有时候面包订单已经阻塞我的系统了，点咖啡的人也在不满的等待着，关于我工作低效的言论已经开始扩散开了。</p>
<p>我需要利用现有的资源来优化订单的处理方式</p>
<p><img src="5.png" alt=""></p>
<h2>基于异步队列的处理方式</h2>
<p>我引入了一个基于令牌的队列系统。</p>
<p>顾客进入到店之后，提交订单，然后拿一个令牌号码在等待。</p>
<p>这个订单按照类型进入不同的队列：面包或是咖啡。</p>
<p>服务员通过队列来决定他们接下来是烘焙面包还是制作咖啡。</p>
<p>当一份面包或者一杯咖啡就绪之后，就会被放到一个输出托盘上，处理订单的服务原就会喊出令牌号码，顾客就可以取走面包或咖啡。</p>
<ul>
<li>输入队列和输出托盘是新加入的，其他的资源都是现成的，只不过在用不同的方式在工作</li>
<li>从顾客的视角来说，现在是完全不同的了</li>
<li>店铺开销和容量的计算已经很复杂了，整个系统的复杂度也在上升，如果出现问题，就很难进行排查和修复问题</li>
<li>如果顾客接受了这种异步系统，那我们就可以管理这种复杂性了，它提供了一种方式来扩打容量和生产不同种类的产品，我可以用这种方式来吓一吓我们对面的竞争者了</li>
</ul>
<p><img src="6.png" alt=""></p>
<h2>后续</h2>
<p>我们已经达到了 Web 服务器的极限了，负载均衡，异步队列系统都用上。然后还可以做什么？</p>
<p>在后续阶段，用咖啡店来做比喻已经完全站不住脚了。如果你想了解更多，可以去搜索 DNS 负载和其他的扩容技术。如果你是 Web 应用扩容的新手，使用这篇文章中提到的技术就够了。咖啡店运营是一个经过简化的例子，以便激发读者对 Web 应用扩容的兴趣。如果你想深入学习，可以修改这个系统，然后与专业的人进行深入的讨论。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式 架构</tag>
      </tags>
  </entry>
  <entry>
    <title>给代码上一份保险</title>
    <url>/2021/12/11/%E7%BB%99%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%B8%80%E4%BB%BD%E4%BF%9D%E9%99%A9/</url>
    <content><![CDATA[<p>程序员都知道代码规范很重要，但是代码规范太多了，很多时候也不一定能够全部记得住。而 git 中的 <a href="https://pre-commit.com/" target="_blank" rel="noopener">pre-commit</a> 就是这样的一个神器，可以帮助你在 git commit 时，检查代码是不是没有问题。</p>
<p>这里需要区分一下，git 自带了一个 pre-commit，本文介绍的是 pre-commit 是一个 git pre-commit 的扩展框架，可以用来管理、开发多种语言插件。后面所说的 pre-commit 都是指这个框架。</p>
<p>pre-commit 官网：<a href="https://pre-commit.com/" target="_blank" rel="noopener">https://pre-commit.com/</a></p>
<h2>1. 安装</h2>
<p>pre-commit 插件是使用 Python 开发的，如果安装了 pip，直接使用 pip 安装：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ pip install pre-commit</span><br></pre></td></tr></table></figure></p>
<p>如果是 python 的项目，直接在 requirements.txt 依赖文件中添加：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pre-commit</span><br></pre></td></tr></table></figure></p>
<p>在 MacOS 上可以使用 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 安装：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ brew install pre-commit</span><br></pre></td></tr></table></figure></p>
<p>在 Windows 上，可以使用 <a href="https://docs.conda.io/en/latest/" target="_blank" rel="noopener">conda</a> 安装：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ conda install -c conda-forge pre-commit</span><br></pre></td></tr></table></figure></p>
<p>查看是否安装成功：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ pre-commit --version</span><br><span class="line">pre-commit <span class="number">2.16</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></p>
<h2>2. 使用</h2>
<p>这个工具的使用也很简单，只需要在项目的根目录底下创建 <code>.pre-commit-config.yaml</code>，然后在项目中填充下面的内容：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">repos:</span><br><span class="line">-   repo: https:<span class="comment">//github.com/pre-commit/pre-commit-hooks</span></span><br><span class="line">    rev: v2<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">    hooks:</span><br><span class="line">    -   id: check-yaml</span><br><span class="line">    -   id: end-of-file-fixer</span><br><span class="line">    -   id: trailing-whitespace</span><br><span class="line">-   repo: https:<span class="comment">//github.com/psf/black</span></span><br><span class="line">    rev: <span class="number">19.3</span>b0</span><br><span class="line">    hooks:</span><br><span class="line">    -   id: black</span><br></pre></td></tr></table></figure></p>
<p>根标签是 repos，表示可以配置多个 repo，每一个 repo 表示一个 git 地址，表示使用的插件库，rev 表示使用的 tag 版本，hooks 表示你要使用插件库中的那些插件。</p>
<p>配置文件写完之后，然后执行 pre-commit install 安装插件：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ pre-commit install</span><br><span class="line">pre-commit installed at .git/hooks/pre-commit</span><br></pre></td></tr></table></figure></p>
<p>而且每次配置有变更的时候，运行下面的命令：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pre-commit run --all-files</span><br></pre></td></tr></table></figure></p>
<p>然后每次执行 git commit 时，git 都会调用这些插件，如果有插件执行失败，那些这次 commit 就会失败：</p>
<p><img src="0.png" alt=""></p>
<h2>3. 自定义</h2>
<p>pre-commit 提供了很多可以直接使用的插件，就在 <a href="https://github.com/pre-commit/pre-commit-hooks" target="_blank" rel="noopener">https://github.com/pre-commit/pre-commit-hooks</a> 这个仓库中。</p>
<p>但很多时候，这个仓库中的插件并不能完全满足要求，比如我现在日常工作中主要写 Go，那么就需要自定义一些插件。</p>
<p>在定义一个插件库时，需要在库的根目录创建一个 <code>.pre-commit-hooks.yaml</code> 文件，在这个文件中定义插件，插件完成后，就可以把库给其他人使用了。</p>
<p>在这个配置文件中，每一项配置如下：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">-   id: trailing-whitespace</span><br><span class="line">    name: Trim Trailing Whitespace</span><br><span class="line">    description: This hook trims trailing whitespace.</span><br><span class="line">    entry: trailing-whitespace-fixer</span><br><span class="line">    language: python</span><br><span class="line">    types: [text]</span><br></pre></td></tr></table></figure></p>
<p>id 是插件的唯一标识，后续也是根据 id 来使用插件，name、description 是插件的名称和描述，自定义就行，extry 则表示具体插件的路径，一般是一段脚本文件。language 是编写这个插件所用的语言，目前支持 python、Go、node、bash 等诸多语言。types 是用来过滤目标文件，就是这个插件在那些文件上起作用。</p>
<p>还有很多其他的属性可以配置，具体可以参考：<a href="https://pre-commit.com/#new-hooks" target="_blank" rel="noopener">https://pre-commit.com/#new-hooks</a></p>
<p>新建的插件库还可以引用其他的插件库，只要创建配置文件引用其他的插件即可： <code>.pre-commit-config.yaml</code> 。</p>
<p>同时 pre-cpmmit 提供了一个 插件的搜索页面：<a href="https://pre-commit.com/hooks.html" target="_blank" rel="noopener">https://pre-commit.com/hooks.html</a>。可以在这里找到自己想要的插件，基本覆盖了主流的语言。</p>
<p>如果你想提交自己的插件，可以 fork 这个仓库：<a href="https://github.com/pre-commit/pre-commit.com" target="_blank" rel="noopener">https://github.com/pre-commit/pre-commit.com</a>，在仓库中添加自己的插件。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊找工作</title>
    <url>/2019/08/24/%E8%81%8A%E8%81%8A%E6%89%BE%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>经过了差不多两个月的折腾，终于完成找工作、离职和入职的整个过程。在这里简单谈一下找工作和面试的体会，在这次找工作之前，我已经差不多 5 年左右的时间没有正儿八经的参加过面试，所以对现在市场上面试的方式已经基本不了解，所以在刚开始面试的时候简直让人绝望，在经过了几个面试之后才慢慢找到了感觉。</p>
<p>在简历准备完成之后，就开始投简历，基本上都是在 BOSS 上完成投递的，整个体验还不错。投递简历之后，慢慢的就可以收到一些面试。基本上所有公司的面试流程都相差不大，但是不同公司的面试体验就完全不一样了。</p>
<p>有的公司的面试过程让人很舒服，不论面试的结果怎么样，如果面不上就确实是自己不合适或者水平不够，自己也不会有别的情绪产生。但是有的公司的面试官给人的体验就想让他下班别走。在整个面试的过程表现的及其傲慢，不断的打断我说话，各种先入为主的念头不断的喷出来，嘴巴臭的就像是刚吃完翔，实在是想不通这么大个公司怎么会让这种人出来做面试官，对于一个公司来说，面试是为公司寻找新鲜血液最重要的手段，不论对于面试者的水平怎么样，用这种傲慢的方式去对待面试者肯定是有问题的，如果是面试者现阶段的能力不行，那他以后也有机会成长为一个很优秀的人，也有机会重新合作。再退一步说，面试者不合适，那他或许有认识的人很合适，用这种不合理的态度去对待他们，结果可想而知，具体哪些公司就不说了，就是吐槽一下。</p>
<p>其他的岗位就不是很清楚，但是对于开发相关的岗位来说，想要拿到一些比较好的 offer，肯定是好好准备的。首先是算法的能力，这个应该是短时间内面试官测试一个人水平最直接的方式，因为算法能力是最不容易通过突击学习来获得的。然后就是网络、操作系统相关的知识，这些短时间内也很难通过突击来学习，即使通过突击学习到了相关的概念，也很容易被面试官用一些更加细节的问题来测试真实的水平。所以最好的方式就是平时注意这些方面的积累。另外对于一些使用过的框架技术，一定需要深入的去学习一下，不要让面试官觉得你知其然不知所以然，最后就是对于真的不知道的内容，老实的回答不知道就好了。</p>
<p>然后再说一下与 HR 聊 offer 的过程。首先，不论你和一个 HR 聊的多开心，也一定要接着去面试其他，手上尽可能的多拿一些口头 offer，这并不是鼓励拿了书面 Offer 不去，这样确实有点不道德。这样做是第一为了让自己在找工作的过程中能掌握更多的主动性，在与 HR 谈薪资的时候能够有更强的议价能力。第二是因为 HR 对 Offer 并没有最终的决定权，他给你的 Offer 最终是要得到领导的批准的，如果领导不批准，和 HR 聊的再开心都没有用，我在找工作的过程中就碰到了两次这样的情况，所以最好的方式就尽可能的多面试，然后从中选一个自己最满意的答应，拿书面的 Offer。</p>
<p>最后就是说一下找工作的方向问题，在开始找工作的时候，对于想从事的方向至少需要有一个大概的方向，因为对于自己不喜欢的业务，以后需要每天都面对它，想想都痛苦，而且最好是在应届毕业的时候就去找一个自己可以长期待下去的公司。否则在失去应届生这个保护伞之后，你面临的将会是与市面上其他的所有人进行竞争，到那时，基本上在学校里面取得的成绩将没有太大的用处了，所以在应届毕业的时候，要谨慎选择。</p>
<p>在经历了投简历、面试的过程后，过程虽然艰难，但对自己的认识也更清晰了一些。事实证明，我还是高估了自己，四五年的空缺并不是在短时间内能填满的，不过没关系，我对未来依然乐观。</p>
<p>文/ray</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯文档的使命</title>
    <url>/2018/04/24/%E8%85%BE%E8%AE%AF%E6%96%87%E6%A1%A3%E7%9A%84%E4%BD%BF%E5%91%BD/</url>
    <content><![CDATA[<p>​       腾讯文档，一个迟到了8年的产品。但还是在今年发布了，小马哥亲自为这个产品代言，因为这是一个对腾讯在企业办公上布局有战略影响的产品。</p>
<p>​       现如今腾讯拥有着qq和微信两个最大的社交入口。腾讯文档无疑是打通了用这两个工具办公的用户。而且现如今企业微信也正正在发力当中。有了腾讯文档这个工具之后，腾讯在企业办公协作领域的布局已经有了很清晰的布局了。</p>
<p>​      腾讯文档的体验可以说是相当的不错了。完美的适配 word 和 excel，而且解决了在线协作和版本管理的问题。也许腾讯的这些功能做的并不比其他的办公协作平台好，但是却已经做到了足够好。再加上在腾讯的这个平台上的天然优势，这个工具融入到用户日常办公中只会越来越迅猛吧。</p>
<p>阿里在这之后也迅速发布了内部文档协作平台语雀，但是这种方式只能是被动的防守吧。</p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title>让 Go 代码跑上移动端</title>
    <url>/2021/05/23/%E8%AE%A9-Go-%E4%BB%A3%E7%A0%81%E8%B7%91%E4%B8%8A%E7%A7%BB%E5%8A%A8%E7%AB%AF/</url>
    <content><![CDATA[<p>在一些特定的情况下，我们需要为移动端实现一些功能，如果为每一个移动端编写代码，不仅工作量大，而且很难维护。</p>
<p>我们使用的一个方案是编写 Go 代码，然后分别编译成不同平台的代码。Go 语言本身也提供了跨平台编译的方式，但是命令很复杂，需要配置很多参数，容易出错。目前有一些成熟的库可以直接使用，在这里使用的是 gomobile 框架。</p>
<p>本文使用的是 Go1.14，Go 语言的安装不再赘述。</p>
<h2>gomobile 安装</h2>
<p>gomobile 可以把 go 代码编译成<strong>移动端应用</strong>或者**移动端SDK，**本文演示的是编译成 SDK。</p>
<p>安装 gomobile：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get golang.org/x/mobile/cmd/gomobile</span><br></pre></td></tr></table></figure></p>
<p>安装不上的可以设置国内的 Go 代理：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure></p>
<p>go mobile 支持 Go Modules，所以不需要在 GOPATH 创建项目。创建了一个基于 Go Modules 的 hello 项目，其中只有一个文件 hello.go，具体代码如下：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"Hello %s!"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>Android 平台</h2>
<p>安装 Android Studio，下载最新版本就可以。</p>
<p>通过 Android Studio 的 SDK manager 下载 NDK 和 CMake，选中右下角的 Show Package Details 可以下载特定版本。</p>
<p>gomobile 对 NDK 的兼容性不好，我测试了 NDK 22 及以上版本都会失败，本文使用的 NDK 版本为 <code>21.4.7075529</code>，CMake 下载最新版本就可以。</p>
<p><img src="0.png" alt=""></p>
<p>然后配置环境变量：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_HOME=~/Library/Android/sdk</span><br><span class="line"><span class="built_in">export</span> ANDROID_NDK_HOME=~/Library/Android/sdk/ndk/21.4.7075529</span><br></pre></td></tr></table></figure></p>
<p>然后在 hello 项目的上一级目录执行以下命令:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello 是 go 项目的目录</span></span><br><span class="line">$ gomobile <span class="built_in">bind</span> -target=android hello</span><br></pre></td></tr></table></figure></p>
<p>把 Go 代码编译成 SDK 使用的是 bind 命令。上面命名执行完成后，就会在产产生两个文件:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello.aar</span><br><span class="line">hello-sources.jar</span><br></pre></td></tr></table></figure></p>
<p>然后直接吧 hello.aar 导入 到 android studio 中使用，就可以像使用普通 Java 包一样来调用 hello 方法，这一步就不再演示了，调用代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hello.Hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略无关代码</span></span><br><span class="line">        fab.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 在这里调用 hello 方法</span></span><br><span class="line">                Snackbar.make(view, Hello.hello(<span class="string">"ray"</span>), Snackbar.LENGTH_LONG)</span><br><span class="line">                        .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>IOS 平台</h2>
<p>编译到 IOS 平台的需要安装 XCode 和配套的 Command Line Tools，整个流程会比 Android 平台简单不少。</p>
<p>同样在项目的上级目录执行下面的命令：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello 是 go 项目的目录</span></span><br><span class="line">$ gomobile <span class="built_in">bind</span> -target=ios hello</span><br></pre></td></tr></table></figure></p>
<p>如果出现这个错误：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gomobile: -target=ios requires XCode</span><br></pre></td></tr></table></figure></p>
<p>到 xcode 中配置一下 Command Line Tools：</p>
<p><img src="1.png" alt=""></p>
<p>上面的命令执行成功之后，就会在本地生成一个 Hello.FrameWork 目录，这个就是 IOS 平台上的依赖库。可以直接把整个目录拷贝到 IOS 的目录底下，然后添加到项目的依赖中，就可以在代码中使用了：</p>
<p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里调用 hello 方法</span></span><br><span class="line">        <span class="type">Text</span>(<span class="type">HelloHello</span>(<span class="string">"ray"</span>))</span><br><span class="line">            .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>小结</h2>
<p>到这里，Go 代码在 Android 和 IOS 上都跑起来了，这个工具本质上还是对 Go 命令的封装。后续我会再写一篇文章来详细介绍 gomobile 的实现。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次服务器被黑事件</title>
    <url>/2018/08/31/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E9%BB%91%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>今天在使用 jenkins 部署一个项目的时候，感觉页面的速度加载很慢。于是登上服务器看了一下，使用 <code>top</code>看了一眼，出现了以下的情况：</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/20180808085419802.png" alt=""></p>
<p>发现 <code>cpu</code> 的使用率基本为100%，这肯定不正常，发现主要是由一个叫 qW3xT.2 的进程占据着 <code>cpu</code>，于是上网查了一下，发现这个是一个专门用于挖矿的病毒，也就是说，我的服务器被人当作矿机了。em.....好像不是很能忍，那只能想办法干掉它了。</p>
<p>网上也有一些解决办法，通常来说这个；病毒就是在服务器上不断的设置定时任务，然后通过 <code>curl</code> 不断获取脚本执行计算任务进行挖矿。杀死进程无效，定时任务会不断的重启服务。通常的解决办法就是，通过打印远程的脚本，看这个脚本是会下载什么内容，然后根据脚本的的执行情况去删除文件，最后杀死进程来解决问题。但是当我使用这个方法来解决问题的时候，有点不太对劲了。服务器上留下的定时任务如图所示：</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/1.png" alt=""></p>
<p>然后我就通过打印脚本去获取内容：</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/2.png" alt=""></p>
<p>有点不太对，这里面居然是另一条获取内容的脚本，和网上出现的情况都不太一样，于是顺藤摸瓜，再次获取一次，得到了下面的内容：</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/3.png" alt=""></p>
<p>em.....居然直接就是一个可执行的文件。也根本没办法找出来这个程序执行的操作，这就有点难搞了。删除那是不可能的，手动删除的速度根本比不上程序的速度。稍微观察了一下，发现服务器的定时任务脚本删除后，它都会利用剩余的任何一份脚本去远程下载，也就是说只有将它的下载路径掐断之后，应该就可以解决问题了。于是通过 <code>wget</code>去获取远程下载脚本的服务器的地址：</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/4.png" alt=""></p>
<p>在这里不能使用 <code>ping</code>，因为它一个域名可能绑定了好几个 <code>ip</code>，使用 <code>ping</code>不能将所有的 <code>ip</code>都查出来，所以使用 <code>wget</code>靠谱一点。然后使用 <code>iptables</code>将 <code>ip</code> 封掉:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -s 104.20.209.21 -j DROP</span><br><span class="line">iptables -I INPUT -s 104.20.208.21 -j DROP</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure></p>
<p>封掉后，然后就是将定时任务删除，杀死挖矿进程 <code>qW3xT.2</code> 和 <code>ddgs.3013</code>，删除 /tmp 文件夹下的 qW3xT.2 和 ddgs.3013 文件，并且将 .ssh 下的内容都清掉，当然如果你能识别出那个是恶意的，选择性删除也是可以的。</p>
<p>做完了这些事情后，这个病毒总算是解决了，剩下的就是清理了，修改 <code>redis</code> 端口，加密码验证，确保后续这样的事情不会再发生了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>黑客 linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次连接池问题排查</title>
    <url>/2020/03/21/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<p>最近排查了一个问题，是关于连接池的，服务的整体情况如下：</p>
<p><img src="pool1.png" alt=""></p>
<p>A 服务是向外提供的 Http 服务，然后 A 服务中会调用 B 和 C，B 和 C 是两个 RPC 服务。 A 服务中通过 B 和 C 提供的 Client 来分别访问这两个服务。</p>
<p>RPC 服务的 Client 创建会比较耗时间，因为需要从 ZK 上去获取服务的注册信息并初始化。所以一般会创建一个 Client 的连接池 ClientPool，所有的 Client 都从 ClientPool 中获取，类似在数据连接池中获取数据库连接。</p>
<p>最近服务出现了一个问题，在正常访问下，服务运行正常，服务的响应时间基本在 50 ms上下，当整体 qps 在 20000 左右的时候，就开始出现大量的请求响应很慢甚至超时。</p>
<p>分别检查的 B 和 C 的服务器资源，各机器服务都正常，日志里面也没有发现异常，IO 和网络也是正常的，说明问题不在服务端。</p>
<p>然后检查 A 服务的日志，发现大量的请求卡在从 CilentPool 中获取 Client，在高峰情况下，甚至会耗费差不多 10 秒，很多的请求无法获取到 Client 连接，问题就出在这里。</p>
<p>既然已经是从连接池中获取连接，为什么还是会出现这种情况？</p>
<p>看了一下连接池的源码，发现默认情况下进程会共享一个连接池实例，也就是说 B 和 C 的 Client 都要从这个连接池中获取，连接池又是按照单个 RPC 服务来设置的，所以就会出现连接池中可用的 Clent 数量不足。也就是下图这样的：</p>
<p><img src="pool2.png" alt=""></p>
<p>解决的办法有两个，一个是调大整个进程 ClientPool 的大小，但是这样还是会发生抢占，而且连接池设置的太大也不合适。另外一种方式就是为每个 Client 创建单独的线程池，这样每个服务的 Client 的数量可以有保证，也不会发生抢占的情况。也就是下面这样：</p>
<p><img src="pool3.png" alt=""></p>
<p>那么如何来为每个 RPC 服务都维护一个 ClientPool 呢，其实就是通过 ConcurrentHashMap 来为每个 RPC 服务维护一个连接池，key 是 RPC 服务的名称。</p>
<p>如果进程中共用一个连接池，在某些请求被阻塞的情况下，就会持续占据线程池的资源，而影响其他服务的访问。这也是造成这次问题的原因，单纯调大连接池的数量不能完全避免服务之间对连接的竞争。</p>
<p>通过为每个服务创建单独的连接池，将每个服务访问都进行了隔离，即使单个服务的请求出现问题也不会影响到其他的服务请求，在高流量的情况下更稳定。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移到Go modules</title>
    <url>/2021/01/23/%E8%BF%81%E7%A7%BB%E5%88%B0Go-modules/</url>
    <content><![CDATA[<p>这是 Go Modules 系列的第二篇文章，主要来说明如何从将现有的项目迁移到 Go Modules。</p>
<p>原文地址：<a href="https://blog.golang.org/migrating-to-go-modules" target="_blank" rel="noopener">https://blog.golang.org/migrating-to-go-modules</a></p>
<hr>
<h2>简介</h2>
<p>这是 Go Modules 系列的第二篇文章：</p>
<ul>
<li><a href="https://rayjun.cn/2021/01/17/%E4%BD%BF%E7%94%A8Go-modules/" target="_blank" rel="noopener">使用 Go Modules</a></li>
<li><strong>迁移到 Go Modules</strong></li>
<li>发布 Go Modules</li>
<li>Go Modules：V2 及后续版本</li>
<li>保持 Modules 的兼容性</li>
</ul>
<p>Go 项目使用的依赖管理工具多种多样。像 dep 和 glide 这样的 vendor 工具很受欢迎，但这些工具在使用方式上有很大的差别，所以通常很难一起使用。有些项目将整个 GOPATH 目录存储在一个 Git 仓库下。而有的人仅仅依靠 go get 来安装依赖，并期望在 GOPATH 中安装最新版本的依赖。</p>
<p>在 Go1.11 中，引入了 Go modules，这是一个官方的依赖管理方案，直接通过内建的 go 命令就可以使用。这篇文章介绍一些工具和方法来帮助项目迁移到 Go modules。</p>
<p>请注意：如果你想项目版本标签已经到了 v2.0.0 或者更高，当你添加 go.mod 文件的时候，你需要更新你的模块路径。我们后续的文章将解释在 v2 或者更高版本中如何在不影响用户的情况下做到这一点。</p>
<h2>把你的项目迁移到 Go Modules</h2>
<p>在迁移到 Go Modules 之前，项目应该属于以下的三种状态之一：</p>
<ul>
<li>一个全新的 Go 项目</li>
<li>一个已经创建的项目，使用了依赖管理，但不是 Go Modules</li>
<li>一个已经创建的项目，没有任何依赖管理</li>
</ul>
<p>第一种情况直接使用上篇<a href="https://rayjun.cn/2021/01/17/%E4%BD%BF%E7%94%A8Go-modules/" target="_blank" rel="noopener">文章</a>中所说的方法来使用 Go Modules。下面来讨论后面的两种情况。</p>
<h2>已经有依赖管理时</h2>
<p>转化一个已经使用了依赖管理工具的项目时，运行以下的命令:</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/my/project</span><br><span class="line">[...]</span><br><span class="line">$ <span class="built_in">cd</span> project</span><br><span class="line">$ cat Godeps/Godeps.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"ImportPath"</span>: <span class="string">"github.com/my/project"</span>,</span><br><span class="line">    <span class="string">"GoVersion"</span>: <span class="string">"go1.12"</span>,</span><br><span class="line">    <span class="string">"GodepVersion"</span>: <span class="string">"v80"</span>,</span><br><span class="line">    <span class="string">"Deps"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"ImportPath"</span>: <span class="string">"rsc.io/binaryregexp"</span>,</span><br><span class="line">            <span class="string">"Comment"</span>: <span class="string">"v0.2.0-1-g545cabd"</span>,</span><br><span class="line">            <span class="string">"Rev"</span>: <span class="string">"545cabda89ca36b48b8e681a30d9d769a30b3074"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"ImportPath"</span>: <span class="string">"rsc.io/binaryregexp/syntax"</span>,</span><br><span class="line">            <span class="string">"Comment"</span>: <span class="string">"v0.2.0-1-g545cabd"</span>,</span><br><span class="line">            <span class="string">"Rev"</span>: <span class="string">"545cabda89ca36b48b8e681a30d9d769a30b3074"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">$ go mod init github.com/my/project</span><br><span class="line">go: creating new go.mod: module github.com/my/project</span><br><span class="line">go: copying requirements from Godeps/Godeps.json</span><br><span class="line">$ cat go.mod</span><br><span class="line">module github.com/my/project</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require rsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>go mod init 会创建一个新的 go.mod 文件并且会自动从 <code>Godeps.json</code> 、<code>Gopkg.lock</code>中导入依赖（或者其他<a href="https://go.googlesource.com/go/+/362625209b6cd2bc059b6b0a67712ddebab312d9/src/cmd/go/internal/modconv/modconv.go#9" target="_blank" rel="noopener">支持的格式</a>）。go mod init 的参数是可能找到模块位置的模块路径。</p>
<p>这是在继续后续步骤之前运行 <code>go build ./..</code> 和 <code>go test ./..</code> 的好时机。接下来可能需要修改你的 go.mod 文件，如果你更喜欢采用迭代方法，最好把 go.mod 文件作为你的预模块依赖规范。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">go: downloading rsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca</span><br><span class="line">go: extracting rsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca</span><br><span class="line">$ cat go.sum</span><br><span class="line">rsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca h1:FKXXXJ6G2bFoVe7hX3kEX6Izxw5ZKRH57DFBJmHCbkU=</span><br><span class="line">rsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>go mod tidy 可以找到模块中被包间接引入的所有包。它会帮助现有的包补齐所有依赖，并且将那些没有使用的包删除。对于那些还没有迁移到 Go Modules 的包，在 go.mod 文件中将会被添加上 <code>// indirect</code> 标识。在将代码提交之前，最好运行一次 go mod tidy 命令。</p>
<p>然后确认代码的构建和测试都能通过：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build ./...</span><br><span class="line">$ go <span class="built_in">test</span> ./...</span><br><span class="line">[...]</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>请注意，其他依赖项管理器可能在单个包或整个存储库（而不是模块）级别指定依赖项。而一般不能识别 go.mod 文件中的依赖。因此，可能有些包不会得到与以前完全相同的版本，而且还存在破坏性升级的风险。所以，遵循上面命令并对产生的依赖项进行检查很重要。要做到这一点，需要运行下面的命令：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go list -m all</span><br><span class="line">go: finding rsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca</span><br><span class="line">github.com/my/project</span><br><span class="line">rsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>并且与老版本的依赖文件进行比较，确保选择了合适的版本。如果你发现了不合适的版本，可以通过go mod why -m 和 go mod graph 来查找原因，并使用 go get 命令升级或降级到正确的版本。（如果你需要的版本比之前选择的版本更旧，go get 将降低其他依赖版本，以维护兼容性。）举个例子：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod why -m rsc.io/binaryregexp</span><br><span class="line">[...]</span><br><span class="line">$ go mod graph | grep rsc.io/binaryregexp</span><br><span class="line">[...]</span><br><span class="line">$ go get rsc.io/binaryregexp@v0.2.0</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<h2>没有依赖管理时</h2>
<p>对于一个没有依赖管理的项目，首先需要创建一个 go.mod 文件：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://go.googlesource.com/blog</span><br><span class="line">[...]</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ go mod init golang.org/x/blog</span><br><span class="line">go: creating new go.mod: module golang.org/x/blog</span><br><span class="line">$ cat go.mod</span><br><span class="line">module golang.org/x/blog</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>由于没有之前版本管理工具的配置文件，go mod init 会创建一个 go.mod 文件，其中只有 module 和 go 的配置。在这个例子中，根据<a href="https://golang.org/cmd/go/#hdr-Remote_import_paths" target="_blank" rel="noopener">自定义导入路径</a>，我们将模块的路径设置为 golang.org/x/blog。用户可以通过这个路径来导入包，我们需要注意，不要改变这个路径。</p>
<p>module 关键字定义了模块路径，go 关键字定义了在这个模块中编译代码所需要的 Go 语言版本。</p>
<p>接下来，运行 go mod tidy 添加模块的依赖：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">go: finding golang.org/x/website latest</span><br><span class="line">go: finding gopkg.in/tomb.v2 latest</span><br><span class="line">go: finding golang.org/x/net latest</span><br><span class="line">go: finding golang.org/x/tools latest</span><br><span class="line">go: downloading github.com/gorilla/context v1.1.1</span><br><span class="line">go: downloading golang.org/x/tools v0.0.0-20190813214729-9dba7caff850</span><br><span class="line">go: downloading golang.org/x/net v0.0.0-20190813141303-74dc4d7220e7</span><br><span class="line">go: extracting github.com/gorilla/context v1.1.1</span><br><span class="line">go: extracting golang.org/x/net v0.0.0-20190813141303-74dc4d7220e7</span><br><span class="line">go: downloading gopkg.in/tomb.v2 v2.0.0-20161208151619-d5d1b5820637</span><br><span class="line">go: extracting gopkg.in/tomb.v2 v2.0.0-20161208151619-d5d1b5820637</span><br><span class="line">go: extracting golang.org/x/tools v0.0.0-20190813214729-9dba7caff850</span><br><span class="line">go: downloading golang.org/x/website v0.0.0-20190809153340-86a7442ada7c</span><br><span class="line">go: extracting golang.org/x/website v0.0.0-20190809153340-86a7442ada7c</span><br><span class="line">$ cat go.mod</span><br><span class="line">module golang.org/x/blog</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/gorilla/context v1.1.1</span><br><span class="line">    golang.org/x/net v0.0.0-20190813141303-74dc4d7220e7</span><br><span class="line">    golang.org/x/text v0.3.2</span><br><span class="line">    golang.org/x/tools v0.0.0-20190813214729-9dba7caff850</span><br><span class="line">    golang.org/x/website v0.0.0-20190809153340-86a7442ada7c</span><br><span class="line">    gopkg.in/tomb.v2 v2.0.0-20161208151619-d5d1b5820637</span><br><span class="line">)</span><br><span class="line">$ cat go.sum</span><br><span class="line">cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=</span><br><span class="line">cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=</span><br><span class="line">git.apache.org/thrift.git v0.0.0-20180902110319-2566ecd5d999/go.mod h1:fPE2ZNJGynbRyZ4dJvy6G277gSllfV2HJqblrnkyeyg=</span><br><span class="line">git.apache.org/thrift.git v0.0.0-20181218151757-9b75e4fe745a/go.mod h1:fPE2ZNJGynbRyZ4dJvy6G277gSllfV2HJqblrnkyeyg=</span><br><span class="line">github.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=</span><br><span class="line">[...]</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>go mod tidy 命令会添加所有依赖包以及依赖包的依赖，并且会生成一个 go.sum 文件，其中包含每个库的特定版本的校验和。最后让我们确认所有的构建和测试都能通过：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build ./...</span><br><span class="line">$ go <span class="built_in">test</span> ./...</span><br><span class="line">ok  	golang.org/x/blog	0.335s</span><br><span class="line">?   	golang.org/x/blog/content/appengine	[no <span class="built_in">test</span> files]</span><br><span class="line">ok  	golang.org/x/blog/content/cover	0.040s</span><br><span class="line">?   	golang.org/x/blog/content/h2push/server	[no <span class="built_in">test</span> files]</span><br><span class="line">?   	golang.org/x/blog/content/survey2016	[no <span class="built_in">test</span> files]</span><br><span class="line">?   	golang.org/x/blog/content/survey2017	[no <span class="built_in">test</span> files]</span><br><span class="line">?   	golang.org/x/blog/support/racy	[no <span class="built_in">test</span> files]</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>注意当 go mod tidy 添加一个依赖时，会添加最新版本。如果你的 GOPATH 包含了一个旧版本的依赖项，并且发布了一个破坏性的更改，你可能会在执行 go mod tidy、go build 或 go test 时看到错误。如果发生了这种情况，你可以通过 go get 来降级版本（比如：go get github.com/broken/module@v1.1.0），或者花时间来确认你的模块中每个依赖最新版本的兼容性。</p>
<h2>Go Modules 中的测试</h2>
<p>在迁移到 Go Modules 后，有些测试需要做些调整。</p>
<p>如果测试需要写包目录下的文件，当包目录在只读的模块缓存中时，它可能会失败。特别是这可能会导致所有的 go test 失败。测试应该将需要写入的文件复制到一个临时目录中。</p>
<p>如果一个测试依赖相对路径（../package-in-another-module）去其他包中定位和读取文件，如果这个包在其他的模块中，该模块将位于模块缓存的版本化子目录中或在 replace 指令中指定的路径中，测试就会失败。</p>
<p>如果测试期望测试中的 go 命令在 GOPATH 模式下运行，那么它可能会失败。如果发生这种情况，你需要添加一个 go.mod 文件到需要被测试的文件目录下，或者显式设置 GO111MODULE=off。</p>
<h2>发布一个版本</h2>
<p>最后，你应该给你的新模块打上一个标签，并发布一个新正式版本。这个操作是可选的，但是如果没有一个正式的版本，下游的用户就只能使用提交时产生的 pseudo 版本号，这样后续将很难继续支持。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag v1.2.0</span><br><span class="line">$ git push origin v1.2.0</span><br></pre></td></tr></table></figure></p>
<p>你的 go.mod 文件中定义了明确的导入路径，并且添加了新的最小版本需求。如果你的用户已经使用了正确的导入路径，你的依赖也没有造成破坏性的变更，添加 go.mod 就是向后兼容的。但这是一个重要的改变，可能会暴露已经存在的问题。如果你已经打过标签了，你应该增量的发布<a href="https://semver.org/#spec-item-7" target="_blank" rel="noopener">次版本</a>。详情查看<a href="https://blog.golang.org/publishing-go-modules" target="_blank" rel="noopener">发布 Go Modules</a> 来学习如何增量发布版本。</p>
<h2>导入和规范模块路径</h2>
<p>每个模块都在 go.mod 文件中定义了模块路径。每个引用模块内的包的 import语句都必须以模块路径作为包路径的前缀。但是，go 命令可能会通过许多不同的远程导入路径解析到同一个包含该模块的仓库。比如 golang.org/x/lint 和 golang.org/x/lint 都会解析到存储这些代码的仓库 go.googlesource.com/lint。这个仓库中的 go.mod 文件声明了路径为 golang.org/x/lint，因此只有该路径对应于有效的模块。</p>
<p>Go 1.4提供了一种使用 // import 注释声明规范导入路径的机制，但不是所有的包作者都会提供这些。因此，在模块出现之前编写的代码可能使用了模块的非规范导入路径，而不会出现不匹配的错误。当使用模块之后，导入路径必须与规范模块路径匹配，因此你可能需要更新导入语句，例如你可能需要更改 import &quot;github.com/golang/lint&quot; 以导入 &quot;golang.org/x/lint&quot;。</p>
<p>在另一个场景中，主版本为 2 或更高版本的模块，模块的规范路径可能与其存储库路径不同。主版本高于 1 的模块必须在其模块路径中包含主版本后缀。例如，版本 v2.0.0 必须包含后缀 /v2。然而，import语句可能引用了模块中没有那个后缀的包。例如，在 v2.0.1 版本中github.com/russross/blackfriday/v2 的非模块用户可能将其导入为github.com/russross/blackfriday，这就需要加上 /v2后缀来更新导入路径。</p>
<h2>结论</h2>
<p>对于大多数用户来说，转换到Go模块应该是一个简单的过程。但由于非规范的导入路径或依赖项中的破坏性更改，偶尔会出现问题。后续的文章将探讨发布新版本问题，v2 后续版本的问题，以及调试奇怪情况的方法。</p>
<p>请向我们发送<a href="https://github.com/golang/go/issues/new" target="_blank" rel="noopener">bug 报告</a>和<a href="https://github.com/golang/go/wiki/ExperienceReports" target="_blank" rel="noopener">体验报告</a>，帮助我们改善 Go 的依赖管理功能。</p>
<p>感谢你所有的反馈和帮助改进模块的建议。</p>
<hr>
<p>另外，腾讯云区块链方向在大量招人，包括前端、后端、架构师、产品等诸多岗位，如果感兴趣，请把简历投过来 <a href="mailto:rayjun0412@gmail.com">rayjun0412@gmail.com</a>。</p>
<p>译 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>读今日简史</title>
    <url>/2018/09/16/%E8%AF%BB%E4%BB%8A%E6%97%A5%E7%AE%80%E5%8F%B2/</url>
    <content><![CDATA[<p>这是简史三部曲的最后一本。这本书不谈过去，不再纠结人类到底从哪里来。也不谈未来，不去研究人类的终极心态。而在这本书里，作者想好好的谈谈当下，谈谈在未来的几十年的时间里面人类可能面临的问题于机运。</p>
<p>当下是过去和未来的连接点，人类在当前做出的任何大的决定都有可能改变人类的命运。作者认为，人类当前各个技术的高速发展已经让人类的个体有些跟不上了。人类的这颗与原始人没有太大区别的大脑很难去接收和处理这么多的信息，所以慢慢的就没有人能够真正的搞清楚这个复杂的世界了。很有可能在混乱当中有人一不小心摁下了毁灭人类的按钮，随着技术的发展，人类想毁灭自己会越来越简单。这里的复杂不仅仅是科技的发展使得整个社会复杂，更多的是随着社会高速的发展和融合，人类如何处理融合的过程中带来的各种问题。比如宗教、移民、文化、肤色。宗教带来的问题根本就不是几十年的时间可以解决的，但是在当前的这个时间点上，我们连十年后的预测都没有办法做出来。所以在这条起飞的路上如何来调节人类的宗教和民族矛盾是一个很大的议题。因为这些问题都有可能带来政局的不稳定，就有可能带来战争和人类的自我毁灭。所以作者也认为在这种情况下，人类不能太着急往前，而是要适当的停下来认清自己，认清那些故事越来越难掩盖的真相，虽然那些有时候不怎么让人愉快，但是，人类还是需要真相的。当然最重要的，人类还是需要好好生存下去的。</p>
<p>这本与与之前的两本书比起来，在结构上要松散一下，虽然读起来没有第一本那么惊艳，但是这本书也还是带来了足够的思考。现在人人都在谈论未来，但是很少有人考虑如果永远也到不了未来要怎么办。会不会在这个过程中由于人类的愚蠢把自己给毁灭了怎么办，这个也不是没有可能，看第一次和第二次的世界大战就知道了，而且更麻烦的是，人类的脑子虽然没怎么成长，但是武器的威力确实成长了不少。整体来说，这是一本值得一看的书，听多了乐观的狂欢，也该用悲观洗洗脑。</p>
<p>ps: 由于中间换了好几次名字，赞赏功能迟迟没有开通，今天终于开通了，如果可以的话，时不时请我喝个咖啡呀，那样我写起来就更带劲了~</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Ubuntu工作环境</title>
    <url>/2020/10/11/%E9%85%8D%E7%BD%AEUbuntu%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>现如今的开发环境选择很多，现在主流的操作系统有 Windows，Linux 和 MacOS。</p>
<p>体验最好，评价最高的就是 MacOS 了，Windows 一直中规中矩。</p>
<p>但是现在在 Linux 系统上，软件生态也越来越成熟了，通过合适的工具，也能打造一个合适的开发环境。Ubuntu 是一个比较受欢迎的 Linux 系统发行版。</p>
<p>现在主流的电脑都支持安装 Linux 系统，如果不想用 Windwos 来用作开发，那就可以安装 Ubuntu 等 Linux 系统，而且 Linux 系统相对来说对硬件的要求更低。</p>
<p>本文介绍如何配置一个合适的 Ubuntu 开发环境。</p>
<p>本文基于 Ubuntu18.04</p>
<h2>1. 基础软件</h2>
<h3>输入法</h3>
<p>首先就是要安装一个输入法，系统自带的输入法基本就没办法用了，现在比较好用的搜狗输入法、百度输入法都有 Linux 版本，可以按照自己的喜好使用。</p>
<p>我更喜欢百度输入法（百度其他的产品一般，但是输入法是个好产品），之前使用的也是搜狗输入法，但使用搜狗输入可能会导致开发工具 IntelliJ IDEA 无法打开，所以就换成了百度输入法。</p>
<h3>Git</h3>
<p>这个就不用说了，现在 Git 早就不止用来做代码的托管了，我现在自己的博客也是使用 Git 来进行管理。</p>
<h3>utools</h3>
<p>在 MacOS 中， Spotlighting 或者 Alfred 都是解放双手的利器，使用者两个工具可以大大减少鼠标的使用，提高输入效率。</p>
<p>之前在 Linux 系统中找不到类似的替代品，但是 utools 的出现解决了这个问题，而且 utools 在三个系统中都可以使用。</p>
<p>使用这个工具，可以将打开程序，搜索等功能只依靠键盘，不需要腾出手去使用鼠标。</p>
<p>utools 的功能很强大，除了常见的搜索功能，还可以支持各类的插件，比如安装有道词典的插件之后就可以划屏取词了。效果如下：</p>
<p><img src="0.png" alt=""></p>
<h3>WPS</h3>
<p>如果要在 Ububtu 中处理一些文档以及查看 PDF ，在 Ubuntu 系统中，WPS 应该是最好的选择了，希望 WPS 可以越做越好。</p>
<h2>2. 终端环境</h2>
<p>终端是一个很重要的工具，很多工具以及登录远程服务器环境的时候，都需要用到终端。</p>
<p>Ubuntu 中自带的终端工具不好用，可以使用 terminator 终端作为替代品，当然，这个也可以使用其他的终端，这个根据自己的喜好就可以了。</p>
<p>在 Ubuntu 中，默认使用的是 <code>bash</code>， <code>zsh</code> 在命令的补全和拼写功能更加强大，但是在执行脚本的时候，还是可以使用 bash，日常的使用过程中，zsh 是更好的选择。</p>
<p>在使用 zsh 时，已经有很多的工具可以配套使用， <code>oh-my-zsh</code> 是一个 zsh 的配置环境，这个配置可以让终端的交互性更好，对于很多常用的命令都有快捷的输入方式。</p>
<p>配合 oh-my-zsh 还有有一个可以配套使用的配置 <code>zsh-autosuggestions</code> ，这个配置可以根据终端中历史的输入，然后自动补全命令，可以提高输入的效率。</p>
<p>在使用终端时，还有 <code>tmux</code> 这个神器值得使用，很多情况下，需要与远程的服务器保持长久的链接，比如执行某个任务，但是与远程服务器的连接是有时间限制的，在超过这个时间限制之后，连接就会断开，如果这个时候任务还没有运行完成，那么也会被终止。</p>
<p>tmux 可以解决这个问题，tmux 可以保存这些连接，即使终端关闭，也可以保存这些连接，在需要使用的时候再恢复。</p>
<h2>3. 开发工具</h2>
<p>至于开发工具，不同的人使用的工具差别就很大了。但是好在一些很好的 IDE 都可以在 Ubuntu 中使用。比如 jetbrains 系列的 IDE，基本都能覆盖到主流的编程语言。而且这些 IDE 基本上都有社区免费版本，虽然功能上没有那么全，但是基本上也够用。</p>
<p>如果想要解锁完整版本，那就只能单买版权或者使用教育版本（只要有大学邮箱就可以，对学生和老师免费）。</p>
<p>有些人不喜欢使用 IDE，那么也自然可以使用编辑器，可以按照自己的喜好选择 Vim 和 emacs 或者 VsCode。对于 Vim，无论是否使用，都还是要学习一下基本的使用方法，因为在操作系统中，Vim 是默认的编辑工具，如果不会基本的使用，在Linux 系统中如果要做些编辑操作的话，就会很麻烦。</p>
<p>除了这些之外，就是安装自己需要的编程语言了。</p>
<p>另外如果涉及到 Web 开发，那么可能就会需要  Postman 这个工具，可以方便我们进行接口的测试，而且 Postman 也不仅仅是接口的测试工具，还可以将这些接口以团队进行协作。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2018/04/11/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>选择排序在每一次的遍历中会找到一个最大(小)值，然后将该值放到已排序的末尾。重复这个过程直到所有的值都处在一个有序状态。</p>
<h4>算法描述</h4>
<p>数组长度为n</p>
<ol>
<li>初始有序序列长度为0，无序序列长度为n；</li>
</ol>
<ol start="2">
<li>第i次遍历后，选出最大(小)值放在有序序列的末尾，有序长度为i，无序序列长度为n-1；</li>
</ol>
<ol start="3">
<li>n-1遍历后，排序完成；</li>
</ol>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/849589-20171015224719590-1433219824.gif" alt=""></p>
<h4>算法代码</h4>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n -<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index] &gt; arr[j]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>金字塔原理</title>
    <url>/2018/06/10/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>从上高中开始，我们开始写的文章基本就是议论文。在写一篇议论文的时候，我们需要提出自己的论点，然后需要列举出若干的论据来支持我们提出的论点。然后在文章结束的时候需要使用简短的话来对自己的文章做出一个简单的概括。</p>
<p>现在想起来，这可能是在高中阶段学习的最重要的一项能力。最近在看一本书，书名就叫做《金字塔原理》。这本书中提到，一篇好的文章或者是报告，条理清晰是最关键的。一篇有着良好结构的文章可以使读者更好的理解作者想要表达的意思以及更好的阅读体验。将文章的结构组织成金字塔结构可能一个好的方式，金字塔的结构如下:</p>
<p><img src="https://rayjun.oss-cn-beijing.aliyuncs.com/timg.jpeg" alt="timg"></p>
<p>金字塔结构与树的结构很类似，如果对计算机熟悉的人应该知道树是一种表达能力很强的结构。</p>
<h4>金字塔的四个基本原则</h4>
<p>搭建一个金字塔结构的时候有四个基本原则:</p>
<ul>
<li>结论先行：每篇文章只有一个中心思想，并放在文章的最前面</li>
<li>以上统下：每一层次上的思想必须是下一层次思想的终结概括</li>
<li>归类分组：每一组的思想必须属于同一范畴</li>
<li>逻辑递进：每一组中的思想必须按照逻辑顺序排列</li>
</ul>
<p>在向读者介绍一个新的思想的时候，结论先行往往是最有效的。特别是在中国这么委婉的文化氛围内，很多时候聊了大半天依然不清楚对方想要表达的意思。如果在一开始就将结论说出来，那么读者是带着结论去读接下来的内容，就容易理解的多。在这篇文章中，我就是采用了这样的方法。</p>
<h4>如何构建金字塔结构</h4>
<p>金字塔结构与树结构很类似，所以我们在构建一个金字塔结构的时候，有两种方法，一种是自上而下法，就是从文章的主题出发，去发散文章的结构。还有一种方法就是指下而上法，这种方法则要求先列出主要的观点，再从这些观点去提炼中心思想。</p>
<h5>自上而下</h5>
<ul>
<li>确定论述的主题</li>
<li>设想读者的疑问</li>
<li>给出答案</li>
<li>检查主题的背景和冲突是否能够引发读者提出疑问</li>
<li>证实答案并给出关键的论证点</li>
</ul>
<h5>自下而上</h5>
<ul>
<li>列出文章所有的要点</li>
<li>找出要点之间的关联</li>
<li>得出结论</li>
<li>推导出文章的主题</li>
</ul>
<p>上面两种方法是根据不同的情况来进行的。对于一个归纳的问题，自上而下的方法可能更合适一些，对于演绎的问题，则自下而上的方法可能更好一些。</p>
<h4>PPT演讲中的金字塔结构</h4>
<p>在做演讲的时候，保持良好的结构也是非常重要的，一个好的演讲应当全程能够吸引听众的注意力。所以整个PPT的构建也应当采用这种方法。但是在做PPT的过程中，与文章不同的是，PPT不应当出现大段的文字。而应当使用更多的图表，图标与文字的比例应当在9:1左右。</p>
<p>结构化思想可以让人更容易接受。构建结构化的金字塔应当在不同的情况下采用不同的方法，最终的目的就是需要能够更清晰的表达作者的思想，而读者也跟容易接受。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>零拷贝为什么这么快</title>
    <url>/2020/03/27/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/</url>
    <content><![CDATA[<p>文件拷贝是一个很常见的需求，无论是在程序中，还是日常使用计算机。在 Java 中，经常需要实现文件拷贝，而且有一种叫做零拷贝的技术，拷贝文件的效率非常高，在这篇文章中，我来来看一下零拷贝技术是怎么实现的。</p>
<h2>文件拷贝</h2>
<p>Java 中文件拷贝的方式有很多种：</p>
<ul>
<li>使用 java.io 中的 FileInputStream 和 FileOutputStream</li>
<li>使用 java.nio 中的 transferTo 或者 transferFrom</li>
<li>Files.copy() 方法</li>
<li>apache.common 中的 FileUtils.copyFile() 方法</li>
</ul>
<p><strong>使用 java.io</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File originFile = <span class="keyword">new</span> File(<span class="string">"originFile.txt"</span>);</span><br><span class="line">File copyFile = <span class="keyword">new</span> File(<span class="string">"copyFile.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(originFile);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(copyFile);)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = fis.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        fos.write(data, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用 java.nio</strong>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File originFile = <span class="keyword">new</span> File(<span class="string">"originFile.txt"</span>);</span><br><span class="line">File copyFile = <span class="keyword">new</span> File(<span class="string">"copyFile.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(originFile);</span><br><span class="line">     FileOutputStream  fos = <span class="keyword">new</span> FileOutputStream(copyFile);) &#123;</span><br><span class="line"></span><br><span class="line">    FileChannel inChannel = fis.getChannel();</span><br><span class="line">    FileChannel outChannel = fos.getChannel();</span><br><span class="line">    inChannel.transferTo(<span class="number">0</span>, inChannel.size(), outChannel);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而 Files.copy() 和 apache.common.FileUtils.copyFile() 则就是在这两种方式的基础上实现的。</p>
<p>Files.copy() 的实现要复杂一些，在不同的操作系统上有不同的实现，可以认为是<strong>本地实现</strong>的用户态空间拷贝，用户态空间的概念下面会说到。</p>
<p>Files.copy() 的可以理解为 java.io 中的实现，没有太大的差别。</p>
<p>apache.common 中的 FileUtils.copyFile() 就是使用 NIO 中 transferFrom 来实现:</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">    FileChannel input = fis.getChannel();</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destFile);</span><br><span class="line">    FileChannel output = fos.getChannel()) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> size = input.size(); </span><br><span class="line">    <span class="keyword">long</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; size) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> remain = size - pos;</span><br><span class="line">        count = remain &gt; FILE_COPY_BUFFER_SIZE ? FILE_COPY_BUFFER_SIZE : remain;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> bytesCopied = output.transferFrom(input, pos, count);</span><br><span class="line">        <span class="keyword">if</span> (bytesCopied == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        pos += bytesCopied;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以在 Java 中，实现文件复制的方法本质上只有两种，java.io 和 java.nio，那么这两种方式有什么区别呢？</p>
<p>在我 2015 年的 i5 8G 内存的 MacBook pro 上，用两种方式分别拷贝一个 12M 的 txt 文件， 5 次耗时（ms）如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>java.io</th>
<th>java.nio</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>161</td>
<td>45</td>
</tr>
<tr>
<td>2</td>
<td>193</td>
<td>29</td>
</tr>
<tr>
<td>3</td>
<td>179</td>
<td>31</td>
</tr>
<tr>
<td>4</td>
<td>185</td>
<td>35</td>
</tr>
<tr>
<td>5</td>
<td>145</td>
<td>53</td>
</tr>
</tbody>
</table>
<p>从上面的测试可以发现，使用 java.io 和 java.nio 来进行文件拷贝有着很大的性能差异，java.nio 占据绝对的优势。</p>
<h2>零拷贝技术</h2>
<p>如果要搞清楚这种差异，就需要了解操作系统中的<strong>用户态空间</strong>和<strong>内核态空间</strong>。</p>
<p>现代的操作系统中会将<a href="https://en.wikipedia.org/wiki/Virtual_memory" target="_blank" rel="noopener">虚拟内存</a>分成内核态空间和用户态空间两个部分，这样的划分方式是为了保护计算机不被恶意软件软件破坏。内核态空间中主要运行系统优先级比较高的应用，比如系统内核，硬件驱动等，而用户态空间中则主要运行普通的应用软件。</p>
<p>那么上面文件拷贝的例子和系统的用户态和内核态有什么关系？</p>
<p>我们都知道文件是存储在磁盘上的，如果我们要把文件从磁盘的一个位置拷贝到磁盘的另一个位置，是先需要将文件读取到计算机的内存当中，然后再把内存中的文件写入到指定的磁盘位置，这样才能完成拷贝。</p>
<p>而计算机的内存并不是一整块，而是分成了上面我们所说的用户态空间和内核态空间，java.io 和 java.nio 在文件拷贝过程中，对这些空间的使用方式不同，具体的区别如下。</p>
<p>如果我们使用 java.io 中的输入流来读取文件，那么整个过程是下面这样的：</p>
<p><img src="space1.png" alt=""></p>
<p>文件从磁盘读到内核态空间再读到用户空间的每一次切换过程都叫<strong>上下文切换</strong>，所以整个过程就是涉及到 4 次上下文切换。</p>
<p>而使用 java.nio 则是这样的：</p>
<p><img src="space2.png" alt=""></p>
<p>nio 的文件拷贝直接在内核态完成，整个过程仅仅需要 2 次上下文切换，所以就节省了很多时间，这个技术也称之为<strong>零拷贝</strong>。</p>
<p>使用零拷贝技术来拷贝文件不需要用户态的参与，每一次拷贝过程都节省了两次上下文切换和拷贝内存的占用。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>预言机不预测</title>
    <url>/2022/01/03/%E9%A2%84%E8%A8%80%E6%9C%BA%E4%B8%8D%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<p>以太坊网络出现之后，基于智能合约来实现的场景越来越多，Defi、链游、NFT。但是这些场景都会一个问题，只在链上这个封闭的世界运行，无法与真实的世界沟通。所谓流水不腐，只有打通了与现实世界的桥梁。区块链网络的生态才能更加完善。</p>
<p>讨论一个强需求的场景，比如某个人在以太网上有很多的资产。假设有一天这个人因为意外去世，那么他在链上的资产将会被完全锁死。如果有一种方式，可以设置一个类似遗嘱的合约，在他去世之后可以把他相关的资产都转移到一个地址，就可以解决这个问题。但这里有一个关键的问题需要解决，智能合约怎么获取他是否死亡的信息呢？</p>
<h2>1. 为什么需要预言机</h2>
<p>区块链是一个完全封闭的环境，在智能合约执行的过程中，不能引入不确定性，也就是说不能出现网络访问，因为网络访问是不确定的。</p>
<p>如果智能合约的执行结果不是确定的，那么就有可能造成节点之间数据的不同步。但是随着智能合约不断的发展，链需要从真实的实际去获取信息。</p>
<p>这些信息有可能是币价信息、股价信息、天气、真正的随机数等等。而智能合约获取这些数据的时候，需要通过确定性的方法，对于每一次数据的获取，所有节点获取到的数据是一致的。</p>
<p>为了达到这个目的，就需要预言机（oracle），这里的预言机不会预测任何事情，只是会将现实世界的数据传输到链上，供链上的智能合约使用。</p>
<p><img src="0.png" alt=""></p>
<h2>2. 预言机的几种实现方法</h2>
<p>预言机的实现原理其实都类似，一般来说会包含三个步骤：</p>
<ul>
<li>从链外的数据源搜集数据</li>
<li>将数据签名传输到区块链网络中</li>
<li>智能合约获取数据，在合约中使用</li>
</ul>
<p>因为智能合约本身是无法访问网络的，只能让预言机通过本地读取的方式来获取数据。而预言机服务本身有一部分也是区块链网络中的智能合约，这些智能合约会与链外的预言机网络进行交互。</p>
<p>预言机提供的数据获取方法大体上可以分成三类：</p>
<h3>2.1 直接读取</h3>
<p>这种方式通常用来获取那些不会改变的数据，比如某个人的生日、学历证明、出生地等等信息，这些信息确定后应该就不会再改变了。这类的数据通常只需要写到链上一次，然后就可以供其他的合约使用了。这些数据通常不会直接写到链上，而是会通过加盐再进行 hash 运算，最后只存储一个 hash 值。</p>
<p><img src="1.png" alt=""></p>
<p>这样做的原因有两个，一方面，可以减少数据的存储量，另外，出于隐私的保护，毕竟一些数据上链之后，就会永久存在了。</p>
<p>这样的好处在于，不需要合约之间进行频繁的交互，既节约时间，也节省成本。但只有一些特定的数据能够采用这种方式。</p>
<h3>2.2 发布与订阅</h3>
<p>很多数据并不一成不变的，比如天气信息、股票信息、币价信息，都在不断的变化，因此预言机网络需要不断的到链上来更新数据，每一类数据都可以看做是一个主体。而对某些数据感兴趣的智能合约则会订阅这些主题，在需要这些数据的时候来取。</p>
<p>还有一些合约可能会去监控这些数据的变化，那就需要不断的来轮询订阅的数据主题，这样可能会有比较高的成本（数据的轮询也是在运行代码，智能合约只要运行，就会产生成本）。</p>
<p><img src="2.png" alt=""></p>
<h3>2.3 请求与响应</h3>
<p>这也是获取数据最复杂的一种方式，这种方式用于获取一个独一无二的数据，或者数据量太大，无法全部写到链上。</p>
<p>比如常见的<strong>获取随机数</strong>。在智能合约中获取不到真正的随机数，需要从链外去获取。</p>
<p>这种模式中，预言机会接收其他合约的数据查询请求，然后预言机网络监听区块链网络相关的交易，如果发现数据请求，就会检查请求，比如是否已经付款。确认无误之后，就会将数据回调给请求数据的智能合约。</p>
<p><img src="3.png" alt=""></p>
<h2>3. 预言机的挑战</h2>
<p>预言机的最大挑战在于，怎么确保预言机提供的数据是可靠的。</p>
<p>从这个角度上来说，预言机可以分为两类，一类是中心化的预言机。我们通常会假设这个预言机不会造假，比如某个政府部门、大学等等。中心化的预言机会从两个方面来保证数据的可靠性。一方面通过签名来保证数据没有被篡改。另外一方面会提供一个可信的执行环境。</p>
<p>但是这样并不足以解决全部的问题，因为这些数据都需要信赖一些机构，没有办法保证这些机构不会造假，而且中心化的预言机容易出现故障，一旦出现故障，对链上的交易会产生很大的影响。这类预言机的代表是 Oraclize。</p>
<p>而以 Chainlink 为代表的去中心化预言机提供了另外一种解决方案。Chainlink 将数据的提供方组合起来，通过一套评价体系去给各个数据提供方打分，最后形成一个去中心化的预言机网络。</p>
<p>Chainlink 由<strong>声誉合约、订单匹配合约、数据汇总合约以及数据提供者的注册表构成</strong>。其中声誉合约用来维护数据提供者的表现。订单合约会从声誉合约的预言机中选择数据提供者。数据汇总合约最后会汇总计算得到的数据，并且会把结果返回给声誉合约。</p>
<p>通过这样的方式，chainlink 构建了一个去分布式预言机网络，解决了单点问题，也一定程度方防止了中心化机构数据造假的问题。</p>
<p>当前的 chainlink 还远没有达到完美，预言机的完善还有很长的路要走。</p>
<p>文 / Rayjun</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>Nostr 协议详解（科普篇）</title>
    <url>/2023/02/04/Nostr-%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%EF%BC%88%E7%A7%91%E6%99%AE%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h2>1. 关于 nostr</h2>
<p>nostr 是一个分布式的网络，但是很特别的是，这个网络不是 p2p 网络，也没有用到区块链技术，仅仅使用了公私钥体系。基本结构如下：</p>
<p><img src="Untitled.png" alt="Untitled"></p>
<p>nostr 网络中目前只有两个角色 relay 和 client。每一个节点被称之为 relay（中继服务器），普通用户是 client。由于没有实现 p2p 协议，每个 relay 之间并不会同步消息，每个 relay 都有自己的数据库存储，数据库的类型可以自行决定，目前用的比较多的是 sqlite 或者 Postgresql，其他的类的数据库也可以，要看 relay 的具体实现。</p>
<p>每个人使用的终端是 client，client 会和 relay 之间进行交互，使用 websocket + json 协议。</p>
<p>从 client 到 relay 支持三种操作:</p>
<ul>
<li>EVENT: 发布 event，发布消息、修改个人简介等等</li>
<li>REQ：搜索数据、订阅 relay 的新信息，比如你关注的用户发布了信息，就可以通过这个请求获取到</li>
<li>CLOSE：关闭 REQ 操作中的订阅</li>
</ul>
<p>从 relay 到 client 支持两种操作：</p>
<ul>
<li>EVENT: 返回用户订阅的 event 信息</li>
<li>NOTICE：返回可读的信息，这些信息的内容可以由 relay 自行决定</li>
</ul>
<p>其中最重要的就是 event 这个结构，用户有任何的数据新增或者修改，都是通过 event 来发布，为了防止 event 被篡改，发出的 event 都需要使用私钥签名，client 在收到 event 时会去验证这些签名。</p>
<p>relay 和 client 可以自行实现。目前 relay 的实现在这里可以看到：<a href="https://github.com/aljazceru/awesome-nostr" target="_blank" rel="noopener">https://github.com/aljazceru/awesome-nostr</a>。</p>
<p>client 实现中比较流行的有 Damus 和 snostr.social，在这里可以看到全部的 client 实现：<a href="https://github.com/vishalxl/Nostr-Clients-Features-List/blob/main/Readme.md" target="_blank" rel="noopener">https://github.com/vishalxl/Nostr-Clients-Features-List/blob/main/Readme.md</a>。</p>
<p>总体来说，nostr 协议很简单，完整的协议可以在这里看到（<a href="https://github.com/nostr-protocol/nips" target="_blank" rel="noopener">https://github.com/nostr-protocol/nips</a>），每一条协议都被称之为 nip，比如 nip-01 中就定义了 event 的基本结构。relay 和 client 的实现也很简单，一个 relay 的实现甚至只需要几千行代码。</p>
<h2>2. 核心数据结构 event</h2>
<p>event 的扩展性很强，可以定义各类的消息类型，目前已经定义的类型如下，后续还可以不断扩展。</p>
<ul>
<li>0 set_metadata: 设置用户的元数据，比如用户名，头像等等</li>
<li>1 text_note: 发布的消息，类似 twitter 的推文</li>
<li>2 recommend_server: 消息发布者推荐的一些中继服务器</li>
<li>3 contract_list: 当前用户的关注者列表</li>
<li>4 encrypted_direct_message: 加密消息</li>
<li>5 deletion: 删除消息</li>
<li>7 reactions: 点赞或者转发</li>
<li>40~44 public chat: 公共频道或者群聊</li>
<li>22242 auth: relay 和 client 之间的鉴权</li>
</ul>
<p>用户在发布消息时，都需要指定以上的一种类型，relay 会按照用户发送的类型来处理消息。可以这样来理解，只要是需要 relay 存储的信息，都必须是一个 event。</p>
<h2>3. nostr 的数据传播</h2>
<p>nostr 的目标就是创建一个完全去中心化的网络，它认为 twitter 的限制太多，比如广告太多、让人沉迷的信息流、可以随意封禁用户，它也认为 Mastodon 等协议太过于依赖第三方。所以 nostr 要让每个 relay、甚至每个用户自己来控制自己的数据。client 可以将消息发布到任意的 relay，由于消息都经过了签名，relay 无法篡改这些消息，所以也不需要关心 relay 是否是可信的。</p>
<p>在 nostr 中，如果一个 relay 把你封禁了，你也可以转发到其他的 relay。即使你是一个发布垃圾信息的人，也可以创建自己的 relay，然后发布消息，至于这些消息会不会被其他的 relay 和 client 抵制就是另外一回事了。</p>
<p>目前在 nostr 上发布一些文本量类的轻量级内容体验还可以，但是对于一些视频或者其他很重的内容，目前 nostr 支持的不好，这一点后续需要通过市场激励的方式来解决。</p>
<p>在 nostr 中，有一个很重要的问题需要解决，由于 relay 之间不同步数据，那么数据要怎么在整个网络中同步呢？nostr 的设计很巧妙，<strong>每个 relay 之间不同步消息，同步消息的机制由 client 来实现</strong>。client 通过发送 2、3 类型的 event， 可以把自己知道的用户及相关的 relay 地址传播到其他的 relay 中。这样其他的用户就可以通过这些信息找到目标用户的 relay，拉取到目标用户的消息，从而完成信息的传播。</p>
<p>这样做的好处在于每个 relay 不需要像区块链节点那样存储全量的数据。nostr 的这种数据存储方式类似于数据库分片，让每个 relay 的存储压力不那么大。当然这样做也有坏处，如果用户的消息只在某一个 relay 上，如果这个 relay 出现问题，就有可能导致数据永久丢失。</p>
<h2>4. 怎么防止垃圾信息</h2>
<p>在 nip-13 中， 定义了 pow 机制来增加发送垃圾消息的成本，但这样应该还不足以拦截垃圾信息。</p>
<p>在这个问题上，有另外一个思路，由于 relay 和 client 实现上的自由度很高，relay 和 client 可以自行决定可以传播什么样的信息，对哪些信息进行拦截，对一些恶意用户设置黑名单，然后在 relay 之间分享。</p>
<p>这样可以让 nostr 形成各种类型的社区，每个社区都有自己的规则，那些任由垃圾消息传播的社区会成为垃圾场，有着良好规则和优质内容的社区就会越来越庞大。</p>
<h2>5. 关于 nostr 的未来</h2>
<p>在 nostr 中，还有很重要的一个特性，可以很方便的集成闪电网络。目前用户可以在 client 上使用闪电网络进行转账，甚至有了一些实用性的功能，比如购买 nip-05 的认证。</p>
<p>对于闪电网络，还有更多的想象空间，比如在 twitter 上，任何人都可以给你发私信（DM），在 nostr 上，可以设置陌生人给你发私信时需要支付一些小额的比特币，从而屏蔽掉很多干扰。</p>
<p>当然 nostr 目前来看还是很粗糙，存在各种 bug，体验也比较差；基于公私钥机制，也解决不了账号丢失的问题。不过只要 nostr 有足够的生命力，这些都是可以被解决的。</p>
<p>参考链接：</p>
<p>[1] <a href="https://github.com/nostr-protocol/nips" target="_blank" rel="noopener">https://github.com/nostr-protocol/nips</a></p>
<p>[2] <a href="https://github.com/nostr-protocol/nostr" target="_blank" rel="noopener">https://github.com/nostr-protocol/nostr</a></p>
<p>[3] <a href="https://github.com/vishalxl/Nostr-Clients-Features-List/blob/main/Readme.md" target="_blank" rel="noopener">https://github.com/vishalxl/Nostr-Clients-Features-List/blob/main/Readme.md</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>nostr</tag>
      </tags>
  </entry>
</search>
